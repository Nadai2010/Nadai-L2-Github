
msgid ""
msgstr ""
"Project-Id-Version: L2 Book\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:3
msgid "Introducci√≥n"
msgstr ""

#: src/SUMMARY.md:4
msgid "Bases Criptogr√°ficas"
msgstr ""

#: src/SUMMARY.md:5
msgid "Criptograf√≠a Sim√©trica"
msgstr ""

#: src/SUMMARY.md:6
msgid "Criptograf√≠a Asim√©trica"
msgstr ""

#: src/SUMMARY.md:7
msgid "Criptograf√≠a H√≠bridas"
msgstr ""

#: src/SUMMARY.md:8
msgid "Firmas Digitales"
msgstr ""

#: src/SUMMARY.md:9
msgid "Generador de Claves"
msgstr ""

#: src/SUMMARY.md:10
msgid "Funciones Hash"
msgstr ""

#: src/SUMMARY.md:11
msgid "Merkle Tree en Blockchain"
msgstr ""

#: src/SUMMARY.md:12
msgid "Patricia Merkle Trie"
msgstr ""

#: src/SUMMARY.md:13
msgid "SHA-256"
msgstr ""

#: src/SUMMARY.md:14
msgid "Keccak - El nuevo SHA-3"
msgstr ""

#: src/SUMMARY.md:15
msgid "Quantum Secure"
msgstr ""

#: src/SUMMARY.md:16
msgid "Grover"
msgstr ""

#: src/SUMMARY.md:17
msgid "Shor"
msgstr ""

#: src/SUMMARY.md:18
msgid "Lattice"
msgstr ""

#: src/SUMMARY.md:19
msgid "Kyber Crystal"
msgstr ""

#: src/SUMMARY.md:20
msgid "EOA y AA - Firmantes"
msgstr ""

#: src/SUMMARY.md:21
msgid "Starknet AA"
msgstr ""

#: src/SUMMARY.md:22
msgid "EC en Cairo - STARK Curve"
msgstr ""

#: src/SUMMARY.md:23
msgid "MyBraavos Secp256r1"
msgstr ""

#: src/SUMMARY.md:24
msgid "Creaci√≥n de una Stark Key en StarkEx"
msgstr ""

#: src/SUMMARY.md:25
msgid "Starknet y Funciones Hash"
msgstr ""

#: src/SUMMARY.md:26
msgid "Hash Keccak"
msgstr ""

#: src/SUMMARY.md:27
msgid "Hash Pedersen"
msgstr ""

#: src/SUMMARY.md:28
msgid "Hash Poseidon"
msgstr ""

#: src/SUMMARY.md:29
msgid "Hashing de Array"
msgstr ""

#: src/SUMMARY.md:30
msgid "S-T-ARKs"
msgstr ""

#: src/SUMMARY.md:31
msgid "Propiedades de las STARKs"
msgstr ""

#: src/SUMMARY.md:32
msgid "STARKs eficientes"
msgstr ""

#: src/SUMMARY.md:33
msgid "IOPs"
msgstr ""

#: src/SUMMARY.md:34
msgid "Polinomios"
msgstr ""

#: src/SUMMARY.md:35
msgid "Creaci√≥n de un STARK"
msgstr ""

#: src/SUMMARY.md:36
msgid "Aritmetizaci√≥n"
msgstr ""

#: src/SUMMARY.md:37
msgid "Polinomio y Composici√≥n para nuestra Traza"
msgstr ""

#: src/SUMMARY.md:38
msgid "Pruebas de Bajo Grado"
msgstr ""

#: src/SUMMARY.md:39
msgid "FRI"
msgstr ""

#: src/SUMMARY.md:40
msgid "Leve introducci√≥n a Cairo (AIR)"
msgstr ""

#: src/SUMMARY.md:41
msgid "Conclusiones"
msgstr ""

#: src/SUMMARY.md:42
msgid "Arquitectura Starkware"
msgstr ""

#: src/SUMMARY.md:43
msgid "Otras Arquitecturas"
msgstr ""

#: src/Introducci√≥n.md:1
msgid "# Introducci√≥n"
msgstr ""

#: src/Introducci√≥n.md:3
msgid "¬°Hola comunidad! üëã"
msgstr ""

#: src/Introducci√≥n.md:5
msgid ""
"Antes que nada nos gustar√≠a expresar nuestro m√°s sincero agradecimiento a "
"todos aquellos que han contribuido y hecho posible la realizaci√≥n de esta "
"exhaustiva investigaci√≥n y documento sobre criptograf√≠a y como se adaptan en "
"StarkWare. Especial reconocimiento a los expertos @X, @Y, @Z y @A, quienes "
"han brindado sus valiosas correcciones y orientaci√≥n en numerosos aspectos "
"del trabajo. Su experiencia y conocimientos han sido fundamentales para "
"alcanzar los resultados y conclusiones presentados en este informe."
msgstr ""

#: src/Introducci√≥n.md:7
msgid ""
"En esta ocasi√≥n, estamos emocionados de presentar una serie de art√≠culos "
"profundos sobre el desarrollo detr√°s de Starkware. Recomendamos a los "
"lectores que previamente hayan le√≠do otros documentos y tengan conocimientos "
"t√©cnicos para una mejor comprensi√≥n, para este documento en concreto "
"recomendamos:"
msgstr ""

#: src/Introducci√≥n.md:9
msgid ""
"[Stark END-Game](https://starkware.co/resource/stark-endgame/) | [Recursive "
"Stark](https://starkware.co/resource/stark-endgame/) |  [Account "
"Abstraction](https://starkware.co/resource/account-abstraction-improving-security-and-user-experience-for-mainstream-crypto-adoption/) "
"| [Intro Maths Starks](https://starkware.co/stark-math-a-very-short-primer/)"
msgstr ""

#: src/Introducci√≥n.md:11
msgid ""
"El panorama actual es complejo, pero nos enorgullece contar con las mentes "
"m√°s brillantes trabajando en el ecosistema, una STARK que los une a todos."
msgstr ""

#: src/Introducci√≥n.md:13
msgid ""
"¬øEres o ser√°s uno de ellos? Antes de sumergirnos, exploraremos una serie de "
"conceptos para establecer bases e historias sobre criptograf√≠a, lo que nos "
"permitir√° adentrarnos a√∫n m√°s en el ecosistema STARKs. ¬°Comencemos!"
msgstr ""

#: src/Bases_Criptogr√°ficas.md:1
msgid "# Bases Criptogr√°ficas"
msgstr ""

#: src/Bases_Criptogr√°ficas.md:2
msgid ""
"La [**criptograf√≠a**](https://en.wikipedia.org/wiki/Cryptography) es el "
"campo de estudio y desarrollo de t√©cnicas y algoritmos para asegurar la "
"confidencialidad, integridad y autenticidad de la informaci√≥n. Utilizando "
"claves secretas o p√∫blicas, **la criptograf√≠a transforma los datos en un "
"formato incomprensible para terceros no autorizados**, garantizando que solo "
"los destinatarios leg√≠timos puedan acceder a la informaci√≥n original. La "
"criptograf√≠a desempe√±a un papel vital en la seguridad de las comunicaciones "
"y el almacenamiento de datos, protegiendo la privacidad y la confianza en "
"diversos √°mbitos de la vida moderna."
msgstr ""

#: src/Bases_Criptogr√°ficas.md:4
msgid ""
"* **Encryption:** [el cifrado](https://en.wikipedia.org/wiki/Encryption) es "
"el proceso de convertir informaci√≥n legible en un formato ilegible llamado "
"texto cifrado, mediante el uso de algoritmos y una clave. El objetivo "
"principal del cifrado es proteger la confidencialidad de los datos, "
"asegurando que solo las personas autorizadas puedan acceder y comprender la "
"informaci√≥n cifrada. Para ello, se aplica una serie de transformaciones "
"matem√°ticas al texto original, lo que dificulta su interpretaci√≥n sin la "
"clave correspondiente.\n"
"\n"
"* **Cryptographic protocol:** [un protocolo "
"criptogr√°fico](https://en.wikipedia.org/wiki/Cryptographic_protocol) o "
"protocolo de seguridad (tambi√©n llamado protocolo de cifrado) es un "
"protocolo abstracto o concreto que realiza funciones relacionadas con la "
"seguridad, aplicando m√©todos criptogr√°ficos.‚Äã Un protocolo describe la forma "
"en que un algoritmo debe usarse.\n"
"\n"
"* **Algorithm:** [un algoritmo](https://es.wikipedia.org/wiki/Algoritmo) de "
"cifrado es un procedimiento que convierte un mensaje de texto plano en un "
"texto cifrado. Los algoritmos modernos utilizan matem√°ticas avanzadas y una "
"o varias claves de cifrado. Esto hace que sea relativamente f√°cil cifrar un "
"mensaje, pero pr√°cticamente imposible descifrarlo sin conocer las claves "
"requeridas."
msgstr ""

#: src/Bases_Criptogr√°ficas.md:10
msgid "## Esquema de cifrado"
msgstr ""

#: src/Bases_Criptogr√°ficas.md:11
msgid ""
"Estos esquemas definen c√≥mo se realiza la transformaci√≥n de los datos "
"originales en texto cifrado y c√≥mo se realiza la operaci√≥n inversa para "
"recuperar los datos originales a partir del texto cifrado. Un esquema de "
"cifrado generalmente consta de los siguientes elementos:"
msgstr ""

#: src/Bases_Criptogr√°ficas.md:13
msgid ""
"* **Encryption Algorithm:** vimos que es el conjunto de operaciones "
"matem√°ticas utilizadas para cifrar los datos en texto cifrado.\n"
"\n"
"* **Decryption Algorithm:** es el conjunto de operaciones matem√°ticas "
"inversas utilizadas para descifrar el texto cifrado y recuperar los datos "
"originales.\n"
"\n"
"* **Key:** conocida como clave, es un valor secreto que se utiliza como "
"entrada para el algoritmo de cifrado. La key determina c√≥mo se realiza la "
"transformaci√≥n de los datos y es esencial para descifrar el texto cifrado.\n"
"\n"
"* **Protocols:** establecen c√≥mo se utiliza el esquema de cifrado, "
"incluyendo la generaci√≥n y distribuci√≥n segura de claves, el manejo de "
"errores y la gesti√≥n de la seguridad."
msgstr ""

#: src/Bases_Criptogr√°ficas.md:21
msgid "Existen varios tipos de esquemas de cifrado:"
msgstr ""

#: src/Bases_Criptogr√°ficas.md:23
msgid ""
"1. El [**cifrado "
"sim√©trico**](https://academy.bit2me.com/que-es-criptografia-simetrica/) "
"(donde se utiliza una sola clave tanto para cifrar como para descifrar),\n"
"\n"
"2. El [**cifrado "
"asim√©trico**](https://es.wikipedia.org/wiki/Criptograf%C3%ADa_asim%C3%A9trica) "
"o de clave p√∫blica (donde se utilizan pares de claves p√∫blica y privada)\n"
"\n"
"3. Otras variantes de esquemas de cifrados como de "
"[flujo](https://es.wikipedia.org/wiki/Cifrador_de_flujo) y de "
"[bloque](https://es.wikipedia.org/wiki/Cifrado_por_bloques). Cada esquema "
"tiene sus propias caracter√≠sticas y se utiliza en diferentes contextos seg√∫n "
"los requisitos de seguridad y las necesidades espec√≠ficas de la aplicaci√≥n, "
"pero nos centraremos en las principales para entender su funcionamiento "
"antes de pasar a la evoluci√≥n de las STARKs."
msgstr ""

#: src/Criptograf√≠a_Sim√©trica.md:1
msgid "## Criptograf√≠a Sim√©trica"
msgstr ""

#: src/Criptograf√≠a_Sim√©trica.md:2
msgid ""
"La historia de la criptograf√≠a sim√©trica se remonta a tiempos antiguos, pero "
"su uso moderno se consolid√≥ en el siglo XX con el desarrollo de m√©todos m√°s "
"sofisticados. Un ejemplo ic√≥nico es la [m√°quina "
"Enigma](https://en.wikipedia.org/wiki/Enigma_machine), utilizada por los "
"alemanes durante la Segunda Guerra Mundial para cifrar y descifrar mensajes, "
"esta m√°quina demostr√≥ la eficacia de la criptograf√≠a sim√©trica en entornos "
"militares."
msgstr ""

#: src/Criptograf√≠a_Sim√©trica.md:4
msgid ""
"Podemos ver la criptograf√≠a sim√©trica como una antigua y confiable llave "
"maestra en el mundo de la seguridad inform√°tica. Es una t√©cnica que ha sido "
"utilizada desde hace mucho tiempo y a√∫n en la actualidad sigue siendo "
"efectiva y segura para proteger informaci√≥n en diversas situaciones."
msgstr ""

#: src/Criptograf√≠a_Sim√©trica.md:6
msgid ""
"Imag√≠nate una llave que puede tanto cerrar como abrir una puerta. Los "
"algoritmos criptogr√°ficos de clave sim√©trica funcionan de manera similar, "
"utilizan la misma clave para cifrar el texto original y descifrar el texto "
"cifrado, esta clave compartida es como el secreto que solo t√∫ y los "
"destinatarios autorizados conocen."
msgstr ""

#: src/Criptograf√≠a_Sim√©trica.md:8
#: src/Criptograf√≠a_Asim√©trica.md:9
#: src/Merkle_Tree_en_Blockchain.md:8
#: src/Patricia_Merkle_Trie.md:16
#: src/Sha256.md:8
#: src/Keccak.md:18
#: src/Keccak.md:40
#: src/Starknet_AA.md:17
#: src/Starknet_AA.md:28
#: src/Starknet_AA.md:39
#: src/Stark_Curve.md:6
#: src/Stark_Curve.md:15
#: src/Stark_Curve.md:24
#: src/Secp256r1.md:6
#: src/Secp256r1.md:25
#: src/Stark_Key.md:40
#: src/Starknet_funciones_hash.md:9
#: src/Pedersen_Starknet.md:12
#: src/Pedersen_Starknet.md:24
#: src/Poseidon_Starknet.md:18
#: src/Hashing_Array.md:19
#: src/Hashing_Array.md:31
#: src/Starks.md:13
#: src/Starks.md:32
#: src/Starks_Propiedades.md:25
#: src/Starks_Propiedades.md:32
#: src/Starks_Propiedades.md:47
#: src/Starks_Eficientes.md:10
#: src/Starks_Creacion.md:21
msgid "graph"
msgstr ""

#: src/Criptograf√≠a_Sim√©trica.md:9
msgid ""
"<div align=\"center\">\n"
"<em>Criptograf√≠a Sim√©trica - √önica Key</em>\n"
"</div>"
msgstr ""

#: src/Criptograf√≠a_Sim√©trica.md:13
msgid ""
"Sin embargo, a medida que la tecnolog√≠a avanzaba y las capacidades de "
"c√≥mputo aumentaban, se hizo evidente que era necesario fortalecer los "
"sistemas de cifrado. Surgieron nuevos desaf√≠os y amenazas que requer√≠an "
"niveles m√°s altos de seguridad. Es por eso que se desarrollaron otros "
"m√©todos criptogr√°ficos, como la criptograf√≠a asim√©trica, que utiliza pares "
"de claves diferentes para el cifrado y el descifrado."
msgstr ""

#: src/Criptograf√≠a_Sim√©trica.md:15
msgid ""
"Aunque la criptograf√≠a sim√©trica ha evolucionado con el tiempo, todav√≠a se "
"utiliza ampliamente en muchos sistemas y aplicaciones. Su simplicidad y "
"eficiencia la convierten en una opci√≥n popular para proteger datos en redes "
"privadas, sistemas de comunicaci√≥n y almacenamiento de informaci√≥n sensible."
msgstr ""

#: src/Criptograf√≠a_Asim√©trica.md:1
msgid "# Criptograf√≠a Asim√©trica"
msgstr ""

#: src/Criptograf√≠a_Asim√©trica.md:2
msgid ""
"Ahora hablemos como el concepto de algoritmos criptogr√°ficos de clave "
"asim√©trica, fue un enfoque revolucionario que introdujo un concepto "
"completamente diferente, **el uso de un par de claves complementarias, una "
"p√∫blica y una privada**, para asegurar la confidencialidad de los datos. "
"Cada clave del par ten√≠a una funci√≥n espec√≠fica:"
msgstr ""

#: src/Criptograf√≠a_Asim√©trica.md:4
msgid ""
"* **Public key**: esta clave p√∫blica se compart√≠a abiertamente y se "
"utilizaba para cifrar la informaci√≥n.\n"
"* **Private key:** esta clave privada se guardaba cuidadosamente y se "
"utilizaba para descifrarla."
msgstr ""

#: src/Criptograf√≠a_Asim√©trica.md:7
msgid ""
"Con la criptograf√≠a de clave p√∫blica, los mensajes cifrados pod√≠an ser "
"transmitidos a trav√©s de redes inseguras sin el temor de que fueran "
"interceptados y descifrados por personas no autorizadas, pero en este caso "
"diferenci√°ndose de la sim√©trica en que estos mensajes requer√≠an un Private "
"key y una Public key. Era como si se hubiera descubierto una nueva forma de "
"comunicaci√≥n secreta y segura en el mundo digital, fue un avance "
"revolucionario en el campo de la criptograf√≠a."
msgstr ""

#: src/Criptograf√≠a_Asim√©trica.md:10
msgid ""
"<div align=\"center\">\n"
"<em>Criptograf√≠a Asim√©trica - Creaci√≥n de PK y PB</em>\n"
"</div>"
msgstr ""

#: src/Criptograf√≠a_Asim√©trica.md:14
msgid "Algunos de los m√°s destacados y utilizados son los siguiente:"
msgstr ""

#: src/Criptograf√≠a_Asim√©trica.md:16
msgid ""
"* **RSA -** [**Rivest-Shamir-Adleman:**](https://es.wikipedia.org/wiki/RSA) "
"es un sistema criptogr√°fico asim√©trico de clave p√∫blica desarrollado en "
"1979. Su seguridad radica en el problema de la factorizaci√≥n de n√∫meros "
"enteros y se utiliza en diversos √°mbitos de la transmisi√≥n de datos en "
"Internet debido a su facilidad de uso. Este sistema consta de una clave "
"p√∫blica RSA y una clave privada RSA.\n"
"\n"
"* **ECC -** [**Elliptic Curve "
"Cryptography:**](https://es.wikipedia.org/wiki/Criptograf%C3%ADa_de_curva_el%C3%ADptica) "
"en la d√©cada de 1980 se desarroll√≥ este enfoque de curva el√≠ptica "
"criptogr√°fica, una variante de la criptograf√≠a asim√©trica o de clave p√∫blica "
"basada en las matem√°ticas de las curvas el√≠pticas que proporciona niveles de "
"seguridad similares o superiores a RSA pero con claves m√°s cortas.\n"
"\n"
"* **ECDSA -** [**Elliptic Curve Digital Signature "
"Algorithm:**](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf) en "
"los A√±os 1990 naci√≥ ECDSA, un algoritmo de firma digital y autenticaci√≥n en "
"criptograf√≠a asim√©trica, basado en curvas el√≠pticas. Se utiliza en "
"criptograf√≠a para garantizar la autenticidad, integridad de los datos. ECDSA "
"se basa en la dificultad computacional de resolver el problema del logaritmo "
"discreto en curvas el√≠pticas."
msgstr ""

#: src/Criptograf√≠a_H√≠bridas.md:1
msgid "# Criptograf√≠a H√≠brida"
msgstr ""

#: src/Criptograf√≠a_H√≠bridas.md:2
msgid ""
"El [**cifrado "
"h√≠brido**](https://es.wikipedia.org/wiki/Criptograf%C3%ADa_h%C3%ADbrida) "
"utiliza las propiedades √∫nicas de la criptograf√≠a de clave p√∫blica para "
"intercambiar informaci√≥n secreta a trav√©s de un canal no confiable, "
"combinando la eficacia del cifrado sim√©trico. Esto proporciona una soluci√≥n "
"pr√°ctica de extremo a extremo para garantizar la privacidad de los datos."
msgstr ""

#: src/Criptograf√≠a_H√≠bridas.md:4
msgid ""
"Aunque los algoritmos de clave p√∫blica, como RSA-OAEP, son menos eficientes "
"que los algoritmos sim√©tricos, generalmente no se utilizan directamente para "
"cifrar los datos. Sin embargo, desempe√±an un papel importante en el "
"ecosistema criptogr√°fico al permitir el intercambio seguro de claves."
msgstr ""

#: src/Criptograf√≠a_H√≠bridas.md:6
msgid ""
"Para utilizar el cifrado sim√©trico, las partes deben compartir una clave. Si "
"ya existe un canal seguro, se puede enviar la clave a trav√©s de √©l. Sin "
"embargo, si no hay un canal seguro disponible, se resuelve el problema del "
"intercambio de claves utilizando la criptograf√≠a de clave p√∫blica."
msgstr ""

#: src/Criptograf√≠a_H√≠bridas.md:8
msgid ""
"* **DH -** "
"[**Diffie‚ÄìHellman:**](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange) "
"el intercambio de claves DH es un algoritmo criptogr√°fico de clave p√∫blica "
"dise√±ado espec√≠ficamente para acordar una clave sim√©trica en ausencia de un "
"canal seguro.\n"
"La combinaci√≥n de criptograf√≠a de clave p√∫blica para el intercambio de "
"claves y el cifrado sim√©trico para el cifrado de datos en masa se conoce "
"como cifrado h√≠brido."
msgstr ""

#: src/Criptograf√≠a_H√≠bridas.md:11
msgid ""
"El cifrado h√≠brido se utiliza ampliamente en los protocolos de transferencia "
"de datos para la web, como en la capa de seguridad de transporte "
"[(TLS)](https://en.wikipedia.org/wiki/Transport_Layer_Security). Cuando te "
"conectas a un sitio web que utiliza "
"[HTTPS](https://en.wikipedia.org/wiki/HTTPS) (HTTP seguro con TLS), tu "
"navegador negocia los algoritmos criptogr√°ficos que aseguran la conexi√≥n. "
"Estos algoritmos incluyen m√©todos para el intercambio de claves, cifrado "
"sim√©trico y firmas digitales."
msgstr ""

#: src/Firmas_Digitales.md:1
msgid "# Firmas digitales"
msgstr ""

#: src/Firmas_Digitales.md:2
msgid ""
"Los esquemas de firma digital son un tipo de criptograf√≠a de clave p√∫blica "
"que garantiza la integridad, autenticidad y no repudio de los datos."
msgstr ""

#: src/Firmas_Digitales.md:4
msgid ""
"Es importante destacar que el esquema de firma digital puede variar "
"dependiendo del algoritmo utilizado, ECDSA, es un ejemplo com√∫n de esquema "
"de firma basado en criptograf√≠a de curva el√≠ptica. Aqu√≠ EC recordemos que "
"representa la curva el√≠ptica utilizada y "
"[**DSA**](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm) (una "
"variante de los esquemas de firma "
"[Schnorr](https://en.wikipedia.org/wiki/Schnorr_signature) y "
"[ElGamal](https://en.wikipedia.org/wiki/ElGamal_signature_scheme)) el "
"algoritmo de firma digital. Cada esquema tiene sus propias caracter√≠sticas y "
"propiedades de seguridad, y se selecciona seg√∫n los requisitos y "
"consideraciones espec√≠ficas de la aplicaci√≥n."
msgstr ""

#: src/Firmas_Digitales.md:6
msgid ""
"Cuando se trata de firmas digitales, los pasos generales suelen ser los "
"siguientes:"
msgstr ""

#: src/Firmas_Digitales.md:8
msgid ""
"* **Key generation:** el Generador de Claves es un protocolo o algoritmo que "
"genera **un Keypar**, un par de claves asim√©tricas como se explic√≥ "
"anteriormente compuestas por una public key y una private key. En el caso de "
"la criptograf√≠a de curva el√≠ptica (como ECDSA), se generan los par√°metros "
"necesarios para definir la curva y se elige una clave privada aleatoria. A "
"partir de la clave privada, se calcula la clave p√∫blica correspondiente "
"utilizando operaciones matem√°ticas espec√≠ficas.\n"
"\n"
"* **Hash del mensaje:** antes de firmar el mensaje, se aplica una funci√≥n "
"hash criptogr√°fica al contenido del mensaje. Esto reduce el mensaje a un "
"valor de longitud fija llamado resumen o hash. El objetivo es garantizar la "
"integridad y eficiencia del proceso de firma, ya que es m√°s r√°pido firmar y "
"verificar un resumen m√°s corto que el mensaje completo.\n"
"\n"
"* **Digital Signature:** este proceso tiene el prop√≥sito de realizar una "
"serie de operaciones matem√°ticas utilizando la clave privada y el hash del "
"mensaje para generar la firma digital.\n"
"\n"
"* **Verify Signature:** para verificar la autenticidad de la firma, se "
"necesita la clave p√∫blica del firmante. Se aplica nuevamente la funci√≥n hash "
"al mensaje original y se utiliza la clave p√∫blica junto con la firma para "
"realizar operaciones matem√°ticas espec√≠ficas. Si el resultado coincide con "
"la firma original, se considera que la firma es v√°lida y se confirma la "
"autenticidad del mensaje y del firmante."
msgstr ""

#: src/Firmas_Digitales.md:16
msgid ""
"El proceso de firma puede considerarse como el cifrado del archivo mediante "
"la clave privada. Para ello, la persona que firma utiliza su clave privada "
"para producir una firma."
msgstr ""

#: src/Firmas_Digitales.md:18
msgid ""
"Exploraremos a continuaci√≥n la relevancia de los diversos esquemas de firmas "
"para garantizar la seguridad de nuestros datos, as√≠ como la forma en que "
"Starknet usa AA para abstraer la firma de la validaci√≥n. En este contexto, "
"se pueden dise√±ar diferentes esquemas o configuraciones, como el "
"`secp256r1`, una variante de STARK Curve, la versi√≥n amigable de ECDSA "
"optimizada en Starknet. Este esquema de firma se puede utilizar para "
"incorporar firmas en dispositivos modernos de manera biom√©trica, aislada y "
"abstra√≠da por naturaleza, lo que mejora significativamente la eficiencia, "
"tal como se discutir√° en detalle m√°s adelante."
msgstr ""

#: src/Firmas_Digitales.md:20
msgid ""
"Por lo tanto, resulta crucial abordar el siguiente apartado relacionado con "
"el uso de Key generation que desempe√±an un papel fundamental en este "
"contexto."
msgstr ""

#: src/Generador_de_Claves.md:1
msgid "# Key generator"
msgstr ""

#: src/Generador_de_Claves.md:2
msgid ""
"Tenemos que entender c√≥mo el generador de claves [**(Key "
"generator)**](https://en.wikipedia.org/wiki/Key_generator) genera el "
"Keypair, para lograrlo, es necesario trabajar con valores pseudoaleatorios "
"que se utilizan en la generaci√≥n de la private key. Un Key generator se "
"puede implementar en un sistema con el prop√≥sito de generar y autenticar "
"claves."
msgstr ""

#: src/Generador_de_Claves.md:4
msgid ""
"Key generator puede implementarse en cualquier sistema criptogr√°fico que "
"utilice la curva el√≠ptica, como es el caso de `secp256k1` (una curva "
"optimizada basada en las propiedades matem√°ticas de las curvas el√≠pticas "
"para proporcionar un esquema de firma digital seguro y eficiente), como "
"Bitcoin y Ethereum."
msgstr ""

#: src/Generador_de_Claves.md:6
msgid ""
"Este generador de claves garantiza que, con alta probabilidad, las claves "
"privadas generadas sean √∫nicas y seguras, lo que a su vez respalda la "
"integridad y autenticidad de las transacciones realizadas en la red."
msgstr ""

#: src/Generador_de_Claves.md:8
msgid "## Generadores de n√∫meros pseudoaleatorios"
msgstr ""

#: src/Generador_de_Claves.md:9
msgid ""
"Para garantizar la seguridad usando la pseudoaleatoriedad estad√≠stica de un "
"**PRNG -** [**Pseudorandom number "
"generator**](https://en.wikipedia.org/wiki/Pseudorandom_number_generator), "
"es crucial contar con una semilla inicial. Si la semilla es f√°cilmente "
"predecible, generar√° valores predecibles de n√∫meros y todo el proceso ser√° "
"inseguro."
msgstr ""

#: src/Generador_de_Claves.md:11
msgid ""
"Para lograr una inicializaci√≥n segura del generador pseudoaleatorio, es "
"necesario recolectar "
"[**Entrop√≠a**](https://en.wikipedia.org/wiki/Entropy_(computing)), que "
"representa la aleatoriedad necesaria en el proceso."
msgstr ""

#: src/Generador_de_Claves.md:13
msgid "## Entrop√≠a"
msgstr ""

#: src/Generador_de_Claves.md:14
msgid ""
"La entrop√≠a o aleatoriedad impredecible en computaci√≥n, generalmente se mide "
"en bits. Tenemos varios ejemplos para entender el concepto y grado de "
"aleatoriedad. Si mueve el mouse de su computadora, generar√° algunos eventos "
"dif√≠ciles de predecir, como la ubicaci√≥n de inicio y la ubicaci√≥n final del "
"cursor del mouse."
msgstr ""

#: src/Generador_de_Claves.md:16
msgid ""
"> Si suponemos que el mouse ha cambiado su posici√≥n en el rango de `[ 0 ... "
"255 p√≠xeles ]`, la entrop√≠a recolectada de este movimiento del mouse debe "
"ser de aproximadamente **8 bits**, porque `2‚Å∏ = 255`"
msgstr ""

#: src/Generador_de_Claves.md:18
msgid ""
"> Si se le pide al usuario que piense en un n√∫mero en el rango `[ 0 ... 1000 "
"]`, este n√∫mero tendr√° alrededor de **9-10 bits** de entrop√≠a porque, `2¬π‚Å∞ = "
"1024`"
msgstr ""

#: src/Generador_de_Claves.md:20
msgid ""
"Para recolectar 256 bits de entrop√≠a, es decir, para generar de forma segura "
"un n√∫mero entero de 256 bits, deber√° tener en cuenta una secuencia de varios "
"eventos similares (como movimientos del mouse e interracidades del teclado "
"del usuario)."
msgstr ""

#: src/Generador_de_Claves.md:22
msgid ""
"Aqu√≠ la importancia de d√≥nde y c√≥mo hemos generado nuestras claves privadas "
"y p√∫blicas y las posibles vulnerabilidades en algunos malos usos."
msgstr ""

#: src/Funciones_Hash.md:1
msgid "# Funciones hash y funciones hash criptogr√°ficas"
msgstr ""

#: src/Funciones_Hash.md:2
msgid ""
"Este apartado es de suma importancia para comprender el funcionamiento de "
"las funciones hash. A diferencia de los esquemas de cifrado o las firmas, "
"las funciones hash no requieren de una clave. Cualquier persona puede "
"calcular el hash de una entrada determinada, y la funci√≥n hash siempre "
"producir√° la misma salida para la misma entrada."
msgstr ""

#: src/Funciones_Hash.md:4
msgid ""
"As√≠ que podemos definir una [**funci√≥n "
"hash**](https://en.wikipedia.org/wiki/Hash_function) como un algoritmo que "
"toma una entrada, como un mensaje o un archivo, y produce una salida de "
"longitud fija llamada hash o resumen. Esta salida es √∫nica para cada entrada "
"espec√≠fica, lo que permite la verificaci√≥n de la integridad de los datos y "
"garantiza que cualquier cambio en la entrada resultar√° en un hash "
"completamente diferente."
msgstr ""

#: src/Funciones_Hash.md:6
msgid ""
"Una [**funci√≥n hash "
"criptogr√°fica**](https://en.wikipedia.org/wiki/Cryptographic_hash_function), "
"por otro lado, es aquella funci√≥n hash que se utiliza en el √°mbito de la "
"criptograf√≠a, para evaluar la seguridad de una funci√≥n de hash "
"criptogr√°fica, se consideran las siguientes propiedades:"
msgstr ""

#: src/Funciones_Hash.md:8
msgid ""
"* **Resistencia a la preimagen:** partiendo de un valor `hash h`, es dif√≠cil "
"encontrar un mensaje `m` que genere ese `hash`, es decir, `h = hash(m)`, "
"este concepto est√° relacionado con el de una funci√≥n de sentido √∫nico. Las "
"funciones que carecen de esta propiedad son vulnerables a ataques de "
"preimagen.\n"
"* **Resistencia a la segunda preimagen:** dado un mensaje `m‚ÇÅ`, es dif√≠cil "
"encontrar otro mensaje `m‚ÇÇ` distinto a `m‚ÇÅ` que produzca el mismo valor de "
"hash, es decir, `hash(m‚ÇÅ) = hash(m‚ÇÇ)`. Esta propiedad tambi√©n se conoce como "
"resistencia d√©bil a colisiones. Las funciones que no cumplen esta propiedad "
"son vulnerables a ataques de segunda preimagen.\n"
"* **Resistencia a colisiones:** es dif√≠cil encontrar dos mensajes diferentes "
"`m‚ÇÅ` y `m‚ÇÇ` que produzcan el mismo valor de hash, es decir, `hash(m‚ÇÅ) = "
"hash(m‚ÇÇ)`. Estas colisiones son conocidas como colisiones criptogr√°ficas de "
"hash. Esta propiedad tambi√©n se conoce como resistencia fuerte a colisiones. "
"Se requiere que el tama√±o del hash sea al menos el doble de largo para "
"garantizar la resistencia a la preimagen."
msgstr ""

#: src/Merkle_Tree_en_Blockchain.md:1
msgid "# Merkle Tree en Blockchain"
msgstr ""

#: src/Merkle_Tree_en_Blockchain.md:2
msgid ""
"Ahora que hemos comprendido mejor qu√© es un hash, veamos c√≥mo en "
"criptograf√≠a y [ciencias de la "
"computaci√≥n](https://en.wikipedia.org/wiki/Computer_science), un √°rbol hash, "
"tambi√©n conocido c√≥mo [**Merkle Tree o binary Merkle "
"tree**](https://en.wikipedia.org/wiki/Merkle_tree), es una [estructura de "
"datos](https://en.wikipedia.org/wiki/Data_structure) utilizada para "
"garantizar la integridad de los contenidos almacenados en un sistema, como "
"la tecnolog√≠a blockchain."
msgstr ""

#: src/Merkle_Tree_en_Blockchain.md:4
msgid ""
"Podemos ver los Merkle Trees como una estructura de √°rbol en la que cada "
"\"hoja\" o nodo terminal, est√° etiquetado con el hash criptogr√°fico de un "
"bloque de datos. A su vez, cada nodo que no es una hoja, tambi√©n conocido "
"como rama, nodo interior o inodo, est√° etiquetado con el hash criptogr√°fico "
"de las etiquetas de sus nodos secundarios."
msgstr ""

#: src/Merkle_Tree_en_Blockchain.md:6
msgid ""
"La construcci√≥n de un Merkle Tree implica dividir los datos en bloques m√°s "
"peque√±os y aplicar una funci√≥n de hash criptogr√°fico a cada uno de ellos. "
"Luego, los bloques hash se combinan en pares y se vuelven a hashear, "
"repitiendo este proceso hasta obtener un √∫nico hash llamado ra√≠z de Merkle o "
"‚ÄúMerkle root‚Äù. Esta ra√≠z se coloca en la cabecera de un bloque o transacci√≥n "
"y se utiliza como una firma digital que representa y verifica la integridad "
"de todos los datos incluidos en el bloque."
msgstr ""

#: src/Merkle_Tree_en_Blockchain.md:9
msgid ""
"<div align=\"center\">\n"
"<em>Ejemplo de estructura de un Merkle Tree</em>\n"
"</div>"
msgstr ""

#: src/Merkle_Tree_en_Blockchain.md:13
msgid ""
"Una de las principales ventajas de los Merkle Trees es su capacidad para "
"proporcionar una verificaci√≥n eficiente y segura de los contenidos de una "
"gran estructura de datos. Como cada nodo intermedio en el √°rbol est√° "
"etiquetado con el hash criptogr√°fico de las etiquetas de sus nodos "
"secundarios, cualquier cambio realizado en los datos se reflejar√° en cambios "
"en los hashes correspondientes."
msgstr ""

#: src/Merkle_Tree_en_Blockchain.md:15
msgid ""
"En la tecnolog√≠a blockchain que usan los Merkle Trees, los utilizan para "
"garantizar la integridad de los datos almacenados en cada bloque de la "
"cadena. Cada bloque contiene una lista de transacciones, y el Merkle Tree se "
"construye utilizando los hashes de estas transacciones."
msgstr ""

#: src/Merkle_Tree_en_Blockchain.md:17
msgid ""
"Cuando se agrega un nuevo bloque a la cadena, la ra√≠z de Merkle del bloque "
"anterior se incluye en el nuevo bloque, creando una cadena enlazada de "
"√°rboles de Merkle. Esto permite verificar r√°pidamente la integridad de "
"cualquier bloque en la cadena sin necesidad de verificar todos los datos "
"desde el inicio. Adem√°s, si alg√∫n dato se modifica en un bloque, el hash del "
"bloque cambiar√°, lo que afectar√° la ra√≠z de Merkle y se√±alar√° la alteraci√≥n "
"en la cadena."
msgstr ""

#: src/Merkle_Tree_en_Blockchain.md:19
msgid ""
"Algunos casos posibles de uso de los binary Merkle Trees para los diferentes "
"esquemas pueden ser:"
msgstr ""

#: src/Merkle_Tree_en_Blockchain.md:21
msgid ""
"* **Los binary Merkle Trees:** son estructuras de datos muy eficientes para "
"autenticar informaci√≥n que se presenta en formato de \"lista\", es decir, "
"una secuencia de elementos consecutivos.\n"
"* **Los transaction trees:** tambi√©n resultan beneficiosos, ya que una vez "
"creado el √°rbol, no importa cu√°nto tiempo se tarde en editarlo, ya que "
"permanecer√° inmutable.\n"
"* **Los State trees:** sin embargo, cuando se trata de un √°rbol que almacena "
"estados la situaci√≥n se vuelve m√°s compleja, el estado en Ethereum, que "
"consiste en un mapa de valores clave donde:\n"
"    * **Las claves son direcciones**\n"
"    * **Los valores son las declaraciones de cuenta que incluyen:** saldo, "
"nonce, c√≥digo y almacenamiento asociados a cada cuenta, r\n"
"    * **Requiere la construcci√≥n de una prueba de transici√≥n de estado de "
"Merkle** [(Merkle state transition "
"proof)](https://medium.com/@chiqing/verify-ethereum-account-balance-with-state-proof-83b51ceb15cf)"
msgstr ""

#: src/Merkle_Tree_en_Blockchain.md:28
msgid ""
"As√≠ que, comprender el funcionamiento de los State Trees y su optimizaci√≥n "
"de datos es crucial en el contexto actual donde los datos y los hashes "
"desempe√±an un papel fundamental. En el caso de Ethereum, uno de los "
"principales actores en el √°mbito de los State Trees, se han incorporado "
"modificaciones interesantes usando Patricia Merkle Trie."
msgstr ""

#: src/Patricia_Merkle_Trie.md:1
msgid "# Patricia Merkle Trie"
msgstr ""

#: src/Patricia_Merkle_Trie.md:2
msgid ""
"La especificaci√≥n de Ethereum define el [**Modified Merkle Patricia "
"Trie**](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/) "
"(tambi√©n conocido como MPT) este m√©todo se utiliza para guardar estados. "
"B√°sicamente, el MPT es una combinaci√≥n del Patricia trie y el Merkle tree, "
"con algunas optimizaciones adicionales adaptadas a las caracter√≠sticas de "
"Ethereum."
msgstr ""

#: src/Patricia_Merkle_Trie.md:4
msgid ""
"Patricia trie, [(Radix tree o Radix "
"trie)](https://en.wikipedia.org/wiki/Radix_tree), √°rbol de prefijos compacto "
"**(compact prefix tree)** o √°rbol de prefijos comprimido **(compressed "
"trie)**, es una sofisticada estructura de datos que ofrece una optimizaci√≥n "
"espacial en la representaci√≥n de [Tries] (√°rboles de prefijos). Una de las "
"caracter√≠sticas clave de este tipo de √°rbol es la fusi√≥n de nodos cuando un "
"nodo es hijo √∫nico de su padre, lo que contribuye a una mayor eficiencia y "
"rendimiento."
msgstr ""

#: src/Patricia_Merkle_Trie.md:6
msgid ""
"Esta estructura es un tipo de **√°rbol de b√∫squeda k-ary**, siendo un [m-ary "
"tree](https://en.wikipedia.org/wiki/M-ary_tree) (tambi√©n conocido como "
"`n-ary tree`, `k-ary tree` o `k-way tree`) un √°rbol ra√≠z en el cual cada "
"nodo tiene como m√°ximo m hijos. Ambas estructuras de datos se utilizan para "
"localizar claves espec√≠ficas dentro de un conjunto."
msgstr ""

#: src/Patricia_Merkle_Trie.md:8
msgid ""
"Estos √°rboles son completamente deterministas, lo que significa que aquellos "
"con las mismas asociaciones de (clave, valor) est√°n garantizados de ser "
"id√©nticos, hasta el √∫ltimo byte. Esto asegura que tengan el mismo hash ra√≠z, "
"lo que proporciona la deseada eficiencia de `O(log(n))` para inserciones, "
"b√∫squedas y eliminaciones. Adem√°s, son m√°s f√°ciles de entender y programar "
"que alternativas m√°s complejas basadas en comparaciones, como los [red-black "
"tree.](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)"
msgstr ""

#: src/Patricia_Merkle_Trie.md:10
msgid ""
"El Patricia Merkle Trie combina la estructura de un √°rbol de b√∫squeda "
"binario con la estructura de √°rbol de Merkle, lo cual permite verificar "
"eficientemente la integridad de los datos y proporciona una representaci√≥n "
"compacta del estado completo de la cadena."
msgstr ""

#: src/Patricia_Merkle_Trie.md:12
msgid ""
"El uso del Patricia Merkle Trie en Ethereum ofrece ventajas significativas "
"en t√©rminos de eficiencia y escalabilidad. Permite realizar consultas "
"r√°pidas sobre el estado de las cuentas y los contratos, evitando la "
"necesidad de recorrer todo el estado completo. En cambio, solo es necesario "
"verificar y acceder a los nodos relevantes en el √°rbol, lo que ahorra tiempo "
"y recursos."
msgstr ""

#: src/Patricia_Merkle_Trie.md:14
msgid ""
"Adem√°s, esta estructura de √°rbol facilita la implementaci√≥n de funciones de "
"snapshot y revert en Ethereum. Estas funciones permiten crear instant√°neas "
"del estado del sistema en momentos espec√≠ficos y revertir cambios en caso de "
"errores o ataques, brindando una capa adicional de seguridad y confiabilidad "
"a la red blockchain."
msgstr ""

#: src/Patricia_Merkle_Trie.md:17
#: src/Keccak.md:19
#: src/Stark_Curve.md:7
#: src/Stark_Curve.md:16
#: src/Stark_Curve.md:25
#: src/Secp256r1.md:7
#: src/Secp256r1.md:26
#: src/Stark_Key.md:41
#: src/Pedersen_Starknet.md:13
#: src/Pedersen_Starknet.md:25
#: src/Poseidon_Starknet.md:19
#: src/Hashing_Array.md:20
#: src/Hashing_Array.md:32
#: src/Starks.md:14
#: src/Starks.md:33
#: src/Starks_Propiedades.md:26
#: src/Starks_Propiedades.md:33
#: src/Starks_Propiedades.md:48
#: src/Starks_Eficientes.md:11
#: src/Starks_Creacion.md:22
msgid ""
"<div align=\"center\">\n"
"<em></em>\n"
"</div>"
msgstr ""

#: src/Patricia_Merkle_Trie.md:21
msgid ""
"La comprensi√≥n de los Merkle Trees y el MPT resulta especialmente relevante "
"al explorar otras estructuras de datos criptogr√°ficas, como las Merkle "
"Mountain Ranges (MMRs) en Herodotus para las Storage Proof. Las MMRs pueden "
"considerarse una lista de √Årboles de Merkle, donde cada √°rbol se representa "
"como una monta√±a y la lista completa forma el rango. La utilizaci√≥n de "
"funciones hash espec√≠ficas y sus caracter√≠sticas de seguridad se explorar√°n "
"para comprender c√≥mo crear estos √°rboles de manera eficiente y √≥ptima."
msgstr ""

#: src/Patricia_Merkle_Trie.md:23
msgid ""
"Por lo tanto, es crucial comprender a fondo las diferentes funciones hash y "
"sus propiedades para tomar decisiones informadas sobre la selecci√≥n y "
"optimizaci√≥n de las mismas en la construcci√≥n de estructuras de datos "
"criptogr√°ficas m√°s eficientes y seguras en los √Årboles de Merkle."
msgstr ""

#: src/Patricia_Merkle_Trie.md:25
msgid ""
"Las funciones hash desempe√±an un papel fundamental en garantizar la "
"integridad y la seguridad de los datos almacenados en los √°rboles de Merkle, "
"ya que se utilizan para calcular los hashes de los nodos y verificar su "
"integridad durante la construcci√≥n y la verificaci√≥n del √°rbol."
msgstr ""

#: src/Sha256.md:1
msgid "# SHA-256"
msgstr ""

#: src/Sha256.md:2
msgid ""
"Es hora de examinar algunos ejemplos de funciones hash criptogr√°ficas "
"ampliamente utilizadas, un ejemplo es `SHA-256` [**(Secure Hash Algorithm "
"256-bit)**](https://es.wikipedia.org/wiki/SHA-2), **que es una funci√≥n de "
"hash criptogr√°fica perteneciente a la familia de algoritmos SHA-2.** Esta "
"funci√≥n acepta una entrada de cualquier longitud y genera una salida de 256 "
"bits que se considera √∫nica y asociada de forma irreversible a dicha entrada."
msgstr ""

#: src/Sha256.md:4
msgid ""
"Pueden probar la generaci√≥n de un hash utilizando cualquier [generador en "
"l√≠nea](https://miniwebtool.com/es/sha256-hash-generator/). En este caso, "
"[realizamos pruebas](https://bfotool.com/category/encode-decoder) utilizando "
"la funci√≥n hash `SHA-256` y `keccak-256`, tambi√©n pueden explorar y probar "
"[m√°s funciones hash desde aqu√≠.](https://bfotool.com/category/encode-decoder)"
msgstr ""

#: src/Sha256.md:6
msgid ""
"El cambio de un solo bit causa un efecto avalancha, lo que significa que "
"incluso un cambio m√≠nimo como un `.` en la entrada, produce un cambio "
"significativo en la salida. Puedes revisar el hash de `L2 en Espa√±ol` y `L2 "
"en Espa√±ol.`"
msgstr ""

#: src/Sha256.md:9
msgid ""
"<div align=\"center\">\n"
"<em>Salida de datos completamente diferente a√±adiendo un \".\"</em>\n"
"</div>"
msgstr ""

#: src/Sha256.md:13
msgid ""
"`SHA-256` se utiliza ampliamente en criptograf√≠a, y cuenta con diversos "
"casos de uso destacados:"
msgstr ""

#: src/Sha256.md:15
msgid ""
"1. **Verificaci√≥n de integridad:** `SHA-256` se utiliza para verificar la "
"integridad de los datos almacenados en un sistema. Al calcular el hash de un "
"archivo o conjunto de datos, se puede comparar con el hash original para "
"detectar cualquier cambio o alteraci√≥n en los datos.\n"
"2. **Firmas digitales:** las firmas digitales se generan mediante algoritmos "
"criptogr√°ficos y se basan en la funci√≥n SHA-256 para asegurar la "
"autenticidad e integridad de los mensajes. El hash `SHA-256` se utiliza para "
"resumir y proteger la informaci√≥n que se firma digitalmente.\n"
"3. **Almacenamiento seguro de contrase√±as:** en lugar de almacenar "
"contrase√±as en texto plano, los sistemas de seguridad suelen almacenar el "
"hash `SHA-256` de las contrase√±as. Cuando un usuario ingresa su contrase√±a, "
"se calcula el hash y se compara con el valor almacenado, lo que permite "
"verificar la autenticidad de la contrase√±a sin almacenarla directamente.\n"
"4. **Generaci√≥n de claves criptogr√°ficas:** `SHA-256` se utiliza en "
"algoritmos de generaci√≥n de claves criptogr√°ficas para producir claves "
"aleatorias y seguras."
msgstr ""

#: src/Sha256.md:20
msgid ""
"En resumen, `SHA-256` es una funci√≥n hash criptogr√°fica ampliamente "
"utilizada que forma parte de la familia de algoritmos `SHA-2`, la hace ideal "
"para verificar la integridad de los datos, generar firmas digitales, "
"almacenar contrase√±as de forma segura y generar claves criptogr√°ficas. "
"`SHA-256` ha demostrado su robustez y eficacia en numerosos casos de uso en "
"criptograf√≠a. Ahora es el turno de explorar otra funci√≥n hash criptogr√°fica "
"m√°s moderna llamada Keccak."
msgstr ""

#: src/Keccak.md:1
msgid "# Keccak - El nuevo SHA-3"
msgstr ""

#: src/Keccak.md:2
msgid ""
"Ahora nos centraremos en el `SHA-3` [**(Secure Hash Algorithm "
"3)**](https://en.wikipedia.org/wiki/SHA-3), es un est√°ndar de funci√≥n hash "
"criptogr√°fica dise√±ado por los cript√≥grafos Joan Daemen y Gilles Van Assche. "
"El algoritmo utilizado en `SHA-3` se llama "
"[**Keccak**](https://keccak.team/index.html), el cual fue [**seleccionado "
"como el ganador del "
"concurso**](https://www.federalregister.gov/documents/2015/08/05/2015-19181/announcing-approval-of-federal-information-processing-standard-fips-202-sha-3-standard) "
"organizado por el Instituto Nacional de Est√°ndares y Tecnolog√≠a "
"[(NIST)](https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology) "
"para encontrar un nuevo est√°ndar de funci√≥n hash criptogr√°fica."
msgstr ""

#: src/Keccak.md:4
msgid ""
"A diferencia de `SHA-256`, `Keccak` utiliza una estructura y operaciones "
"diferentes. En lugar de rondas, `Keccak` se basa en una construcci√≥n llamada "
"funci√≥n de esponja [(Sponge "
"function)](https://en.wikipedia.org/wiki/Sponge_function), que se basa en "
"una funci√≥n pseudoaleatoria amplia o "
"[(permutation)](https://keccak.team/glossary.html#permutation) "
"pseudoaleatorio permitiendo ingresar **\"absorbing\"** y **\"squeezing\"**."
msgstr ""

#: src/Keccak.md:6
msgid ""
"`Keccak-256` es una funci√≥n hash criptogr√°fica utilizada en Ethereum. "
"Pertenece a la familia de algoritmos `SHA-3` y se emplea ampliamente en la "
"plataforma Ethereum para diversos prop√≥sitos."
msgstr ""

#: src/Keccak.md:8
msgid "Algunos casos de uso de `Keccak-256` incluyen:"
msgstr ""

#: src/Keccak.md:10
msgid ""
"* Ethereum utiliza `Keccak-256` para garantizar la integridad de los datos y "
"generar identificadores √∫nicos (hash) para verificar la autenticidad de los "
"archivos y mensajes en sistemas criptogr√°ficos.\n"
"* Tambi√©n se utiliza en la firma criptogr√°fica de peque√±o tama√±o, donde en "
"lugar de firmar la entrada completa, se firma el hash `Keccak-256` del "
"mensaje o dato.\n"
"* `Keccak-256` es utilizado para obtener una identificaci√≥n √∫nica y "
"determinista de una colecci√≥n de datos. Por ejemplo, en Ethereum, las "
"direcciones de Ethereum se derivan de claves p√∫blicas o contratos utilizando "
"la funci√≥n hash unidireccional `Keccak-256`."
msgstr ""

#: src/Keccak.md:14
msgid ""
"Las direcciones Ethereum son n√∫meros hexadecimales, identificadores "
"derivados de los √∫ltimos 20 bytes del hash `Keccak-256` de la clave p√∫blica."
msgstr ""

#: src/Keccak.md:16
msgid ""
"A diferencia de las direcciones de Bitcoin, que est√°n codificadas en la "
"interfaz de usuario de todos los clientes para incluir una suma de "
"verificaci√≥n incorporada para proteger contra direcciones mal escritas, las "
"direcciones de Ethereum se presentan como hexadecimales sin ninguna suma de "
"verificaci√≥n."
msgstr ""

#: src/Keccak.md:23
msgid ""
"El algoritmo **Keccak** utiliza la [**Sponge "
"construction**](https://keccak.team/glossary.html#sponge_construction) para "
"procesar los datos de entrada de longitud variable para generar una salida "
"de longitud variable. Esta construcci√≥n se basa en una funci√≥n interna "
"llamada `\"F\"` que opera en un n√∫mero fijo de bits, denotado como "
"`\"width\"` [(anchura)](https://keccak.team/glossary.html#width)."
msgstr ""

#: src/Keccak.md:25
msgid ""
"La anchura total del algoritmo Keccak se determina sumando dos componentes, "
"el valor de `\"r\"` [(rate)](https://keccak.team/glossary.html#rate) y el "
"valor de `\"c\"` [(capacity)](https://keccak.team/glossary.html#capacity), "
"donde `b = r + c`."
msgstr ""

#: src/Keccak.md:27
msgid ""
"* El valor de `\"r\"` representa la cantidad de bits absorbidos en cada paso "
"de la funci√≥n esponja, es decir, **la capacidad de absorci√≥n de la "
"esponja.** Un valor de `\"r\"` m√°s grande permite procesar m√°s informaci√≥n "
"en cada paso, lo que reduce la cantidad de pasos necesarios para procesar "
"una entrada espec√≠fica.\n"
"* El valor de `\"c\"` representa la capacidad de la esponja, es decir, **la "
"cantidad de bits que se mantienen en el estado interno del algoritmo despu√©s "
"de cada paso de absorci√≥n**. Estos bits se mezclan con los datos de entrada "
"y el resultado de la funci√≥n interna `\"F\"`. La capacidad afecta la "
"resistencia del algoritmo a ataques criptogr√°ficos como colisiones o "
"preimagen."
msgstr ""

#: src/Keccak.md:30
msgid ""
"La suma de `\"r\"` y `\"c\"` da como resultado el n√∫mero total de bits, "
"`\"b\"`, utilizados en la funci√≥n esponja de Keccak. Este valor determina la "
"longitud del estado interno y, por lo tanto, la longitud de la salida "
"generada por el algoritmo."
msgstr ""

#: src/Keccak.md:32
msgid "## Funcionamiento keccak"
msgstr ""

#: src/Keccak.md:33
msgid ""
"El algoritmo funciona de la siguiente manera, inicialmente la cadena de "
"entrada se rellena con bits adicionales para enmascarar el mensaje inicial y "
"se divide en bloques de longitud `\"r\"` bits. Luego, los `\"b\"` bits de "
"estado se inicializan a `0`, que da inicio a la **Sponge construction** en "
"dos fases **\"absorbing\"** y **\"squeezing\"**."
msgstr ""

#: src/Keccak.md:35
msgid ""
"* **Fase Absorbing:** a los bloques de entrada de longitud `r-bits` se les "
"aplica un [XOR](https://en.wikipedia.org/wiki/XOR_cipher) (toma dos bits y "
"devuelve un resultado que es 1 si solo uno de los bits es 1, y 0 en caso "
"contrario) a los primeros `r` bits del estado, altern√°ndose con la funci√≥n "
"`f`. Cuando todos los bloques han sido procesados, se pasa a la siguiente "
"fase.\n"
"* **Fase Squeezing:** los primeros `r` bits del estado son devueltos como "
"bloques de salida, altern√°ndose con ejecuciones de la funci√≥n `f`. El n√∫mero "
"de bloques de salida es seleccionado por el usuario."
msgstr ""

#: src/Keccak.md:38
msgid ""
"A continuaci√≥n os dejamos una tabla que enumeran algunas de las diferencias "
"entre `SHA-256` y `Keccak-256`."
msgstr ""

#: src/Keccak.md:41
msgid ""
"<div align=\"center\">\n"
"<em>Algunas diferencias entre SHA-256 y Keccak-256</em>\n"
"</div>"
msgstr ""

#: src/Keccak.md:45
msgid ""
"Vemos c√≥mo cada tipo de criptograf√≠a o funci√≥n hash tiene caracter√≠sticas "
"distintas. En el contexto actual de la computaci√≥n cu√°ntica en constante "
"evoluci√≥n, es crucial abordar las preocupaciones emergentes sobre seguridad. "
"Algunos algoritmos criptogr√°ficos podr√≠an ser vulnerables a los ataques "
"cu√°nticos en un futuro cercano. Es en este punto donde entra en juego el "
"concepto de criptograf√≠a "
"[Post-Quantum](https://en.wikipedia.org/wiki/Post-quantum_cryptography)."
msgstr ""

#: src/Quantum_Secure.md:1
msgid "# Quantum Secure"
msgstr ""

#: src/Quantum_Secure.md:2
msgid ""
"As√≠ que es hora de aprovechar lo que hemos aprendido y explorar lo que "
"podr√≠a suceder en un escenario te√≥rico apocal√≠ptico. Pero antes comencemos "
"con una breve descripci√≥n sobre [computaci√≥n "
"cu√°ntica](https://es.wikipedia.org/wiki/Computaci%C3%B3n_cu%C3%A1ntica) para "
"sumergirnos en el tema. **No es m√°s que un modelo de computaci√≥n basado en "
"la** [**f√≠sica "
"cu√°ntica**](https://es.wikipedia.org/wiki/Mec%C3%A1nica_cu%C3%A1ntica), que "
"funciona de manera diferente a las computadoras cl√°sicas (el tipo de "
"computadoras que usamos habitualmente) y tiene la capacidad de realizar "
"tareas que estas √∫ltimas no pueden, como romper ciertos algoritmos de manera "
"eficiente."
msgstr ""

#: src/Quantum_Secure.md:4
msgid ""
"> **¬°As√≠ que espera un momento!** Antes de que tu imaginaci√≥n se desborde y "
"te veas rodeado de supercomputadoras cu√°nticas capaces de solucionar todos "
"nuestros problemas, d√©jame contarte una peque√±a an√©cdota."
msgstr ""

#: src/Quantum_Secure.md:6
msgid ""
"> _Ah, las computadoras cu√°nticas, esas criaturas de la f√≠sica cu√°ntica que "
"nos hacen so√±ar con un futuro lleno de posibilidades. Pero, ¬øsab√≠as que no "
"son m√°quinas m√°gicas capaces de resolver todos nuestros problemas "
"inform√°ticos en un abrir y cerrar de ojos?_"
msgstr ""

#: src/Quantum_Secure.md:8
msgid ""
"> **Imagina esto:** las computadoras cu√°nticas son como esas personas "
"brillantes que son s√∫per eficientes en ciertas tareas, pero bastante d√©biles "
"en otras. Son como el genio matem√°tico que resuelve complicados problemas de "
"c√°lculo en segundos, pero se le olvida c√≥mo atarse los zapatos."
msgstr ""

#: src/Quantum_Secure.md:10
msgid ""
"> _Entonces, s√≠, las computadoras cu√°nticas pueden ser incre√≠blemente "
"poderosas cuando se trata de ciertos problemas espec√≠ficos, como el "
"factorizar n√∫meros grandes o buscar en enormes bases de datos. Pero cuando "
"se trata de tareas cotidianas, como revisar correos electr√≥nicos o navegar "
"por la web, bueno, digamos que son como un caracol tratando de correr una "
"marat√≥n._"
msgstr ""

#: src/Quantum_Secure.md:12
msgid ""
"Despu√©s de esta peque√±a relato, es importante comprender el concepto de "
"criptograf√≠a post-cu√°ntica "
"[**(PQC)**](https://cryptobook.nakov.com/quantum-safe-cryptography), tambi√©n "
"conocida como [**Resistente a la Computaci√≥n "
"Cu√°ntica**](https://cryptobook.nakov.com/quantum-safe-cryptography), se "
"refiere a algoritmos criptogr√°ficos especialmente algoritmos de clave "
"p√∫blica, que se consideran seguros contra los ataques criptoanal√≠ticos "
"llevados a cabo por computadoras cu√°nticas."
msgstr ""

#: src/Quantum_Secure.md:14
msgid ""
"A medida que avanza la computaci√≥n cu√°ntica, se espera que algunos "
"algoritmos y t√©cnicas criptogr√°ficas tradicionales utilizadas en los "
"sistemas de seguridad actuales sean vulnerables a los ataques cu√°nticos. "
"Esto se debe a la capacidad de las computadoras cu√°nticas para realizar "
"c√°lculos a una escala exponencialmente mayor que las computadoras cl√°sicas, "
"lo que podr√≠a comprometer la seguridad de los sistemas criptogr√°ficos "
"actuales."
msgstr ""

#: src/Quantum_Secure.md:16
msgid ""
"Es bien sabido en inform√°tica que las computadoras cu√°nticas podr√°n romper "
"algunos algoritmos criptogr√°ficos, especialmente los criptosistemas de clave "
"p√∫blica como **RSA**, el intercambio de llaves **Diffie‚ÄìHellman** y "
"**ECDSA**, que dependen del "
"[**IFP**](https://es.wikipedia.org/wiki/Factorizaci%C3%B3n_de_enteros) "
"(problema de factorizaci√≥n en n√∫meros primos), el "
"[**DLP**](https://es.wikipedia.org/wiki/Logaritmo_discreto) (problema del "
"logaritmo discreto) y el ECDLP (problema del logaritmo discreto de curva "
"el√≠ptica). Todos estos problemas podr√≠an resolverse f√°cilmente en una "
"computadora cu√°ntica suficientemente poderosa que ejecute el algoritmo de "
"Shor."
msgstr ""

#: src/Quantum_Secure.md:18
msgid ""
"Pero los algoritmos cu√°nticos no significar√°n el fin de la criptograf√≠a, "
"porque:"
msgstr ""

#: src/Quantum_Secure.md:20
msgid ""
"* Solo algunos criptosistemas son inseguros frente a la computaci√≥n cu√°ntica "
"(como RSA, DHKE, ECDSA y ECDH).\n"
"* Algunos criptosistemas son seguros frente a la computaci√≥n cu√°ntica y solo "
"se ver√°n ligeramente afectados (como los hash criptogr√°ficos, algoritmos "
"[MAC](https://es.wikipedia.org/wiki/C%C3%B3digo_de_autenticaci%C3%B3n_de_mensaje) "
"y cifrados de clave sim√©trica como "
"[AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard?wprov=srpw1_0), "
"siempre que se utilicen tama√±os de clave suficientemente grandes)."
msgstr ""

#: src/Quantum_Secure.md:23
msgid ""
"A diferencia de la amenaza que representa la computaci√≥n cu√°ntica para los "
"algoritmos de clave p√∫blica actuales, **la mayor√≠a de los algoritmos "
"criptogr√°ficos sim√©tricos y las funciones hash actuales se consideran "
"relativamente seguros contra ataques de computadoras cu√°nticas.** Si bien el "
"algoritmo cu√°ntico de Grover acelera los ataques contra los cifrados "
"sim√©tricos, duplicar el tama√±o de la clave puede bloquear eficazmente estos "
"ataques. Por lo tanto, la criptograf√≠a sim√©trica post-cu√°ntica no necesita "
"diferir significativamente de la criptograf√≠a sim√©trica actual."
msgstr ""

#: src/Grover.md:1
msgid "# El algoritmo de Grover y la b√∫squeda no estructurada"
msgstr ""

#: src/Grover.md:3
msgid ""
"El [algoritmo de Grover](https://es.wikipedia.org/wiki/Algoritmo_de_Grover) "
"es un [algortimo "
"cu√°ntico](https://es.wikipedia.org/wiki/Algoritmo_cu%C3%A1ntico) para la "
"b√∫squeda en una secuencia no ordenada de datos con `N` componentes en un "
"tiempo "
"[O](https://es.wikipedia.org/wiki/Cota_superior_asint%C3%B3tica)(N¬π/‚ÇÇ), y "
"con una necesidad adicional de espacio de almacenamiento de `O(logN)`. Fue "
"inventado por Lov K. Grover en [1996](https://es.wikipedia.org/wiki/1996)."
msgstr ""

#: src/Grover.md:5
msgid ""
"Aunque el algoritmo de Grover es eficiente, su paralelizaci√≥n √≥ptima resulta "
"complicada y no se espera que las computadoras cu√°nticas actuales tengan "
"suficiente potencia para comprometer la seguridad de esquemas como ECDSA o "
"de funciones de hash como SHA256."
msgstr ""

#: src/Shor.md:1
msgid "# El algoritmo de Shor te√≥rico y su impacto en ECDSA"
msgstr ""

#: src/Shor.md:3
msgid ""
"El [**algoritmo de Shor**](https://en.wikipedia.org/wiki/Shor's_algorithm) "
"es un algoritmo cu√°ntico desarrollado por Peter Shor en 1994. Este algoritmo "
"es conocido por su capacidad para factorizar grandes n√∫meros enteros de "
"manera mucho m√°s eficiente que los algoritmos cl√°sicos conocidos, lo que "
"tiene implicaciones importantes para la seguridad de algunos sistemas "
"criptogr√°ficos basados en la factorizaci√≥n de n√∫meros enteros."
msgstr ""

#: src/Shor.md:5
msgid ""
"En el contexto de sistemas centralizados, como los sistemas bancarios, ECDSA "
"se utiliza para garantizar la autenticidad de las transacciones, proteger la "
"confidencialidad de la informaci√≥n y asegurar la integridad de los datos. En "
"el √°mbito de Bitcoin y Ethereum, si bien los algoritmos de b√∫squeda "
"cu√°ntica, como el algoritmo de Shor, podr√≠an eventualmente romper la ECDSA, "
"es importante destacar que estos algoritmos a√∫n est√°n en una etapa te√≥rica."
msgstr ""

#: src/Shor.md:7
msgid ""
"Cada implementaci√≥n de algoritmos o protocolos puede ser diversa, ya sea "
"privada o abstracta. Nos hemos centrado en los principios b√°sicos comunes de "
"ECDSA, adem√°s se espera que la implementaci√≥n pr√°ctica de algoritmos de "
"b√∫squeda cu√°ntica sea un desaf√≠o t√©cnico debido a los requisitos de recursos "
"y la necesidad de superar errores cu√°nticos."
msgstr ""

#: src/Shor.md:9
msgid ""
"Aqu√≠ tienes una descripci√≥n general de en qu√© consisten algunos problemas "
"que se consideran complejos de resolver mediante la computaci√≥n cl√°sica."
msgstr ""

#: src/Shor.md:11
msgid "## IFP"
msgstr ""

#: src/Shor.md:12
msgid ""
"El IFP se refiere al desaf√≠o de descomponer un n√∫mero entero grande en sus "
"factores primos. En el caso de n√∫meros peque√±os, esto puede hacerse "
"f√°cilmente mediante el uso de algoritmos como [el cribado de "
"Erat√≥stenes](https://yosoytuprofe.20minutos.es/2022/11/09/que-es-la-criba-de-eratostenes-y-cual-es-su-importancia-en-las-matematicas/) "
"o [el algoritmo de factorizaci√≥n de "
"Pollard](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm_for_logarithms)."
msgstr ""

#: src/Shor.md:14
msgid ""
"A modo de ejemplo simplificado, supongamos que queremos factorizar el n√∫mero "
"compuesto `N = 35` utilizando el algoritmo de Shor. Despu√©s de aplicar el "
"algoritmo, encontrar√≠amos que los factores primos de `N` son `5 y 7`."
msgstr ""

#: src/Shor.md:16
msgid ""
"Sin embargo, a medida que los n√∫meros crecen en tama√±o, el IFP se vuelve "
"cada vez m√°s dif√≠cil de resolver. De hecho, la seguridad de muchos sistemas "
"criptogr√°ficos se basa en la dificultad de factorizar n√∫meros grandes en "
"tiempo razonable, como el popular algoritmo RSA."
msgstr ""

#: src/Shor.md:18
msgid "## DLP"
msgstr ""

#: src/Shor.md:19
msgid ""
"Por otro lado, el DLP implica encontrar el exponente desconocido de una "
"potencia modular dada. En t√©rminos m√°s sencillos, se trata de resolver la "
"ecuaci√≥n `(y = gÀ£ mod p)` para el exponente desconocido `(x)`, donde `(g)` y "
"`(p)` son n√∫meros conocidos e `(y)` es el resultado de la operaci√≥n de "
"potenciaci√≥n modular. Para valores peque√±os de `(p)`, el DLP puede "
"resolverse mediante la aplicaci√≥n de m√©todos exhaustivos como la prueba y "
"error."
msgstr ""

#: src/Shor.md:21
msgid ""
"A modo de ejemplo simplificado, ser√≠a encontrar el logaritmo discreto de "
"`base 2` para el n√∫mero `5` `m√≥dulo 11`. Esto implica encontrar el valor de "
"`x` en la ecuaci√≥n `2À£ ‚â° 5 (mod 11).`"
msgstr ""

#: src/Shor.md:23
msgid "Realizando los c√°lculos paso a paso:"
msgstr ""

#: src/Shor.md:25
msgid ""
"* 2¬π ‚â° 2 (mod 11)\n"
"* 2¬≤ ‚â° 4 (mod 11)\n"
"* 2¬≥ ‚â° 8 (mod 11)\n"
"* 2‚Å¥ ‚â° 5 (mod 11)"
msgstr ""

#: src/Shor.md:30
msgid ""
"Entonces, el valor de `x` que satisface la ecuaci√≥n `2À£ ‚â° 5 (mod 11)` es `x "
"= 4`."
msgstr ""

#: src/Shor.md:32
msgid "## ECDLP"
msgstr ""

#: src/Shor.md:33
msgid ""
"La seguridad de esquemas criptogr√°ficos basados en **ECC**, como **ECDSA**, "
"se basa en la dificultad de resoluci√≥n del problema del logaritmo discreto "
"de curva el√≠ptica o **ECDLP**. Las curvas el√≠pticas son objetos matem√°ticos "
"utilizados en criptograf√≠a de clave p√∫blica, y el **ECDLP** ser√≠a el "
"problema de hallar el valor de `‚ÄòK‚Äô` en esta ecuaci√≥n, `P =k‚ãÖG`, donde `P` "
"es un punto en la curva, `k` es el valor que debemos hallar y `G` es un "
"punto base conocido (el generador)."
msgstr ""

#: src/Shor.md:35
msgid ""
"Al igual que en el caso del **DLP**, el **ECDLP** se vuelve m√°s dif√≠cil de "
"resolver a medida que el tama√±o de los n√∫meros involucrados en esas "
"expresiones matem√°ticas aumentan"
msgstr ""

#: src/Shor.md:37
msgid "## ECDSA"
msgstr ""

#: src/Shor.md:38
msgid ""
"Por √∫ltimo llegamos a un algoritmo ampliamente utilizado y conocido como es "
"el **ECDSA**, que se utiliza com√∫nmente en blockchain. La clave p√∫blica se "
"obtiene multiplicando un punto base conocido (llamado generador) en la curva "
"el√≠ptica por un entero, que representa la llave privada. El desaf√≠o radica "
"en encontrar ese valor privado a partir del punto p√∫blico conocido en la "
"curva."
msgstr ""

#: src/Shor.md:40
msgid ""
"La curva el√≠ptica **secp256k1** est√° definida por la ecuaci√≥n: `y¬≤ = x¬≥ + ax "
"+ b` sobre `ùîΩp` donde `p` es un n√∫mero primo grande."
msgstr ""

#: src/Shor.md:42
msgid ""
"El algoritmo de Shor, en su versi√≥n completa y ejecutado en un computador "
"cu√°ntico lo suficientemente grande y estable, podr√≠a factorizar el n√∫mero "
"primo `p` en esta ecuaci√≥n, lo que proporcionar√≠a informaci√≥n sobre el orden "
"del subgrupo c√≠clico relacionado con la curva."
msgstr ""

#: src/Shor.md:44
msgid ""
"Si se pudiera determinar el orden del subgrupo c√≠clico relacionado con la "
"curva `secp256k1` utilizando el algoritmo de **Shor**, ser√≠a posible "
"encontrar el valor privado a partir de la clave p√∫blica. Esto comprometer√≠a "
"la seguridad de **ECDSA**, ya que la clave privada es fundamental para "
"generar firmas digitales y autenticar transacciones. Es importante destacar "
"que el algoritmo de Shor plantea un desaf√≠o para los sistemas criptogr√°ficos "
"actuales basados en la factorizaci√≥n de n√∫meros enteros o en el logaritmo "
"discreto, como **RSA** y **ECDSA**."
msgstr ""

#: src/Shor.md:46
msgid ""
"No obstante, la implementaci√≥n pr√°ctica de un algoritmo cu√°ntico capaz de "
"realizar estos c√°lculos, como los mencionados ejemplos, todav√≠a se encuentra "
"en desarrollo y no representa una amenaza inmediata para los sistemas "
"criptogr√°ficos utilizados en la actualidad. La investigaci√≥n y el desarrollo "
"continuo en criptograf√≠a pos-cu√°ntica son fundamentales para garantizar la "
"seguridad en un entorno tecnol√≥gico en constante evoluci√≥n."
msgstr ""

#: src/Lattice.md:1
msgid "## Criptograf√≠a basada en Lattice previene Shor"
msgstr ""

#: src/Lattice.md:2
msgid ""
"Ahora deberemos aprender c√≥mo una verificaci√≥n de esquemas de firmas puede "
"ser lo suficientemente fuerte para prevenirnos contra un posible ataque "
"ejecutado con el algoritmo de Shor, la criptograf√≠a basada en ret√≠culos "
"[**(Lattice)**](https://es.wikipedia.org/wiki/Criptograf%C3%ADa_basada_en_ret%C3%ADculos), "
"es una forma segura de protegerse frente a muchos algoritmos."
msgstr ""

#: src/Lattice.md:4
msgid ""
"Pensemos en un [ret√≠culo](https://es.wikipedia.org/wiki/Red_(grupo)), como "
"una estructura matem√°tica que se forma mediante una red de puntos en un "
"espacio n-dimensional. Es similar a una cuadr√≠cula o una rejilla en dos "
"dimensiones, pero se extiende a cualquier n√∫mero de dimensiones. Cada punto "
"en el ret√≠culo est√° ubicado en una posici√≥n determinada y est√° conectado a "
"los puntos vecinos por l√≠neas rectas de igual longitud."
msgstr ""

#: src/Lattice.md:6
msgid ""
"En el contexto de la criptograf√≠a basada en ret√≠culos, se utilizan ret√≠culos "
"en [teor√≠a de "
"n√∫meros](https://es.wikipedia.org/wiki/Teor%C3%ADa_de_n%C3%BAmeros) para "
"construir sistemas criptogr√°ficos. Estos ret√≠culos se definen mediante un "
"conjunto de vectores base, que son combinaciones lineales de vectores de "
"coordenadas con coeficientes enteros. Los ret√≠culos tienen propiedades "
"matem√°ticas interesantes, como la propiedad de ser densos y uniformes en el "
"espacio."
msgstr ""

#: src/Lattice.md:8
msgid ""
"Los problemas computacionales basados en ret√≠culos, como el problema de la "
"aproximaci√≥n m√°s cercana en ret√≠culos o el problema del vector corto m√°s "
"cercano, se utilizan en criptograf√≠a para establecer la seguridad de los "
"esquemas basados en ret√≠culos. Estos problemas son dif√≠ciles de resolver y "
"se cree que no existen algoritmos eficientes para resolverlos en el caso "
"general, lo que brinda seguridad a los sistemas criptogr√°ficos basados en "
"ret√≠culos."
msgstr ""

#: src/Lattice.md:10
msgid ""
"La criptograf√≠a basada en ret√≠culos es el t√©rmino gen√©rico para las "
"construcciones de primitivas criptogr√°ficas que involucran ret√≠culos, ya sea "
"en la construcci√≥n misma o en la prueba de seguridad."
msgstr ""

#: src/Lattice.md:12
msgid ""
"**Las construcciones basadas en ret√≠culos son actualmente candidatas "
"importantes para la criptograf√≠a post-cu√°ntica.** A diferencia de los "
"esquemas de clave p√∫blica m√°s ampliamente utilizados y conocidos, como RSA, "
"Diffie-Hellman o los criptosistemas de curva el√≠ptica, que te√≥ricamente "
"podr√≠an ser derrotados utilizando el algoritmo de Shor en un computador "
"cu√°ntico, algunas construcciones basadas en ret√≠culos parecen ser "
"resistentes a los ataques tanto de computadoras cl√°sicas como cu√°nticas. "
"Adem√°s, muchas construcciones basadas en ret√≠culos se consideran seguras "
"bajo la suposici√≥n de que ciertos problemas computacionales bien estudiados "
"en ret√≠culos no pueden ser resueltos."
msgstr ""

#: src/Lattice.md:14
msgid ""
"Aqu√≠ hay una breve explicaci√≥n de las diferencias entre los esquemas de "
"criptograf√≠a basados en ret√≠culos en t√©rminos de encriptaci√≥n, funciones "
"hash y intercambio de claves:"
msgstr ""

#: src/Lattice.md:16
msgid ""
"1. **Encriptaci√≥n basada en ret√≠culos:** los esquemas de encriptaci√≥n "
"basados en ret√≠culos aprovechan las propiedades matem√°ticas de los ret√≠culos "
"para proporcionar seguridad en la comunicaci√≥n.\n"
"2. **Funciones hash basadas en ret√≠culos:** las funciones hash basadas en "
"ret√≠culos utilizan ret√≠culos y operaciones matem√°ticas relacionadas para "
"calcular los hashes y se utilizan en diversas aplicaciones criptogr√°ficas, "
"como la integridad de datos y la firma digital.\n"
"3. **Intercambio de claves basado en ret√≠culos:** el intercambio de claves "
"basado en ret√≠culos como el [(Intercambio NewHope "
"Protocol)](https://newhopecrypto.org/) implica el establecimiento de una "
"clave compartida entre dos o m√°s partes que desean comunicarse de manera "
"segura. Los protocolos de intercambio de claves basados en ret√≠culos "
"utilizan los ret√≠culos y los problemas computacionales relacionados con "
"ellos para garantizar que las partes puedan acordar una clave sin que un "
"tercero pueda determinarla. Estos esquemas se basan en la dificultad de "
"resolver ciertos problemas matem√°ticos relacionados con los ret√≠culos para "
"asegurar la confidencialidad de la clave compartida."
msgstr ""

#: src/Kyber_Crystal.md:1
msgid "# Kyber Crystal"
msgstr ""

#: src/Kyber_Crystal.md:2
msgid ""
"En el √∫ltimo estudio post-quantum veremos "
"[**Kyber**](https://pq-crystals.org/kyber/resources.shtml), antes de entrar "
"dentro del ecosistema de Starkware y aprender c√≥mo se generan los contratos "
"de cuentas, as√≠ como las caracter√≠sticas criptogr√°ficas y matem√°ticas detr√°s "
"de las STARKs."
msgstr ""

#: src/Kyber_Crystal.md:4
msgid ""
"Kyber es un m√©todo de encapsulaci√≥n de clave "
"[(KEM)](https://en.wikipedia.org/wiki/Key_encapsulation) dise√±ado para "
"resistir ataques criptoanal√≠ticos realizados por futuras computadoras "
"cu√°nticas poderosas. Se utiliza para establecer un secreto compartido entre "
"dos partes que se comunican, sin que un atacante "
"[(IND-CCA2)](https://en.wikipedia.org/wiki/Ciphertext_indistinguishability) "
"en el sistema de transmisi√≥n pueda descifrarlo. Este criptosistema "
"asim√©trico utiliza una variante del problema de redes de aprendizaje con "
"errores [(learning with errors, "
"LWE)](https://en.wikipedia.org/wiki/Learning_with_errors) como su [funci√≥n "
"b√°sica con trampa](https://en.wikipedia.org/wiki/Trapdoor_function). Gan√≥ la "
"competencia del NIST para el primer est√°ndar de criptograf√≠a PQ."
msgstr ""

#: src/Kyber_Crystal.md:6
msgid ""
"La generaci√≥n de claves en Kyber no se basa en la factorizaci√≥n de enteros o "
"en problemas relacionados con las curvas el√≠pticas, sino que utiliza el "
"problema de aprendizaje con errores en ret√≠culos como base para la seguridad "
"del algoritmo."
msgstr ""

#: src/Kyber_Crystal.md:8
msgid ""
"El sistema se basa en el aprendizaje con errores en m√≥dulos (M-LWE) del "
"campo del aprendizaje autom√°tico, en conjunto con anillos ciclot√≥micos. "
"Recientemente, tambi√©n se ha logrado una reducci√≥n formal matem√°tica "
"estrecha de la problem√°tica del anillo LWE al MLWE. **En comparaci√≥n con "
"otros m√©todos de criptograf√≠a post-cu√°ntica, tiene las ventajas t√≠picas de "
"los m√©todos basados en ret√≠culos, como el tiempo de ejecuci√≥n, el tama√±o de "
"los textos cifrados y el material clave.**"
msgstr ""

#: src/Kyber_Crystal.md:10
msgid ""
"En cuanto a los par√°metros, Kyber proporciona diferentes conjuntos para "
"alcanzar diferentes niveles de seguridad. Por ejemplo, `Kyber-512` tiene una "
"seguridad aproximada equivalente a `AES-128`, `Kyber-768` tiene una "
"seguridad aproximada equivalente a `AES-192` y `Kyber-1024` tiene una "
"seguridad aproximada equivalente a `AES-256`."
msgstr ""

#: src/Kyber_Crystal.md:12
msgid ""
"En resumen, Kyber utiliza un enfoque matem√°tico diferente a ECDSA en la "
"generaci√≥n de claves. Se basa en el problema de aprendizaje con errores en "
"ret√≠culos y en la selecci√≥n adecuada de par√°metros de seguridad. La "
"seguridad de Kyber radica en la dificultad de resolver problemas "
"criptogr√°ficos espec√≠ficos asociados a ese enfoque matem√°tico."
msgstr ""

#: src/Kyber_Crystal.md:14
msgid ""
"Con esto hemos concluido las bases criptogr√°ficas que nos han brindado los "
"detalles de c√≥mo se generan los distintos tipos de criptograf√≠a sim√©trica o "
"asim√©trica, as√≠ como las funciones hash y su importancia en la seguridad. "
"Nos adentramos en c√≥mo se integraban en los Merkle Tree o Patricia Trie, "
"para luego explorar el √°mbito de la computaci√≥n cu√°ntica y ver c√≥mo se "
"pod√≠an resolver algunos de los problemas planteados por ciertas "
"criptograf√≠as. Tambi√©n destacamos la importancia de las firmas y las "
"verificaciones de firmas en los avances de la tecnolog√≠a de la computaci√≥n "
"cu√°ntica."
msgstr ""

#: src/Kyber_Crystal.md:16
msgid ""
"La computaci√≥n cu√°ntica se mostr√≥ resistente a las bases sim√©tricas de una "
"llave maestra o a las funciones hash en s√≠. Adem√°s, presenciamos avances en "
"la prevenci√≥n de ataques cu√°nticos y en algoritmos cu√°nticos como Lattice o "
"encapsulamientos por Kyber. Con estos avances en mente, es hora de pasar a "
"ver las EOA (Externally Owned Accounts) y los firmantes en Ethereum, para "
"luego diferenciarlos de la Account Abstraction nativa en Starknet."
msgstr ""

#: src/EOA_AA.md:1
msgid "# EOA y AA - Firmantes"
msgstr ""

#: src/EOA_AA.md:2
msgid ""
"Las cuentas de EOA [**(Externally Owned "
"Accounts)**](https://ethereum.org/en/whitepaper/#ethereum-accounts) en "
"Ethereum, al igual que muchas otras criptomonedas, utilizan el algoritmo "
"ECDSA que aprendimos antes para generar claves y firmar transacciones "
"digitalmente. Esto les permite participar de manera segura en la red y "
"realizar operaciones. Las EOA son cuentas que pertenecen a usuarios externos "
"a la cadena de bloques."
msgstr ""

#: src/EOA_AA.md:4
msgid ""
"En Ethereum, el estado de una cuenta solo puede ser modificado a trav√©s de "
"transacciones, las cuales deben ser iniciadas por una EOA. sin embargo, no "
"cualquier persona puede activar una transacci√≥n desde cualquier EOA, aqu√≠ es "
"donde entra en juego el concepto de firmante."
msgstr ""

#: src/EOA_AA.md:6
msgid ""
"Cada cuenta en Ethereum est√° asociada con un objeto criptogr√°fico llamado "
"keypair, como aprendimos antes."
msgstr ""

#: src/EOA_AA.md:8
msgid ""
"La clave privada, se utiliza para firmar mensajes digitales, mientras que la "
"clave p√∫blica permite que cualquiera pueda verificar que una firma en "
"particular fue generada por la clave privada correspondiente."
msgstr ""

#: src/EOA_AA.md:10
msgid ""
"La asociaci√≥n entre una cuenta y un firmante se realiza mediante la "
"direcci√≥n de la cuenta. La direcci√≥n de un EOA se deriva de la clave p√∫blica "
"del firmante, espec√≠ficamente, **la direcci√≥n se obtiene tomando los √∫ltimos "
"20 bytes del hash Keccak-256 de la clave p√∫blica.**"
msgstr ""

#: src/EOA_AA.md:12
msgid ""
"El propietario de una cuenta puede autorizar una transacci√≥n desde su cuenta "
"firmando los par√°metros de la transacci√≥n con la clave privada "
"correspondiente."
msgstr ""

#: src/EOA_AA.md:14
msgid ""
"La [**curva el√≠ptica "
"secp256k1**](https://ethereum.org/en/whitepaper/#ethereum-accounts)  es una "
"de las curvas el√≠pticas m√°s utilizadas en criptograf√≠a, especialmente en el "
"contexto de criptomonedas como Bitcoin o Ethereum. Esto ha permitido "
"establecer esquemas de firmas digitales que garantizan la integridad de las "
"transacciones al asegurar la autenticidad de las claves."
msgstr ""

#: src/EOA_AA.md:16
msgid ""
"La abstracci√≥n de firma y clave privada es una propiedad presente en algunos "
"sistemas criptogr√°ficos, como ciertos esquemas de firmas digitales basados "
"en identidad. Sin embargo, en el caso del algoritmo ECDSA utilizado en "
"Ethereum y muchas otras blockchain, la firma est√° inherentemente vinculada a "
"la clave privada de la cuenta y no es posible separarlas o abstraerlas, como "
"podr√≠a ser el caso en otros esquemas dise√±ados con estos principios."
msgstr ""

#: src/EOA_AA.md:18
msgid ""
"Ahora que ya hemos adquirido los conceptos b√°sicos y hemos prestado atenci√≥n "
"para adquirir la formaci√≥n adecuada y avanzada, podemos sumergirnos en el "
"apasionante ecosistema de StarkWare, Starknet, StarkEx y STARKs. Nuestra "
"mente est√° mejor preparada para embarcarnos en el viaje que nos espera en el "
"resto del documento y en las futuras series."
msgstr ""

#: src/Starknet_AA.md:1
msgid "## Starknet AA"
msgstr ""

#: src/Starknet_AA.md:3
msgid ""
"Esperamos que haya disfrutado de la primera parte, donde se presentaron "
"conceptos generales de criptograf√≠a. Ahora nos adentraremos en un tema a√∫n "
"m√°s interesante, [**Starknet**](https://www.starknet.io/en) y c√≥mo mejora el "
"ecosistema, exploraremos c√≥mo los contratos de cuentas (CA) y el esquema de "
"firmas abstra√≠das de Starknet ofrecen beneficios significativos frente al "
"[ERC-4337](https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a)."
msgstr ""

#: src/Starknet_AA.md:5
msgid ""
"_Si deseas aprender m√°s sobre el concepto y las variantes del ERC-4337, te "
"recomendamos leer esta serie de art√≠culos en el blog de "
"[Argent](https://www.argent.xyz/argent-x/). La serie est√° compuesta por la "
"[Parte 1](https://www.argent.xyz/blog/wtf-is-account-abstraction/), [Parte "
"2](https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/) y [Parte "
"3](https://www.argent.xyz/blog/part-3-wtf-is-account-abstraction/). Argent y "
"[Braavos](https://braavos.app/) son Smart wallets que aprovechan el poder "
"del AA nativo en Starknet. Tambi√©n te recomendamos leer los art√≠culos de "
"Braavos de [Guide 101 "
"AA](https://braavos.app/account-abstraction-ethereum-comprehensive-guide/) y "
"[Security Pyramid "
"AA](https://braavos.app/account-abstraction-security-pyramid/), los cuales "
"presentan optimizaciones adicionales y capas de seguridad que exploraremos "
"m√°s adelante. Estos recursos te proporcionar√°n una mejor comprensi√≥n del "
"concepto de **AA** y del **ERC-4337**._"
msgstr ""

#: src/Starknet_AA.md:7
msgid "**¬°As√≠ que sin m√°s pre√°mbulos, bienvenidos a Starknet!**"
msgstr ""

#: src/Starknet_AA.md:9
msgid ""
"En el ecosistema de Starknet, se encuentran diversas metodolog√≠as para "
"generar claves y firmas. A diferencia de las cuentas EOA, en Starknet se "
"emplea **Account Abstraction** "
"[**(AA)**](https://book.starknet.io/chapter_5/index.html) para la "
"implementaci√≥n de **Contract Accounts** "
"[(CA)](https://book.starknet.io/chapter_5/index.html#ethereums_current_account_system_a_closer_look). "
"Estos contratos son responsables de establecer la l√≥gica en nuestras cuentas "
"dentro de Starknet, incluyendo la validaci√≥n del esquema de firma abstra√≠do."
msgstr ""

#: src/Starknet_AA.md:11
msgid ""
"En lugar de utilizar ECDSA, Starknet utiliza una variaci√≥n llamada [**STARK "
"Curve**], un tipo de curva el√≠ptica m√°s amigable y optimizada que es nativa "
"en el ecosistema, esta variante nos ofrece mejoras y caracter√≠sticas "
"espec√≠ficas para las necesidades de Starknet."
msgstr ""

#: src/Starknet_AA.md:13
msgid ""
"Lo grandioso de tener esta abstracci√≥n nativa es que permite a√±adir "
"diferentes l√≥gicas en tus esquemas o capas adicionales. Normalmente, se "
"utiliza un sistema asim√©trico usando la curva el√≠ptica `secp256k1`, basado "
"en la pseudoaleatoriedad y diversas operaciones matem√°ticas utilizando dicha "
"curva, para generar claves privadas y p√∫blicas. Sin embargo, tambi√©n se "
"pueden a√±adir curvas adicionales de forma nativa al crear un CA, como lo ha "
"hecho Braavos con la "
"[secp256r1](https://github.com/myBraavos/efficient-secp256r1). Esta curva "
"cuenta con un sistema de firmas integrado, mejor optimizado y preparado para "
"dispositivos modernos, donde el signer puede almacenar los datos habilitados "
"por biometricidad en dispositivos aislados y seguros, como el m√≥dulo "
"\"Enclave\" de Apple."
msgstr ""

#: src/Starknet_AA.md:15
msgid ""
"La AA desempe√±a un papel crucial al abstraer el esquema de firmas o "
"verificaci√≥n de firmas de la ejecuci√≥n. Como vimos anteriormente, podemos "
"generar una clave privada y mediante ECDSA generar una clave p√∫blica. En "
"este caso el poseedor de esta clave privada y del esquema de firma asociado "
"tiene el poder de realizar transacciones en Starknet, los [dos tipos de "
"transacciones](https://book.starknet.io/chapter_8/transactions.html) son "
"`DEPLOY` o `INVOKE`."
msgstr ""

#: src/Starknet_AA.md:18
msgid ""
"<div align=\"center\">\n"
"<em>Contrato de Cuenta de usuario</em>\n"
"</div>"
msgstr ""

#: src/Starknet_AA.md:22
msgid ""
"Con AA podemos modificar estas firmas o curvas. Por ejemplo, la curva "
"`Secp256r1`, vimos que ofrece una seguridad adicional en Braavos al "
"configurar una firma biom√©trica en el m√≥dulo de seguridad del enclave. De "
"esta manera, esta firma biom√©trica solo puede ser a√±adida gracias a AA."
msgstr ""

#: src/Starknet_AA.md:24
msgid ""
"Todo esto es posible gracias al lenguaje de programaci√≥n utilizado en la "
"implementaci√≥n, el poderoso [**Cairo**](https://starkware.co/cairo/), as√≠ "
"que analicemos c√≥mo Cairo incorpora esta abstracci√≥n en su programaci√≥n."
msgstr ""

#: src/Starknet_AA.md:26
msgid ""
"En primer lugar, se necesita validar la firma y comprobar que coincide con "
"la generada mediante ECDSA antes de proceder a la ejecuci√≥n. Estas dos "
"funciones principales son `validate` y `execute`. Adem√°s, `execute` tambi√©n "
"puede realizar m√∫ltiples llamadas utilizando `execute_calls`."
msgstr ""

#: src/Starknet_AA.md:29
msgid ""
"<div align=\"center\">\n"
"<em>Informaci√≥n de la L√≥gica separada de las funciones validate, "
"execute</em>\n"
"</div>"
msgstr ""

#: src/Starknet_AA.md:33
msgid ""
"Ahora analicemos c√≥mo Cairo incorpora esta abstracci√≥n en su programaci√≥n."
msgstr ""

#: src/Starknet_AA.md:35
msgid ""
"Veamos c√≥mo funciona un ciclo de transacci√≥n con AA nativa y c√≥mo se "
"representa gr√°ficamente este ciclo completo de firmas para detectar si es "
"correcto y realizar la operaci√≥n."
msgstr ""

#: src/Starknet_AA.md:37
msgid ""
"Tambi√©n pensemos en c√≥mo se podr√≠an combinar de manera eficiente firmas como "
"ha realizado Braavos con la EC `secp256r1` o incluso realizar la "
"verificaci√≥n de firmas, como vimos con Lattice para prevenir ataques "
"cu√°nticos."
msgstr ""

#: src/Starknet_AA.md:40
#: src/Starknet_funciones_hash.md:10
msgid ""
"<div align=\"center\">\n"
"<em>Ciclo completo de una firma y validaci√≥n de una trnasacci√≥n</em>\n"
"</div>"
msgstr ""

#: src/Starknet_AA.md:44
msgid ""
"Los conocimientos previos adquiridos nos han ense√±ado muchas cosas, una de "
"ellas es c√≥mo el algoritmo de Shor puede te√≥ricamente romper ECDSA, pero no "
"podr√° romper una prueba STARK. "
msgstr ""

#: src/Starknet_AA.md:46
msgid ""
"En la secci√≥n de generaci√≥n de STARKs, aprenderemos como gracias a sus bases "
"de criptograf√≠a sim√©trica y otras variables, si alguien nos roba, hackea o "
"perdemos la cuenta, el esquema **PQS** para la prueba no ser√° de mucha "
"utilidad, ya que no se ha alterado la integridad del estado de los datos, "
"sino que por oun te√≥rico ataque criptoanal√≠tico se habr√° obtenido tu PK, lo "
"que permitir√≠a mover los fondos de forma justa."
msgstr ""

#: src/Starknet_AA.md:48
msgid ""
"**Pero, ¬øqu√© suceder√≠a si tuvi√©ramos un esquema de verificaci√≥n de firmas "
"seguro frente a un ataque cu√°ntico?**"
msgstr ""

#: src/Starknet_AA.md:50
msgid ""
"Aqu√≠ es donde entran en juego peque√±os cambios, espec√≠ficamente en la parte "
"de validaci√≥n y no de ejecuci√≥n, con las mejoras en Starknet y con la ayuda "
"de AA nativo, est√° implementando para prepararse para el futuro. Una "
"posibilidad ser√≠a el uso de Lattice o Kyber, aunque el futuro no est√° "
"escrito, as√≠ que ha llegado el momento de ver c√≥mo se genera la parte de la "
"EC."
msgstr ""

#: src/Stark_Curve.md:1
msgid "# EC en Cairo - STARK Curve"
msgstr ""

#: src/Stark_Curve.md:2
msgid ""
"Como hemos visto en el contexto de los sistemas criptogr√°ficos, la elecci√≥n "
"de la curva el√≠ptica adecuada es de suma importancia. En este caso, se "
"utiliza una variante de EC la cual ha sido especialmente dise√±ada y "
"optimizada para su aplicaci√≥n en el entorno de Starknet."
msgstr ""

#: src/Stark_Curve.md:4
msgid ""
"La STARK Curve "
"[**(EC.cairo)**](https://github.com/starkware-libs/cairo-lang/blob/361fe32d5930db340ea78fe05aedfe706f6c9405/src/starkware/cairo/common/ec.cairo) "
"se define mediante la ecuaci√≥n:"
msgstr ""

#: src/Stark_Curve.md:11
msgid ""
"Los valores espec√≠ficos de `Œ±`, `Œ≤` y `p` utilizados en esta curva han sido "
"cuidadosamente seleccionados para proporcionar propiedades criptogr√°ficas "
"s√≥lidas y un rendimiento eficiente en el contexto de los contratos de cuenta "
"nativos en Starknet."
msgstr ""

#: src/Stark_Curve.md:13
msgid ""
"En particular, los valores de `Œ±`, `Œ≤` (notese que es `œÄ` ‚ÄúPI‚Äù sin decimales "
"usando 67 digitos) y `p` son los siguientes:"
msgstr ""

#: src/Stark_Curve.md:20
msgid ""
"Estos valores aseguran que la curva el√≠ptica Stark-friendly cumple con los "
"requisitos de seguridad necesarios para su aplicaci√≥n en sistemas "
"criptogr√°ficos."
msgstr ""

#: src/Stark_Curve.md:22
msgid ""
"Adem√°s se utiliza un punto generador "
"[(G)](https://docs.starkware.co/starkex/crypto/stark-curve.html) espec√≠fico "
"asociado a esta curva. El punto generador `G` se define como:"
msgstr ""

#: src/Stark_Curve.md:29
msgid ""
"Este punto generador desempe√±a un papel fundamental en el esquema de firmas "
"digitales ECDSA, permitiendo la generaci√≥n de claves p√∫blicas, como "
"aprendimos al momento de hablar del Generador de Claves."
msgstr ""

#: src/Stark_Curve.md:31
msgid ""
"La elecci√≥n de la curva el√≠ptica Stark-friendly y el punto generador `G` "
"asociado a ella proporcionan una base s√≥lida y optimizada para la "
"implementaci√≥n de esquemas criptogr√°ficos en el entorno de Starknet. Estos "
"elementos garantizan la seguridad y eficiencia necesarias para la creaci√≥n "
"de contratos de cuenta nativos y la verificaci√≥n de firmas digitales en el "
"sistema."
msgstr ""

#: src/Stark_Curve.md:33
msgid ""
"Si desea probar y adentrarse en el despliegue de cuentas en Starknet, o si "
"est√° interesado en aprender c√≥mo se generan y calculan off-chain, y luego "
"financiar esas cuentas para que los contratos de cuenta se autodesplieguen, "
"le animamos a seguir los ejercicios oficiales de [**Starknet-Edu "
"Account**](https://github.com/starknet-edu/starknet-accounts/blob/answers/ES%20README.md) "
"o las [**Gu√≠as Completas Cairo "
"1**](https://github.com/Nadai2010/Nadai-StarknetEs-Guia-Cairo1#configuraci%C3%B3n-de-una-cuenta) "
"proporcionadas por [Starknet-Es](https://twitter.com/StarkNetEs) para "
"realizar pruebas reales."
msgstr ""

#: src/Secp256r1.md:1
msgid "# My Braavos - Secp256r1"
msgstr ""

#: src/Secp256r1.md:2
msgid ""
"Empecemos con un dato que no hab√≠amos comentando antes, la `k` en "
"`sepc256k1` significa "
"[**Koblitz**](https://es.wikipedia.org/wiki/Neal_Koblitz)¬†y el `r` en "
"`sepc256r1` significa random."
msgstr ""

#: src/Secp256r1.md:4
msgid ""
"Braavos ha incorporado la firma y validaci√≥n de transacciones utilizando "
"`secp256r1`, lo que brinda una excelente experiencia al usuario final al "
"permitir transacciones con firma biom√©trica en el dispositivo del usuario. "
"Esto a√±ade un nivel adicional de seguridad. Braavos ha presentado en su blog "
"una [Pir√°mide de Seguridad "
"AA](https://braavos.app/account-abstraction-security-pyramid/)."
msgstr ""

#: src/Secp256r1.md:11
msgid ""
"Podemos ver en la c√∫spide de la pir√°mide al Multi-Signer (3FA). El "
"Multi-Signer combina la protecci√≥n de la frase de recuperaci√≥n (seed phrase) "
"en la extensi√≥n del navegador y el Hardware Signer o Protected Signer "
"utilizando el dispositivo m√≥vil."
msgstr ""

#: src/Secp256r1.md:13
msgid ""
"Ahora se requieren dos firmas de dos claves diferentes para ejecutar la "
"transacci√≥n en la cadena, obteniendo una autenticaci√≥n de 3FA:"
msgstr ""

#: src/Secp256r1.md:15
msgid ""
"* **Algo que sabemos:** la clave derivada de tu frase de recuperaci√≥n en la "
"extensi√≥n del navegador.\n"
"* **Algo que tenemos:** tu dispositivo m√≥vil.\n"
"* **Algo que somos:** tu huella dactilar o identificaci√≥n biom√©trica facial."
msgstr ""

#: src/Secp256r1.md:19
msgid ""
"Cabe destacar que aunque se ha agregado otro firmante, no se ha a√±adido otra "
"seed phrase, esto tambi√©n tiene el beneficio adicional de alejarse de las "
"seed phrase a una mejor seguridad en los dispositivos m√≥viles/computadoras "
"port√°tiles modernas, y seguridad superior cuando el dispositivo del usuario "
"admite un chip de seguridad dedicado, como el [elemento seguro Titan de "
"Android](https://cloud.google.com/blog/products/identity-security/titan-in-depth-security-in-plaintext) "
"o [Enclave Secure de "
"Apple](https://support.apple.com/es-us/guide/security/sec59b0b31ff/web), etc."
msgstr ""

#: src/Secp256r1.md:21
msgid ""
"Este chip Secure Enclave/Titan es un subsistema dedicado y aislado, "
"totalmente separado del procesador de aplicaciones que puede generar claves "
"privadas y mensajes de signo. Genera las teclas utilizando un generador "
"interno de n√∫meros aleatorios verdaderos "
"[**(TRNG)**](https://en.wikipedia.org/wiki/Hardware_random_number_generator) "
"y firma mensajes a trav√©s de la curva el√≠ptica `secp256r1` a trav√©s de su "
"acelerador interno de claves p√∫blicas "
"[**(PKA)**](https://www.rambus.com/security/crypto-accelerator-cores/pka-ip-28/). "
"Las claves privadas nunca abandonan el sistema seguro y son desconocidas / "
"inaccesibles para cualquier persona, ni siquiera para el usuario o para la "
"aplicaci√≥n en s√≠."
msgstr ""

#: src/Secp256r1.md:23
msgid ""
"Esto significa que incluso si el n√∫cleo del procesador de la aplicaci√≥n del "
"dispositivo se ve comprometido, **¬°Nuestras claves se mantendr√°n seguras!**"
msgstr ""

#: src/Secp256r1.md:30
msgid ""
"Vemos que esta implementaci√≥n de la firma ECDSA `secp256r1` en Cairo no es "
"nativa, lo que significa que no tiene un Builtin dedicado nativo, esto puede "
"llevar a un alto costo de gas al validar la firma. Sin embargo, Braavos es "
"uno de los que han adoptado esta maravillosa novedad y est√° trabajando en "
"mejorar la eficiencia de este proceso."
msgstr ""

#: src/Secp256r1.md:32
msgid ""
"Adem√°s, aprovechando la funcionalidad de Multi-Call incorporada, los "
"usuarios pueden agrupar m√∫ltiples transacciones en una √∫nica transacci√≥n "
"at√≥mica. Esto no solo acelera y reduce los costos de las transacciones, sino "
"que tambi√©n permite a los usuarios aprobar la cantidad exacta que desean "
"depositar, lo cual mejora la seguridad al eliminar la necesidad de "
"[aprobaci√≥n "
"infinita](https://hackernoon.com/erc20-infinite-approval-a-battle-between-convenience-and-security-lk60350r)"
msgstr ""

#: src/Secp256r1.md:34
msgid ""
"En cuanto a la **gesti√≥n de firmantes**, cuando se a√±ade un firmante "
"adicional, como un Hardware Signer o Protected Signer, el firmante original "
"basado en semillas ya no puede firmar transacciones, a menos que se solicite "
"la eliminaci√≥n del firmante adicional y se regrese al firmante basado en "
"semillas. **Esta solicitud tiene un retraso de tiempo (actualmente de 4 "
"d√≠as)** para su procesamiento."
msgstr ""

#: src/Secp256r1.md:36
msgid ""
"Por otro lado, la funci√≥n de multifirma permite configurar la cuenta en modo "
"de multifirma (actualmente admite 2 de 2), lo que significa que ninguna "
"transacci√≥n se ejecutar√° hasta que los 2 firmantes definidos en la cuenta "
"firmen la transacci√≥n. La seed phrase puede solicitar la desactivaci√≥n de la "
"multifirma, pero esto **tambi√©n tiene un retraso de tiempo (actualmente 4 "
"d√≠as)** antes de que se haga efectiva."
msgstr ""

#: src/Secp256r1.md:38
msgid ""
"Vemos la importancia de las firmas y como vimos en el contexto del PQS, "
"entendemos la relevancia de poder modificar nuestros esquemas de "
"verificaci√≥n de firmas, como la utilizaci√≥n de Lattice o Kyber, por ejemplo. "
"Ahora, centr√©monos en aprender c√≥mo creamos una Stark Key para StarkEx, el "
"motor de escalabilidad de Starknet."
msgstr ""

#: src/Stark_Key.md:1
msgid "# Creaci√≥n de una Stark Key en StarkEx"
msgstr ""

#: src/Stark_Key.md:2
msgid ""
"Es importante comprender c√≥mo "
"[StarkEx](https://mirror.xyz/dashboard/edit/KJVQJ6X6wvbf6ps1oy96zpE3TztWyhSIDZd2IHu5NuI) "
"se comunica con otras billeteras en t√©rminos de firmas, y c√≥mo mantiene todo "
"el motor de transacciones y pruebas STARKs en su interior."
msgstr ""

#: src/Stark_Key.md:4
msgid ""
"StarkEx ofrece soluciones altamente especializadas para diferentes "
"aplicaciones que deseen construir sobre su servicio, y esto es parte de lo "
"que StarkWare, como compa√±√≠a, proporciona a grandes empresas o cualquier "
"otra entidad que desee aprovechar su conjunto de profesionales y servicios "
"adaptables."
msgstr ""

#: src/Stark_Key.md:6
msgid ""
"Aplicaciones populares como Sorare, Rhino y Apex Pro, por ejemplo, "
"aprovechan las soluciones ofrecidas por StarkWare. Estas aplicaciones "
"espec√≠ficas se construyen sobre el marco de Starknet. Si bien no "
"profundizaremos en los detalles espec√≠ficos de estas aplicaciones aqu√≠, se "
"recomienda visitar la [Biblioteca de Layer 2 en "
"Espa√±ol](https://layer2es.notion.site/39d63a8af9ca4524a7237b1f2456e745) para "
"obtener informaci√≥n m√°s detallada sobre cada una de ellas y comprender mejor "
"c√≥mo se integran en las soluciones de escalado de capa 2 de Ethereum."
msgstr ""

#: src/Stark_Key.md:8
msgid ""
"Para utilizar StarkEx y asociar tu cuenta de MetaMask u otra billetera a "
"Starknet, es necesario crear una Stark Key. StarkEx admite diferentes tipos "
"de billeteras y m√©todos para crear esta clave, dependiendo de c√≥mo se "
"utilizar√° posteriormente. A continuaci√≥n, se detallan las opciones "
"disponibles:"
msgstr ""

#: src/Stark_Key.md:10
msgid "## Billeteras compatibles con BIP32"
msgstr ""

#: src/Stark_Key.md:11
msgid ""
"Si est√°s utilizando una billetera compatible con "
"[**BIP32**](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), "
"como Ledger, se recomienda seguir el EIP-2645. Este est√°ndar describe una "
"ruta denominada `starkPath` y un algoritmo de derivaci√≥n de clave que "
"utiliza esta ruta para obtener la `starkPrivateKey`."
msgstr ""

#: src/Stark_Key.md:13
msgid ""
"La `starkPath` est√° compuesta por cuatro par√°metros pasados y dos par√°metros "
"internos, y sigue la siguiente estructura:"
msgstr ""

#: src/Stark_Key.md:15
msgid "`m/purpose'/layer'/application'/ethAddress1'/ethAddress2'/index`"
msgstr ""

#: src/Stark_Key.md:17
msgid "Los par√°metros externos pasados son los siguientes:"
msgstr ""

#: src/Stark_Key.md:19
msgid ""
"* **Purpose:** el n√∫mero de EIP correspondiente (en este caso, 2645).\n"
"* **Layer:** se utiliza para diferenciar entre tecnolog√≠as y se calcula como "
"`sha256(layer) & ((1 << 31) - 1))`. En el contexto de StarkEx, el valor es "
"`579218131` seg√∫n lo descrito en el EIP-2645.\n"
"* **Application:** sirve para diferenciar entre aplicaciones y se calcula "
"como: `sha256(application_name) & ((1 << 31) - 1))`.\n"
"* **Index:** permite tener m√∫ltiples claves por direcci√≥n de Ethereum."
msgstr ""

#: src/Stark_Key.md:24
msgid "Los par√°metros internos usados son los siguientes:"
msgstr ""

#: src/Stark_Key.md:26
msgid ""
"* **ethAddress1:** Los 31 LSB de la direcci√≥n Ethereum del usuario, es "
"decir, `(ethAddress & 1 << 31) - 1`\n"
"* **ethAddress2:** Los 31 LSB siguientes de la direcci√≥n Ethereum del "
"usuario, es decir, `(ethAddress >> 31) & 1 << 31) - `."
msgstr ""

#: src/Stark_Key.md:29
msgid ""
"Adem√°s, es importante que las billeteras compatibles con BIP32 mantengan un "
"estado persistente en relaci√≥n con su propia direcci√≥n de Ethereum."
msgstr ""

#: src/Stark_Key.md:31
msgid "## Billeteras NO compatibles con BIP32"
msgstr ""

#: src/Stark_Key.md:33
msgid ""
"Si est√°s utilizando una billetera que no es compatible con BIP32, como "
"MetaMask, se recomienda seguir el siguiente proceso:"
msgstr ""

#: src/Stark_Key.md:35
msgid ""
"1. El usuario firma un mensaje utilizando su clave privada de Ethereum a "
"trav√©s de MetaMask u otra billetera similar. Se recomienda utilizar el "
"est√°ndar  IP-712 para brindar transparencia al usuario durante el proceso de "
"firma. Es importante que el mensaje incluya una advertencia, indicando al "
"usuario que so1lo debe firmarlo si proviene de un dominio espec√≠fico.\n"
"2. La firma `(r, s, v)` se utiliza como entrada para el algoritmo de "
"derivaci√≥n de clave, que generar√° la `starkPrivateKey`. Para realizar este "
"c√°lculo, puedes utilizar la biblioteca [StarkEx Crypto "
"SDK](https://www.npmjs.com/package/@starkware-industries/starkware-crypto-utils). "
"Primero, llama a la funci√≥n `getPrivateKeyFromEthSignature` para obtener la "
"clave privada a partir de la firma, y luego utiliza la funci√≥n "
"`privateToStarkKey` para calcular la `StarkKey`."
msgstr ""

#: src/Stark_Key.md:38
msgid ""
"Al seguir estos pasos, podr√°s crear una Stark Key asociada a tu cuenta de "
"MetaMask u otra billetera compatible. Esta clave te permitir√° interactuar "
"con StarkEx y otras aplicaciones dentro del ecosistema de Starknet, realizar "
"transacciones seguras y aprovechar las funcionalidades ofrecidas por esta "
"plataforma."
msgstr ""

#: src/Starknet_funciones_hash.md:1
msgid "# Starknet y Funciones Hash"
msgstr ""

#: src/Starknet_funciones_hash.md:2
msgid ""
"Hemos visto la importancia de las firmas, el poder de AA y la asociaci√≥n de "
"los hash dentro del ecosistema de Starknet y StarkEx. Ahora, profundicemos "
"en c√≥mo se utilizan y los diferentes tipos de hash que podemos encontrar."
msgstr ""

#: src/Starknet_funciones_hash.md:4
msgid "## Dominio y rango"
msgstr ""

#: src/Starknet_funciones_hash.md:5
msgid ""
"Todas las salidas de las funciones de hash se mapean eventualmente a "
"elementos en `ùîΩ‚Çö` con `p = 2¬≤‚Åµ¬π + 17 ‚ãÖ 2¬π‚Åπ¬≤ + 1` como vimos en la Stark "
"Curve."
msgstr ""

#: src/Starknet_funciones_hash.md:7
msgid ""
"Las funciones hash son componentes clave en las especificaciones de "
"Starknet, y se utilizan para mapear las salidas de los c√°lculos a elementos "
"en el campo finito `ùîΩ‚Çö`. A continuaci√≥n, explicaremos las tres funciones "
"hash utilizadas en Starknet de manera m√°s clara:"
msgstr ""

#: src/Starknet_funciones_hash.md:14
msgid ""
"1. "
"[**sn_keccak:**](https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#starknet_keccak) "
"Esta funci√≥n hash se basa en el algoritmo KECCAK, que es una familia de "
"funciones hash criptogr√°ficas como vimos antes. Su dominio es el conjunto de "
"cadenas de bits compuestas por ceros y unos `{0,1}*` y su rango es el campo "
"finito `ùîΩ‚Çö` La funci√≥n toma una cadena de bits como entrada y produce una "
"salida en el campo finito `ùîΩ‚Çö`.\n"
"2. "
"[**Pedersen:**](https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash) "
"La funci√≥n hash Pedersen es una funci√≥n hash computacionalmente segura que "
"se utiliza en la construcci√≥n de criptograf√≠a de compromiso cero y otras "
"primitivas criptogr√°ficas. Su dominio es el conjunto de pares de elementos "
"del campo finito `ùîΩ¬≤p`, donde `p` es un n√∫mero primo, y su rango es el campo "
"finito `ùîΩp`. La funci√≥n toma un par de elementos del campo finito `ùîΩ¬≤p` como "
"entrada y produce una salida en el campo finito `ùîΩp`.\n"
"3. "
"[**Poseidon:**](https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#poseidon_hash) "
"La funci√≥n hash Poseidon es una funci√≥n hash criptogr√°fica. Su dominio es un "
"conjunto de elementos del campo finito `ùîΩp`, que incluye el cero y los "
"elementos inversos multiplicativos, y su rango tambi√©n es el campo finito "
"`ùîΩp`. La funci√≥n toma un conjunto de elementos del campo finito `ùîΩp` como "
"entrada y produce una salida en el campo finito `ùîΩp`."
msgstr ""

#: src/Starknet_funciones_hash.md:18
msgid ""
"Las funciones de hash mencionadas son a√±adidas como "
"[**Builtin**](https://mirror.xyz/0x7D1c14939AcEE5ca141c8beDF3474AFBf3884041/RTgQnMxeVGRCczih1pGXKy2KGFcU_xmf2NMx52wDgH0) "
"(AIR integradas espec√≠ficas de aplicaciones), que se utilizan como "
"herramientas adicionales en el protocolo para garantizar la seguridad y la "
"integridad de las transacciones y los datos."
msgstr ""

#: src/Starknet_funciones_hash.md:20
msgid ""
"Estas funciones hash desempe√±an un papel fundamental en las operaciones de "
"Starknet al garantizar la integridad y seguridad de los c√°lculos realizados "
"en el sistema."
msgstr ""

#: src/Keccak_Starknet.md:1
msgid "# Keccak Starknet"
msgstr ""

#: src/Keccak_Starknet.md:2
msgid ""
"Keccak en Starknet es una implementaci√≥n espec√≠fica de la funci√≥n hash "
"`Keccak256` adaptada para su uso en la red Starknet. Proporciona un m√©todo "
"confiable y eficiente para calcular hashes dentro del entorno de Starknet."
msgstr ""

#: src/Keccak_Starknet.md:4
msgid ""
"Generalmente denotado por `sn_keccak`, se define como los primeros **250 "
"bits del hash Keccak256** (esto es simplemente `Keccak256` ampliado para "
"ajustarse a un field element ‚Äúelemento de campo‚Äù)."
msgstr ""

#: src/Pedersen_Starknet.md:1
msgid "# Pedersen Hash Starknet"
msgstr ""

#: src/Pedersen_Starknet.md:2
msgid ""
"El [Pedersen "
"hash](https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash) "
"es una funci√≥n hash criptogr√°fica utilizada en criptograf√≠a propuesta por "
"Torben Pedersen en 1991."
msgstr ""

#: src/Pedersen_Starknet.md:4
msgid ""
"Uno de los aspectos interesantes del [esquema de compromiso de "
"Pedersen](https://en.wikipedia.org/wiki/Commitment_scheme) es su propiedad "
"homom√≥rfica, que permite realizar la adici√≥n entre dos compromisos. En otras "
"palabras, dados dos mensajes `m‚ÇÅ` y `m‚ÇÇ`, y sus respectivas aleatoriedades "
"`r‚ÇÅ` y `r‚ÇÇ`, el Pedersen hash permite combinarlos de manera segura."
msgstr ""

#: src/Pedersen_Starknet.md:6
msgid ""
"La funci√≥n Pedersen Hash utilizada en Starknet es resistente a colisiones "
"para entradas de longitud fija, siempre y cuando la funci√≥n de codificaci√≥n "
"subyacente sea inyectiva. Una funci√≥n inyectiva asigna elementos distintos "
"de su dominio a elementos distintos de su codominio, esto hace que el "
"Pedersen hash sea resistente a ciertos tipos de ataques, como colisiones y "
"preim√°genes."
msgstr ""

#: src/Pedersen_Starknet.md:8
msgid ""
"Sin embargo, es importante destacar que la implementaci√≥n y el contexto en "
"el que se utilice esta funci√≥n pueden influir en su resistencia. Para "
"obtener m√°s informaci√≥n se recomienda realizar una lectura sobre [Pedersen "
"hashes in "
"Practice](https://research.nccgroup.com/2023/03/22/breaking-pedersen-hashes-in-practice/)."
msgstr ""

#: src/Pedersen_Starknet.md:10
msgid ""
"En Starknet, se utiliza la EC amigable STARK curve sobre el campo finito "
"`ùîΩ‚Çö` para calcular el Pedersen hash de manera eficiente y segura."
msgstr ""

#: src/Pedersen_Starknet.md:17
msgid ""
"* Œ± = 1\n"
"* Œ≤ = 31415926535897932384626433832795028841971693993751058209749 "
"44592307816406665"
msgstr ""

#: src/Pedersen_Starknet.md:20
msgid ""
"Los par√°metros `Œ±` y `Œ≤` de la curva son importantes en t√©rminos de "
"seguridad y eficiencia en los algoritmos utilizados en la construcci√≥n del "
"Pedersen hash y los protocolos de ZKP o basados en STARK."
msgstr ""

#: src/Pedersen_Starknet.md:22
msgid ""
"Dada una entrada `(a, b) ‚àà ùîΩ¬≤p`, se divide en `alow`, `ahigh`, `blow` y "
"`bhigh`, donde la parte `low` consiste en los **248 bits menos "
"significativos del elemento** y la parte `high` consiste en los **4 bits m√°s "
"significativos del elemento.** El c√°lculo del Pedersen hash se define de la "
"siguiente manera:"
msgstr ""

#: src/Pedersen_Starknet.md:29
msgid ""
"En esta f√≥rmula, `[P]x` denota la coordenada `x` del punto `P`. Para "
"calcular el hash, se realiza una combinaci√≥n lineal de los puntos `P0, P1, "
"P2 y P3`, ponderados por los valores `alow`, `ahigh`, `blow` y `bhigh`, "
"respectivamente. Luego, se suma el punto `shift_point` y se extrae la "
"coordenada `x` del resultado."
msgstr ""

#: src/Pedersen_Starknet.md:31
msgid ""
"Los valores de las constantes `shift_point`, `P0`, `P1`, `P2` y `P3` se "
"encuentran en el archivo "
"[fast_pedersen_hash.py](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/crypto/signature/fast_pedersen_hash.py). "
"Este archivo contiene la implementaci√≥n espec√≠fica del algoritmo necesario "
"para calcular el Pedersen hash."
msgstr ""

#: src/Pedersen_Starknet.md:33
msgid ""
"No se trata de puntos en la EC en s√≠ misma, sino de valores espec√≠ficos que "
"se han elegido para el c√°lculo del hash y tampoco est√°n relacionadas con la "
"EC ni con el punto generador `G`, revise minuciosamente la informaci√≥n "
"oficial en caso de querer hacer pruebas sobre Stark Curve o Hash en "
"Starknet. Estas constantes se eligen de forma independiente para el c√°lculo "
"del hash y se utilizan en combinaci√≥n con los valores de entrada para "
"obtener el hash resultante."
msgstr ""

#: src/Poseidon_Starknet.md:1
msgid "# Poseidon hash Starknet"
msgstr ""

#: src/Poseidon_Starknet.md:2
msgid ""
"La funci√≥n **Poseidon hash** es un [ZK-friendly "
"Hashing](https://www.poseidon-hash.info/), pertenece a una familia de "
"funciones hash dise√±adas para ser muy eficientes en circuitos algebraicos. "
"Como tal, pueden ser muy √∫tiles en sistemas ZK proof como STARKs y otros."
msgstr ""

#: src/Poseidon_Starknet.md:4
msgid ""
"Poseidon es una construcci√≥n de esponja basada en la permutaci√≥n Hades, la "
"estrategia de dise√±o Hades se basa en dividir el proceso en diferentes "
"rondas para garantizar la seguridad y eficiencia del algoritmo:"
msgstr ""

#: src/Poseidon_Starknet.md:6
msgid ""
"* En las primeras rondas, denominadas `Rf`, se aplican las `S-boxes` al "
"estado completo. Las `S-boxes` son funciones no lineales que mezclan y "
"transforman los datos. En esta etapa inicial, se busca lograr una alta "
"dispersi√≥n de los bits en el estado.\n"
"* Despu√©s de estas rondas iniciales, se llevan a cabo las rondas "
"intermedias, denominadas `RP`. En cada ronda intermedia, se aplica "
"√∫nicamente una `S-box`, mientras que el resto del estado permanece sin "
"cambios, es decir, se utiliza una funci√≥n identidad en lugar de las "
"`S-boxes` faltantes. Esta simplificaci√≥n reduce el costo computacional y la "
"complejidad del algoritmo.\n"
"* Finalmente, en las √∫ltimas rondas, nuevamente se utilizan las `S-boxes` "
"para el estado completo. Estas rondas finales, al igual que las rondas "
"iniciales, permiten obtener una mezcla y transformaci√≥n adicional de los "
"datos."
msgstr ""

#: src/Poseidon_Starknet.md:10
msgid ""
"Para una revisi√≥n m√°s profunda sobre su integridad en sistema de Proof "
"pueden revisar [POSEIDON: A New Hash Function for Zero-Knowledge Proof "
"Systems (Updated Version)](https://eprint.iacr.org/2019/458.pdf)."
msgstr ""

#: src/Poseidon_Starknet.md:12
msgid ""
"La versi√≥n de **Poseidon** utilizada en Starknet se basa en una permutaci√≥n "
"de estado de tres elementos."
msgstr ""

#: src/Poseidon_Starknet.md:14
msgid ""
"El campo **ùîΩ**, sobre el que se definen las declaraciones aritm√©ticas que "
"utilizan Poseidon. A menudo es determinado por el sistema de prueba ZK. Lo "
"m√°s probable es que sea un subgrupo de primer orden del grupo de puntos de "
"una curva el√≠ptica. Poseidon mapea secuencias de elementos **ùîΩ** a una "
"secuencia de longitud fija de elementos **ùîΩ**."
msgstr ""

#: src/Poseidon_Starknet.md:16
msgid ""
"A continuaci√≥n, se define el **Poseidon hash** de hasta 2 elementos, y "
"tambi√©n se menciona una versi√≥n que admite un n√∫mero arbitrario de entradas."
msgstr ""

#: src/Hashing_Array.md:1
msgid "# Hashing de Array (matrices)"
msgstr ""

#: src/Hashing_Array.md:2
msgid ""
"Estas definiciones explican c√≥mo se realizan los hashing de matrices "
"utilizando las funciones Pedersen y Poseidon en el contexto de Starknet. "
"Estas operaciones son fundamentales para asegurar la integridad y la "
"seguridad de los c√°lculos realizados en el sistema."
msgstr ""

#: src/Hashing_Array.md:4
msgid ""
"El hashing de un array implica aplicar la funci√≥n de hash correspondiente a "
"cada elemento del array, de manera secuencial o iterativa. Esto permite "
"resumir y representar de manera compacta la informaci√≥n contenida en el "
"array, independientemente de su longitud o contenido espec√≠fico."
msgstr ""

#: src/Hashing_Array.md:6
msgid ""
"El hashing de un array es √∫til en muchas aplicaciones, como la verificaci√≥n "
"de integridad de datos, la indexaci√≥n eficiente de informaci√≥n y la "
"identificaci√≥n √∫nica de elementos."
msgstr ""

#: src/Hashing_Array.md:8
msgid "## Pedersen"
msgstr ""

#: src/Hashing_Array.md:9
msgid ""
"La funci√≥n hash Pedersen, denotada como `h`, se utiliza para calcular el "
"hash de un array de elementos de campo. Consideremos un arreglo `a‚ÇÅ`, `a‚ÇÇ`, "
"..., `a‚Çô` que contiene `n` elementos. La definici√≥n de `h(a‚ÇÅ a‚ÇÇ, ..., a‚Çô)` "
"es la siguiente:"
msgstr ""

#: src/Hashing_Array.md:11
msgid ""
"1. Comenzamos con un valor inicial de 0.\n"
"2. Aplicamos la funci√≥n de hash h al primer elemento a‚ÇÅ junto con el valor "
"inicial. El resultado se convierte en el nuevo valor inicial.\n"
"3. Continuamos aplicando la funci√≥n de hash h al siguiente elemento a‚ÇÇ junto "
"con el valor anteriormente obtenido. Nuevamente, el resultado se convierte "
"en el nuevo valor inicial.\n"
"4. Repetimos este proceso hasta llegar al √∫ltimo elemento a‚Çô, aplicando la "
"funci√≥n de hash en cada paso.\n"
"5. Finalmente, aplicamos la funci√≥n de hash h al √∫ltimo elemento an junto "
"con el valor obtenido en el paso anterior."
msgstr ""

#: src/Hashing_Array.md:17
msgid ""
"De esta manera, obtenemos el resultado final que representa el hash del "
"array completo."
msgstr ""

#: src/Hashing_Array.md:24
msgid ""
"Esta construcci√≥n en capas nos permite combinar de manera secuencial los "
"elementos del array a medida que calculamos el hash. Cada iteraci√≥n agrega "
"un nivel adicional de seguridad y complejidad al resultado final."
msgstr ""

#: src/Hashing_Array.md:26
msgid "## Poseidon"
msgstr ""

#: src/Hashing_Array.md:27
msgid ""
"La funci√≥n de hash Poseidon utiliza la permutaci√≥n Hades, representada por "
"hades: `ùîΩ¬≥‚Çö‚ÜíùîΩ‚Çö`, con los par√°metros de Starknet. Dado un array `a‚ÇÅ`, `a‚ÇÇ`, "
"..., `a‚Çô` que contiene `n` field elements, definimos `poseidon(a‚ÇÅ, a‚ÇÇ, ..., "
"a‚Çô)` como la primera coordenada de `H(a‚ÇÅ, a‚ÇÇ, ..., a‚Çô; 0, 0, 0)`,"
msgstr ""

#: src/Hashing_Array.md:29
msgid "* `H(a‚ÇÅ, a‚ÇÇ, ..., a‚Çô; s‚ÇÅ, s‚ÇÇ, s‚ÇÉ)` se define de la siguiente manera:"
msgstr ""

#: src/Hashing_Array.md:36
msgid ""
"* **Si n ‚â• 2:** entonces `H(a‚ÇÅ,a‚ÇÇ,...,a‚Çô;s‚ÇÅ,s‚ÇÇ,s‚ÇÉ) = H(a‚ÇÉ, a‚ÇÑ, ..., "
"a‚Çô;hades(s‚ÇÅ + a‚ÇÅ, s‚ÇÇ + a‚ÇÇ, s‚ÇÉ))`.\n"
"* **Si n = 1:** entonces `H(a‚ÇÅ; s‚ÇÅ, s‚ÇÇ, s‚ÇÉ) = hades(s‚ÇÅ + a‚ÇÅ, s‚ÇÇ + 1, s‚ÇÉ)`.\n"
"* **Si n = 0:** entonces `H(); s‚ÇÅ, s‚ÇÇ, s‚ÇÉ) = hades(s‚ÇÅ + 1, s‚ÇÇ, s‚ÇÉ)`."
msgstr ""

#: src/Hashing_Array.md:40
msgid ""
"En resumen, la `funci√≥n poseidon(a‚ÇÅ,a‚ÇÇ,...,a‚Çô)` toma el array de field "
"elements y aplica la permutaci√≥n Hades en capas. Cada iteraci√≥n de la "
"permutaci√≥n combina los elementos del array en funci√≥n de los valores de  "
"`s‚ÇÅ`, `s‚ÇÇ` y `s‚ÇÉ`, generando as√≠ una salida √∫nica. La primera coordenada de "
"la salida final se considera el resultado de la funci√≥n de hash Poseidon."
msgstr ""

#: src/Hashing_Array.md:42
msgid ""
"Esta construcci√≥n en capas y la utilizaci√≥n de la permutaci√≥n Hades permiten "
"obtener un hash seguro y resistente a ciertos ataques criptogr√°ficos."
msgstr ""

#: src/Starks.md:1
msgid "# S-T-ARKs"
msgstr ""

#: src/Starks.md:2
msgid ""
"Ahora, adentr√©monos en una de las partes m√°s fascinantes del ecosistema, los "
"**STARKs** [(Scalable Transparent Argument of "
"Knowledge)](https://starkware.co/stark/) se basan en los principios de la "
"criptograf√≠a sim√©trica combinados con matem√°ticas modernas, la existencia de "
"funciones hash criptogr√°ficas seguras y resistentes a las colisiones. Muchas "
"de estas primitivas existen hoy en d√≠a como instrucciones de hardware, y la "
"criptograf√≠a magra conduce a dos beneficios m√°s:"
msgstr ""

#: src/Starks.md:4
msgid ""
"1. **Seguridad poscu√°ntica:** los **STARK** son plausiblemente seguros "
"frente a ordenadores cu√°nticos eficientes.\n"
"2. **Eficiencia concreta:** el prover **STARK** es al menos **10 veces m√°s "
"r√°pido** que el prover SNARK y el prover "
"[Bulletproofs](https://eprint.iacr.org/2017/1066.pdf).\n"
"\n"
"    El verificador **STARK** es al menos **2 veces m√°s r√°pido** que el "
"verificador **SNARK** y m√°s de **10 veces m√°s r√°pido** que el verificador "
"**Bulletproof**.\n"
"\n"
"    A medida que StarkWare contin√∫e optimizando **STARKs** estos ratios "
"probablemente mejorar√°n. Sin embargo, la longitud de una prueba **STARK es "
"~100x mayor** que la correspondiente **SNARK** y **~20x mayor que "
"BulletProofs**."
msgstr ""

#: src/Starks.md:11
msgid ""
"Puede encontrar una imagen animada en una comparativa con los datos "
"expuestos sobre el Proving Time y Verification Time, Tama√±o de la Proof, "
"Configuraci√≥n inicial y PQS entre STARKs y SNARKs, veremos como cada una "
"cumple con propiedades que puede ser recomendada para darle mejor uso."
msgstr ""

#: src/Starks.md:18
msgid ""
"Ahora que tenemos conceptos m√°s profundos sobre algunos aspectos de la "
"criptograf√≠a, funciones hash y las operaciones detr√°s de cada una, veamos la "
"importancia de la Integridad Computacional (CI), una propiedad fundamental "
"para el d√≠a a d√≠a. Esta propiedad se refiere a la confianza en que la salida "
"de un c√°lculo es correcta, permiti√©ndonos confiar en el saldo de una cuenta "
"o en el monto de una factura en una tienda."
msgstr ""

#: src/Starks.md:20
msgid ""
"> **Pero, ¬øc√≥mo podemos garantizar esta integridad en un entorno digital "
"donde no siempre podemos confiar en todas las partes involucradas?**"
msgstr ""

#: src/Starks.md:22
msgid ""
"Aqu√≠ es donde entra en juego la tecnolog√≠a STARK, que se basa en estas "
"Validity Proofy para garantizar que la computaci√≥n se realice correctamente, "
"**incluso si nadie est√° observando `‚ÄúINTEGRO‚Äù`**. STARKs utiliza matem√°ticas "
"para lograr este objetivo y est√° dise√±ado para monitorear y garantizar la "
"integridad de un gran c√°lculo realizado por un grupo de supercomputadoras "
"poco confiables."
msgstr ""

#: src/Starks.md:24
msgid ""
"Las Validity Proofs son una herramienta crucial para garantizar la "
"integridad y validez de los cambios realizados fuera de la cadena principal. "
"Los sistemas de ZKP, en los que el prover posee informaci√≥n secreta que no "
"es conocida por el verifier, son clave para las Validity Proofs. En el caso "
"de Starknet, se trata de un Validity Rollup que utiliza STARKs."
msgstr ""

#: src/Starks.md:26
msgid ""
"Es importante tener en cuenta que ZK en Starknet, es una propiedad adicional "
"que se utiliza para afirmar al probador que no tiene que revelar ninguna "
"informaci√≥n incluida en el c√°lculo. Sin embargo, en el caso de Starknet como "
"una capa 2 p√∫blica, los datos de transacci√≥n son p√∫blicos, lo que significa "
"que no se ofrece privacidad como tal en transacciones, ocultar saldos u "
"otras operaciones opacas, aunque los zk-STRAKs est√°n listas para eso."
msgstr ""

#: src/Starks.md:28
msgid ""
"En Starknet, el enfoque principal es el Validity Rollup, que se utiliza para "
"probar la validez del c√°lculo computacional, a diferencia de otros "
"protocolos que utilizan mal nombrado ZK Rollup. La propiedad ZK se utiliza "
"en Starknet para escalar el rendimiento, no para garantizar privacidad, por "
"lo tanto, los STARKs en Starknet son Validity Proofs en lugar de ZK Proofs."
msgstr ""

#: src/Starks.md:30
msgid ""
"Los STARKs utilizan funciones de criptograf√≠a sim√©trica y hash "
"criptogr√°ficos como componentes fundamentales en su construcci√≥n, las "
"vulnerabilidades cu√°nticas conocidas en criptograf√≠a, como el algoritmo de "
"Shor que puede factorizar n√∫meros enteros grandes y romper sistemas de "
"criptograf√≠a asim√©trica basados en factorizaci√≥n, no afectan a las STARKs."
msgstr ""

#: src/Starks.md:37
msgid ""
"En la imagen superior, se puede observar que las pruebas pueden basarse en "
"principios de criptograf√≠a sim√©trica o asim√©trica, como aprendimos al "
"principio del documento. Adem√°s, se pueden apreciar las diferentes "
"propiedades de cada una en cuanto a escalabilidad, transparencia, seguridad "
"en el futuro post-cu√°ntico o tama√±o de la prueba."
msgstr ""

#: src/Starks.md:39
msgid ""
"Como conclusi√≥n final antes de pasar a sus propiedades podemos ver para "
"pruebas cortas como se recomienda utilizar **Groth16** o **SNARKs**, "
"mientras que para todo lo dem√°s se sugiere **STARK**. Es importante destacar "
"que este campo se encuentra en constante desarrollo y cada uno sigue "
"optimizando sus propias soluciones. Tanto las **STARKs** como Starknet "
"tambi√©n experimentar√°n optimizaciones para mejorar **STARK** y/o admitir "
"diferentes tipos de pruebas. Un ejemplo de esto es como "
"[Keep-Starknet-Strange](https://github.com/keep-starknet-strange) el equipo "
"detr√°s de [**Garaga**](https://github.com/keep-starknet-strange/garaga), que "
"est√° trabajando en diversas librer√≠as criptogr√°ficas como "
"[Plonk](https://eprint.iacr.org/2019/953.pdf), "
"[Groth16](https://eprint.iacr.org/2016/260.pdf), **SNARK**, entre otras."
msgstr ""

#: src/Starks.md:41
msgid ""
"Si desea obtener m√°s informaci√≥n sobre como los STARKs est√°n en diversas "
"arquitectura y sus diversos casos de uso para asentar las bases dela "
"criptograf√≠a moderna, recomendamos leer el articulo que sacamos para L2 "
"Espa√±ol [Profundizando en el Ecosistema "
"STARKs](https://mirror.xyz/layer2es.eth/8TUEfpZPgl1u3-HyyGaUA0YMrFm8XSHfYtY6tfqFX7s)"
msgstr ""

#: src/Starks_Propiedades.md:1
msgid "## Propiedas de las STARKs"
msgstr ""

#: src/Starks_Propiedades.md:2
msgid ""
"Hemos visto c√≥mo diferenciar los tipos de pruebas seg√∫n su criptograf√≠a, as√≠ "
"como la comparativa entre varias de ellas. Ahora veamos cu√°les son las dos "
"propiedades esenciales en las pruebas y c√≥mo se pueden lograr, antes de "
"pasar a la definici√≥n de STARK"
msgstr ""

#: src/Starks_Propiedades.md:4
msgid ""
"1. **Succintness (Sucintez):** exigimos que nuestras pruebas y, en "
"particular, el tiempo de verificaci√≥n sean sucintos, es decir, que sean "
"√≥rdenes de magnitud m√°s peque√±os que el tiempo necesario para calcular "
"nuestro programa. De lo contrario, no habr√≠a ninguna ventaja para el "
"verificador en utilizar la prueba en lugar del c√°lculo original.\n"
"2. **Heur√≠stica Fiat-Shamir:** este es un proceso mediante el cual podemos "
"convertir una prueba interactiva en una no interactiva. Funciona "
"proporcionando compromisos a los mensajes que formar√≠an la interacci√≥n y las "
"funciones hash se utilizan como fuente de aleatoriedad."
msgstr ""

#: src/Starks_Propiedades.md:7
msgid ""
"Uno de los protocolos que se utiliza en sistemas criptogr√°ficos, como los "
"STARKs, para abordar el desaf√≠o de verificar eficientemente la correcci√≥n de "
"grandes c√°lculos polinomiales es FRI (Fast Reed-Solomon Interactive Oracle "
"Proofs of Proximity)."
msgstr ""

#: src/Starks_Propiedades.md:9
msgid ""
"FRI utiliza c√≥digos de correcci√≥n de errores Reed-Solomon para permitir "
"pruebas interactivas eficientes. Esto significa que el probador puede "
"proporcionar una prueba corta de la correcci√≥n del c√°lculo, mientras que el "
"verificador puede verificar de manera eficiente la validez de la prueba. "
"Este proceso interactivo permite realizar pruebas de proximidad, donde el "
"verificador puede verificar de manera eficiente si el c√°lculo reclamado se "
"acerca al resultado correcto sin tener que evaluar por completo todo el "
"polinomio."
msgstr ""

#: src/Starks_Propiedades.md:11
msgid ""
"> El conjunto de operaciones matem√°ticas, bases criptogr√°ficas, FRI y otras "
"propiedades, como Fiat-Shamir, permite que las STARKs logren seguridad "
"cu√°ntica y escalabilidad, al tiempo que proporcionan una verificaci√≥n "
"transparente y eficiente de c√°lculos complejos."
msgstr ""

#: src/Starks_Propiedades.md:13
msgid ""
"Podemos decir entonces que los STARKs demuestran la correcta operaci√≥n de "
"una m√°quina virtual al demostrar que la traza de ejecuci√≥n asociada es "
"v√°lida con respecto al AIR dado. En t√©rminos generales, las trazas de "
"ejecuci√≥n se organizan como tablas de n√∫meros, y el protocolo STARK "
"demuestra que estos n√∫meros resuelven conjuntamente un sistema de polinomios."
msgstr ""

#: src/Starks_Propiedades.md:15
msgid ""
"As√≠ vemos c√≥mo algunas de estas propiedades, como la succintez, pueden venir "
"de forma natural en las STARKs, y c√≥mo el principio de Fiat-Shamir permite "
"realizar pruebas interactivas. Adem√°s, contar con FRI como correcci√≥n de "
"errores ampl√≠a las capacidades y visi√≥n de las STARKs, as√≠ que ahora vayamos "
"a su definici√≥n"
msgstr ""

#: src/Starks_Propiedades.md:17
msgid "## S = Scalable"
msgstr ""

#: src/Starks_Propiedades.md:19
msgid ""
"Una de las principales ventajas de STARKs es que al trasladar un c√°lculo "
"fuera de la cadena, se reducen de manera exponencial los costos de "
"verificaci√≥n en la cadena de bloques. El proceso de creaci√≥n de una prueba "
"fuera de la cadena tiene un costo similar al de solicitar a un √∫nico nodo de "
"la cadena de bloques que realice el c√°lculo."
msgstr ""

#: src/Starks_Propiedades.md:21
msgid ""
"La producci√≥n de pruebas no resulta considerablemente m√°s costosa que la "
"ejecuci√≥n del c√°lculo original, y la validaci√≥n de las pruebas es "
"**exponencialmente m√°s r√°pida** que la ejecuci√≥n del c√°lculo original. "
"Adem√°s, las pruebas son **considerablemente m√°s cortas** en tama√±o que el "
"c√°lculo original."
msgstr ""

#: src/Starks_Propiedades.md:23
msgid ""
"Otra ventaja importante es que a medida que se incrementa la cantidad de "
"c√≥mputo, su crecimiento es casi lineal. Esto la convierte en una opci√≥n "
"ideal para procesar transacciones a gran escala."
msgstr ""

#: src/Starks_Propiedades.md:30
msgid ""
"Adem√°s, se puede aprovechar la capacidad de paralelizaci√≥n de pruebas por el "
"prover y recursividad de los STRAKs eficentes para mejorar "
"significativamente la escalabilidad."
msgstr ""

#: src/Starks_Propiedades.md:37
msgid "## T = Transparent"
msgstr ""

#: src/Starks_Propiedades.md:39
msgid ""
"La seguridad de las STARKs no depende de ceremonias de configuraci√≥n "
"elaboradas que puedan generar residuos t√≥xicos criptogr√°ficos, como ocurre "
"en otras tecnolog√≠as de pruebas."
msgstr ""

#: src/Starks_Propiedades.md:41
msgid ""
"El uso de STARKs para iniciar la prueba bas√°ndose en criptograf√≠a sim√©trica, "
"pseudoaleatoriedad y las matem√°ticas proporciona un inicio de ceremonia "
"transparente y elimina la necesidad de una configuraci√≥n de confianza "
"inicial (trusted setup), lo que asegura la ausencia de residuos t√≥xicos y "
"mejora la seguridad y confiabilidad general del sistema criptogr√°fico."
msgstr ""

#: src/Starks_Propiedades.md:43
msgid ""
"Una caracter√≠stica importante de las STARKs es su construcci√≥n basada en el "
"trabajo de [Micali](https://es.wikipedia.org/wiki/Silvio_Micali). En esta "
"construcci√≥n, la √∫nica criptograf√≠a necesaria para producir o validar una "
"prueba corta `ùõë` es una **funci√≥n hash criptogr√°fica** `H`, como `SHA-256` o "
"`Keccak`. La elecci√≥n de `H` se convierte en el √∫nico **\"par√°metro "
"global\"** que todos los usuarios del sistema de prueba deben conocer, y "
"**esta elecci√≥n puede hacerse de manera p√∫blica, garantizando la "
"transparencia de las pruebas criptogr√°ficas obtenidas a trav√©s de las "
"STARKs.**"
msgstr ""

#: src/Starks_Propiedades.md:45
msgid ""
"Sin embargo siempre comparamos STARKs con SNARKs o pruebas derivadas de "
"criptograf√≠a asim√©trica como las "
"[Pinocchio](https://eprint.iacr.org/2013/279.pdf) de ECC, pero cada una "
"tiene sus varientes y esquemas diversos,  aunque para una explicaci√≥n m√°s "
"clara cogeremos el ejemplo de [VB en un art√≠culo sobre "
"zk-SNARKs](https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6)."
msgstr ""

#: src/Starks_Propiedades.md:52
msgid ""
"Imaginemos que tenemos un par de puntos `P` y `Q`, donde `P * k = Q`, y "
"tienes un punto `C`, entonces no es posible obtener `C * k` a menos que `C` "
"est√© **\"derivado\"** de alguna manera que conozcas a partir de `P`. Esto "
"puede parecer intuitivamente obvio, pero esta suposici√≥n en realidad no "
"puede derivarse de ninguna otra suposici√≥n (por ejemplo, la dificultad del "
"logaritmo discreto) que usualmente utilizamos al probar la seguridad de los "
"protocolos basados en EC. Por lo tanto, los SNARKs se basan en una base un "
"tanto m√°s fr√°gil que la ECC en general."
msgstr ""

#: src/Starks_Propiedades.md:54
msgid ""
"Supongamos que cae del cielo un par de puntos `(P, Q)`, donde `P * k = Q`, "
"pero nadie conoce el valor de `k`. Ahora, supongamos que yo presento un par "
"de puntos `(R, S)` donde `R * k = S`. Entonces, la suposici√≥n de "
"conocimiento del extremo de la curva (KoE, por sus siglas en ingl√©s) implica "
"que la √∫nica forma en que podr√≠a haber creado ese par de puntos es tomando "
"`P` y `Q`, y multiplic√°ndolos por un factor `r` que **solo yo conozco**. "
"Tambi√©n hay que tener en cuenta que, gracias a la magia de las parejas de "
"curvas el√≠pticas, verificar que `R = k * S` no requiere conocer `k`; en su "
"lugar, simplemente puedes comprobar si `e(R, Q) = e(P, S)`, donde e es una "
"funci√≥n de emparejamiento de curvas el√≠pticas."
msgstr ""

#: src/Starks_Propiedades.md:56
msgid ""
"Hagamos algo m√°s interesante. Supongamos que caen del cielo diez pares de "
"puntos: `(P_1, Q_1), (P_2, Q_2) ... (P_10, Q_10)`. En todos los casos, se "
"cumple que `P_i * k = Q_i`, ahora, supongamos que te proporciono un par de "
"puntos `(R, S)` donde `R * k = S`."
msgstr ""

#: src/Starks_Propiedades.md:58
msgid ""
"**¬øQu√© sabemos ahora?** Que `R` es una combinaci√≥n lineal de la forma `P_1 * "
"i_1 + P_2 * i_2 + ... + P_10 * i_10`, donde yo conozco los coeficientes "
"`i_1, i_2 ... i_10`, es decir, la √∫nica forma de obtener un par de puntos "
"`(R, S)` de esta manera es tomando algunos m√∫ltiplos de `P_1, P_2 ... P_10` "
"y sum√°ndolos, y hacer el mismo c√°lculo con `Q_1, Q_2 ... Q_10.`"
msgstr ""

#: src/Starks_Propiedades.md:60
msgid ""
"Enrtonces tenemos que tener en cuenta que dado cualquier conjunto espec√≠fico "
"de puntos `P_1‚Ä¶P_10` para los que puedas querer verificar combinaciones "
"lineales, en realidad no puedes crear los puntos correspondientes `Q_1‚Ä¶Q_10` "
"sin conocer el valor de `k`, y si conoces el valor de `k`, entonces puedes "
"crear un par `(R, S)` donde `R * k = S` para cualquier `R` que desees, sin "
"necesidad de crear una combinaci√≥n lineal."
msgstr ""

#: src/Starks_Propiedades.md:62
msgid ""
"**Por lo tanto, para que esto funcione, es absolutamente imperativo que "
"quien cree esos puntos sea confiable y realmente elimine `k` una vez que "
"haya creado los diez puntos.**"
msgstr ""

#: src/Starks_Propiedades.md:64
msgid ""
"Se debe destacar la importancia de las ceremonias de ajuste inicial en "
"ciertos casos, como en implementaciones de sistemas de votaci√≥n. En estos "
"casos, es crucial tener en cuenta qui√©n ha sido el creador de los puntos y "
"si existe alguna posibilidad de manipulaci√≥n o si se ha eliminado "
"correctamente el valor de k. Esto es necesario para lograr transparencia y "
"evitar depender de estas verificaciones. En este sentido, los STARKs se "
"presentan como una soluci√≥n prometedora y **EFICIENTE**, ya que proporcionan "
"una base s√≥lida que elimina la necesidad de confiar en dichas ceremonias de "
"ajuste inicial."
msgstr ""

#: src/Starks_Propiedades.md:66
msgid "## ARK = Argument of Knowledge"
msgstr ""

#: src/Starks_Propiedades.md:67
msgid ""
"Los argumentos de conocimiento ‚ÄúARK‚Äù son llevados a cabo por el prover que "
"opera fuera de la cadena principal. Este probador se encarga de ejecutar el "
"c√°lculo requerido para la prueba, utilizando las entradas auxiliares "
"necesarias, la realizaci√≥n de la prueba fuera de la cadena principal es "
"clave, ya que debe garantizar la integridad y la confiabilidad del proceso."
msgstr ""

#: src/Starks_Propiedades.md:69
msgid ""
"La principal ventaja de esta metodolog√≠a es que permite una verificaci√≥n "
"aut√©ntica y matem√°ticamente s√≥lida. Despu√©s de que el probador haya "
"realizado el c√°lculo, puede proporcionar la prueba generada a cualquier "
"computadora o entidad interesada para su verificaci√≥n, haciendo uso de ARK "
"sto significa que cualquier sistema inform√°tico puede confirmar la validez "
"de la prueba de manera independiente."
msgstr ""

#: src/Starks_Eficientes.md:1
msgid "## STARKS eficientes"
msgstr ""

#: src/Starks_Eficientes.md:2
msgid ""
"Est√° llegando el momento de comprender como los STARKs son una versi√≥n m√°s "
"eficiente de las "
"[**(PCP)**](https://en.wikipedia.org/wiki/Probabilistically_checkable_proof), "
"un protocolo que permite establecer la exactitud de las declaraciones de "
"**CI**, mediante una verificaci√≥n aleatoria local en una prueba larga, este "
"protocolo se realiza entre un prover **PCP** y un verifier **PCP**."
msgstr ""

#: src/Starks_Eficientes.md:4
msgid ""
"El prover **PCP** produce una cadena de prueba `ùöø` que codifica el "
"seguimiento de c√°lculo de la declaraci√≥n de `CI`, a pesar de que `ùöø` es m√°s "
"larga que la traza de c√°lculo de pasos `T`. Sin embargo, la cadena de prueba "
"`ùöø` tiene la propiedad especial de que puede ser validada a trav√©s de una "
"prueba probabil√≠stica que lee solo una peque√±a parte de `ùöø`."
msgstr ""

#: src/Starks_Eficientes.md:6
msgid ""
"El verifier **PCP**, al recibir la misma declaraci√≥n de **CI** `(A, x, y, "
"T)`, puede validar la cadena de prueba `ùöø` leyendo aleatoriamente unas pocas "
"ubicaciones de `ùöø` y luego realizar una **\"verificaci√≥n local\"** econ√≥mica "
"en los valores le√≠dos. El n√∫mero de ubicaciones de lectura puede ser una "
"peque√±a constante, como 3, independientemente de la longitud de la traza de "
"c√°lculo `T`."
msgstr ""

#: src/Starks_Eficientes.md:8
msgid ""
"Si la declaraci√≥n de CI es verdadera, el verifier siempre aceptar√°. Sin "
"embargo, si la declaraci√≥n de CI es falsa, el verificador la rechazar√° con "
"alta probabilidad, sin importar c√≥mo se haya elegido la cadena de prueba `ùöø`."
msgstr ""

#: src/Starks_Eficientes.md:15
msgid ""
"En la imagen animada podemos ver un ejemplo de **PCP** con un conjunto de "
"resticciones un sudoku y ahora veremos como los STARKs eficiente pueden "
"mejorar la eficiencia de las **PCP** y **MPCP** con **IOPs**."
msgstr ""

#: src/Starks_Iops.md:1
msgid "# IOPs - Interactive Oracle Proof"
msgstr ""

#: src/Starks_Iops.md:2
msgid ""
"Las Interactive Orcale Proof [**(IOP)**](https://eprint.iacr.org/2016/116) "
"son un nuevo tipo de sistema de prueba que combina las propiedades clave de "
"**pruebas interactivas** y **PCP**, las **IOP** permiten que un verifier "
"est√© convencido de la exactitud de una declaraci√≥n al interactuar con un "
"prover no confiable mientras lee solo algunos bits de los mensajes enviados "
"por el prover. Las **IOP** se han vuelto muy prominentes en el dise√±o de "
"sistemas de prueba eficientes en los √∫ltimos a√±os."
msgstr ""

#: src/Starks_Iops.md:4
msgid ""
"> **Las construcciones STARK eficientes se obtienen combinando IOP "
"eficientes y funciones hash criptogr√°ficas. El IOP le confiere al STARK su "
"escalabilidad, mientras que la funci√≥n hash le confiere al STARK su "
"transparencia.**"
msgstr ""

#: src/Starks_Iops.md:6
msgid ""
"Las STARKs eficientes se basan en IOP, de manera informal, un prover y un "
"verifier participan en un protocolo interactivo en el que, en cada ronda, el "
"verifier env√≠a algo de aleatoriedad `ùõî·µ¢` al prover, y el prover responde con "
"una proof larga `ùöø·µ¢`. Al final de la interacci√≥n, el verificador realiza una "
"verificaci√≥n local aleatoria de todas las proof largas `(ùöø‚ÇÅ,ùöø‚ÇÇ,‚Ä¶)` enviadas "
"por el prover a lo largo de la interacci√≥n."
msgstr ""

#: src/Starks_Iops.md:8
msgid ""
"Ahora, antes de sumergirnos en el mundo de los pasos de creaci√≥n de un "
"STARKs y su eficiencia, es importante comprender qu√© es un polinomio, ya que "
"desempe√±an un papel crucial en la construcci√≥n y verificaci√≥n de STARKs. Son "
"utilizados para representar y manipular datos de manera eficiente, lo que "
"permite lograr un alto nivel de compresi√≥n y optimizaci√≥n en el proceso de "
"verificaci√≥n."
msgstr ""

#: src/Starks_Polinomios.md:1
msgid "## Polinomios"
msgstr ""

#: src/Starks_Polinomios.md:2
msgid ""
"Los polinomios son una poderosa herramienta algebraica que se utiliza en "
"diversas ramas de las matem√°ticas y la f√≠sica. Estas expresiones algebraicas "
"est√°n formadas por t√©rminos que contienen variables y coeficientes. Los "
"t√©rminos son la suma o resta de monomios, que son productos de constantes y "
"variables elevadas a exponentes enteros no negativos."
msgstr ""

#: src/Starks_Polinomios.md:4
msgid ""
"Un polinomio puede tener una o varias variables, y su grado est√° determinado "
"por el exponente m√°s alto presente en los t√©rminos del polinomio. Por "
"ejemplo, el polinomio `3x¬≤ - 2x + 1`  es un polinomio de grado 2, ya que el "
"t√©rmino de mayor grado tiene un exponente de 2."
msgstr ""

#: src/Starks_Polinomios.md:6
msgid ""
"Los polinomios se pueden sumar, restar, multiplicar y dividir, y se emplean "
"en ecuaciones algebraicas, c√°lculo, geometr√≠a y muchas otras ramas de las "
"ciencias exactas."
msgstr ""

#: src/Starks_Polinomios.md:8
msgid "**¬øPor qu√© no eval√∫a el verifier los propios polinomios?**"
msgstr ""

#: src/Starks_Polinomios.md:10
msgid ""
"* Prque, en realidad, el prover no env√≠a todos los polinomios al "
"verificador, si lo hiciera perder√≠amos sucintez, contienen m√°s informaci√≥n "
"que nuestra declaraci√≥n original, por lo que el prover s√≥lo proporciona un "
"compromiso con los polinomios."
msgstr ""

#: src/Starks_Polinomios.md:12
msgid "**¬øQu√© propiedades de los polinomios son importantes en este caso?**"
msgstr ""

#: src/Starks_Polinomios.md:14
msgid "* Los polinomios son buenos c√≥digos de correcci√≥n de errores."
msgstr ""

#: src/Starks_Polinomios.md:16
msgid ""
"Si tenemos polinomios de grado `d` sobre un dominio de codificaci√≥n `D`, y "
"dos mensajes `m‚ÇÅ` y `m‚ÇÇ`, entonces  `m‚ÇÅ` y `m‚ÇÇ` diferir√°n en `|D|-d` puntos. "
"Esto es importante porque queremos que la diferencia entre una declaraci√≥n "
"correcta y una incorrecta sea grande, de modo que sea f√°cil de encontrar."
msgstr ""

#: src/Starks_Polinomios.md:18
msgid ""
"Esto conduce a un buen muestreo, lo que ayuda a la sucintez, s√≥lo "
"necesitamos muestrear unos pocos valores para estar seguros de que la "
"probabilidad de error es lo suficientemente baja como para ser "
"insignificante."
msgstr ""

#: src/Starks_Polinomios.md:20
msgid "* Disponer de pruebas eficaces de lote cero mantiene la sucintez."
msgstr ""

#: src/Starks_Polinomios.md:22
msgid ""
"Tener la capacidad de realizar pruebas de lote cero eficaces es fundamental. "
"Esto nos permite demostrar de manera conjunta que un conjunto de elementos "
"cumple con una determinada propiedad, en lugar de tener que probar cada "
"elemento de forma individual, esta t√©cnica de prueba en lote nos permite "
"lograr una mayor concisi√≥n y eficiencia en la verificaci√≥n."
msgstr ""

#: src/Starks_Polinomios.md:24
msgid ""
"Imaginemos que queremos demostrar que un polinomio de grado grande `P(x) "
"(grado ~ 10 millones)` eval√∫a a `0` en los puntos `1...1 mill√≥n`, pero "
"queremos hacerlo con una sola consulta."
msgstr ""

#: src/Starks_Polinomios.md:26
msgid ""
"Imaginemos que nuestra afirmaci√≥n es que `P` desaparece en estos puntos. Si "
"el verifier s√≥lo utiliza el muestreo, el prover podr√≠a hacer trampas "
"f√°cilmente proporcionando un punto que se eval√∫e como `0`, pero los otros "
"`999.999` podr√≠an ser distintos de `0`."
msgstr ""

#: src/Starks_Polinomios.md:28
msgid "## Resolviendo el problema"
msgstr ""

#: src/Starks_Polinomios.md:30
msgid "Consideremos un conjunto `S = 1...10‚Å∂`"
msgstr ""

#: src/Starks_Polinomios.md:32
msgid ""
"Definir `V` como el polinomio que se anula en estos puntos, es decir: `(x - "
"1)(x - 2)(x - 3)...` el grado de `V = tama√±o de S` y esto es beneficioso "
"porque:"
msgstr ""

#: src/Starks_Polinomios.md:34
msgid "1. `P(x) = P'(x) ‚Ä¢ V(x)`\n2. `Grado de P = Grado de P' - Tama√±o de S.`"
msgstr ""

#: src/Starks_Polinomios.md:37
msgid "La introducci√≥n de `V(x)` nos permite verificar en todo el dominio."
msgstr ""

#: src/Starks_Polinomios.md:39
msgid ""
"* Estos polinomios tienen una propiedad **\"multiplicadora\"**. Podemos "
"**\"envolver\"** una restricci√≥n alrededor de un polinomio."
msgstr ""

#: src/Starks_Polinomios.md:41
msgid ""
"Por ejemplo, si tenemos la restricci√≥n **C**, que indica que nuestra "
"evaluaci√≥n siempre ser√° 0 o 1, podr√≠amos expresarla como `C(x) = x ‚Ä¢ (x - "
"1)`. Esto se podr√≠a interpretar como restringir una salida para que sea un "
"booleano, lo cual es √∫til en t√©rminos de integridad computacional."
msgstr ""

#: src/Starks_Polinomios.md:43
msgid ""
"En lugar de tener `x` como un simple punto, podr√≠amos considerar la "
"evaluaci√≥n de un  de un polinomio `P‚ÇÅ(x)` en un punto espec√≠fico, es decir, "
"`C(P‚ÇÅ(x)) = P‚ÇÅ(x)‚Ä¢(P‚ÇÅ(x)-1)`"
msgstr ""

#: src/Starks_Polinomios.md:45
msgid ""
"Los grados de los polinomios resultantes de la multiplicaci√≥n son aditivos, "
"por lo que el grado de `C(x) = 2 ‚Ä¢ grado de P‚ÇÅ(x)`"
msgstr ""

#: src/Starks_Polinomios.md:47
msgid ""
"Podemos afirmar que si `P‚ÇÅ(x)` cumple con esta restricci√≥n para nuestro "
"conjunto `S`, entonces, como mencionamos anteriormente, existe un polinomio "
"`P'(x)` tal que:"
msgstr ""

#: src/Starks_Polinomios.md:49
msgid "* `C(P‚ÇÅ(x)) = P'(x) ‚Ä¢ V(x)`"
msgstr ""

#: src/Starks_Polinomios.md:51
msgid ""
"Si `P‚ÇÅ(x)` no cumpliera con la restricci√≥n (por ejemplo, si para un valor de "
"`x, P‚ÇÅ(x) = 93`), entonces no podr√≠amos encontrar esos polinomios, la "
"igualdad no se cumplir√≠a y habr√≠a un residuo en la ecuaci√≥n anterior."
msgstr ""

#: src/Starks_Creacion.md:1
msgid "# Creando un STARK"
msgstr ""

#: src/Starks_Creacion.md:2
msgid ""
"En esta parte final del documento y despu√©s de haber explicado algunas "
"propiedades  importantes de los polinomios y que resuelven, exploraremos la "
"creaci√≥n de una STARK desde los fundamentos matem√°ticos m√°s profundos. Para "
"obtener una comprensi√≥n completa de los procesos involucrados y c√≥mo se "
"puede combinar un PCP con criptograf√≠a ligera para obtener un STARK, te "
"recomendamos revisar la serie lanzada por Starkware,que proporciona una "
"profundizaci√≥n inicial m√°s detallada."
msgstr ""

#: src/Starks_Creacion.md:4
msgid ""
"Adem√°s, encontrar√°s a continuaci√≥n los enlaces a cinco art√≠culos "
"fundamentales  traducidos al espa√±ol que complementar√°n tu aprendizaje:"
msgstr ""

#: src/Starks_Creacion.md:6
msgid ""
"1. [Comienza el "
"Viaje](https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Comienza%20el%20viaje.md)\n"
"2. [Aritmetizaci√≥n "
"I](https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20I.md)\n"
"3. [Aritmetizaci√≥n "
"II](https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20II.md)\n"
"4. [Pruebas de Bajo "
"Grado](https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Prueba%20de%20bajo%20grado.md)\n"
"5. [Un Frameword para STARKs "
"Eficientes](https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Un%20marco%20para%20STARKs%20eficientes.md)"
msgstr ""

#: src/Starks_Creacion.md:12
msgid ""
"Estos recursos adicionales te brindar√°n una visi√≥n m√°s completa y pr√°ctica "
"del proceso de creaci√≥n de una STARK. Tambi√©n te recomendamos revisar los "
"repositorios relacionados y los videos de creaci√≥n de una STARK en Pioneros "
"Clases 3, un Basecamp descentralizado en Espa√±ol creado por Starknet, o el "
"den ingl√©s impartido por Eli Ben Saason"
msgstr ""

#: src/Starks_Creacion.md:14
msgid ""
"Nos interesa la Integridad Computacional (CI), por ejemplo, saber que el "
"programa de Cairo que escribiste se calcul√≥ correctamente."
msgstr ""

#: src/Starks_Creacion.md:16
msgid ""
"* Tenemos que pasar por una serie de transformaciones desde el trazado de "
"nuestro programa, hasta la prueba.\n"
"* La primera parte de esto se llama aritmetizaci√≥n, y consiste en tomar "
"nuestra traza y convertirla en un conjunto de polinomios.\n"
"* Nuestro problema se convierte entonces en uno en el que el prover intenta "
"convencer a un verificador de que el polinomio es de grado bajo.\n"
"* El verificador est√° convencido de que el polinomio es de grado bajo si y "
"s√≥lo si el c√°lculo original es correcto (salvo una probabilidad "
"infinitesimalmente peque√±a)."
msgstr ""

#: src/Starks_Creacion.md:26
msgid ""
"El uso de la aletoriedad es muy importante para el prover y el verifier, "
"mientras que el prover utiliza la aleatoriedad para alcanzar el conocimiento "
"cero, el verificador utiliza la aleatoriedad al generar consultas al prover, "
"para detectar trampas por parte del prover."
msgstr ""

#: src/Starks_Creacion.md:28
msgid ""
"Gran parte del trabajo que se realiza al crear una prueba consiste en "
"garantizar que sea sucinta y que pueda elaborarse y verificarse en un tiempo "
"razonable. Por tanto, nuestro plan consistir√° en:"
msgstr ""

#: src/Starks_Creacion.md:30
msgid ""
"* Reformular la traza de ejecuci√≥n como un polinomio,\n"
"* Extenderlo a un gran dominio,\n"
"* Transformarlo, utilizando las restricciones polin√≥micas, en otro polinomio "
"que se garantiza que es de grado bajo si y s√≥lo si la traza de ejecuci√≥n es "
"v√°lida.\n"
"* Queremos lograr una verificaci√≥n sucinta, en la que el verificador de la "
"declaraci√≥n CI requiera exponencialmente menos recursos que los necesarios "
"para la repetici√≥n ingenua."
msgstr ""

#: src/Starks_Aritmetizacion.md:1
msgid "# Aritmetizaci√≥n"
msgstr ""

#: src/Starks_Aritmetizacion.md:2
msgid "Tenemos dos pasos principales en este proceso:"
msgstr ""

#: src/Starks_Aritmetizacion.md:4
msgid ""
"1. Generaci√≥n de una traza de ejecuci√≥n y restricciones polin√≥micas.\n"
"2. Transformar estos dos objetos en un √∫nico polinomio de bajo grado."
msgstr ""

#: src/Starks_Aritmetizacion.md:7
msgid ""
"En t√©rminos de interacci√≥n prover-verifier, realmente lo que ocurre es que "
"entre ambos acuerdan de antemano cu√°les son las restricciones polin√≥micas."
msgstr ""

#: src/Starks_Aritmetizacion.md:9
msgid ""
"A continuaci√≥n, el prover genera una traza de ejecuci√≥n y, en la interacci√≥n "
"posterior, intenta convencer al verificador de que las restricciones "
"polin√≥micas se cumplen en esta traza de ejecuci√≥n, sin que el verificador lo "
"vea."
msgstr ""

#: src/Starks_Aritmetizacion.md:11
msgid ""
"La traza de ejecuci√≥n es una tabla que representa los pasos del c√°lculo "
"subyacente, donde cada fila representa un √∫nico paso y el tipo de traza de "
"ejecuci√≥n que buscamos generar debe tener la caracter√≠stica especial de ser "
"sucintamente comprobable:"
msgstr ""

#: src/Starks_Aritmetizacion.md:13
msgid ""
"* Cada fila puede ser verificada bas√°ndose s√≥lo en las filas que est√°n cerca "
"de ella en la traza, y el mismo procedimiento de verificaci√≥n se aplica a "
"cada par de filas."
msgstr ""

#: src/Starks_Aritmetizacion.md:15
msgid ""
"Por ejemplo, imaginemos que nuestra traza representa un total en ejecuci√≥n, "
"con cada paso de la siguiente manera."
msgstr ""

#: src/Starks_Aritmetizacion.md:17
msgid ""
"```bash\n"
"                    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n"
"                    ‚ïë  PASO  ‚ïë  IMPORTE  ‚ïë TOTAL ‚ïë\n"
"                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n"
"                    ‚ïë   0    ‚ïë     0     ‚ïë   0   ‚ïë\n"
"                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n"
"                    ‚ïë   1    ‚ïë     5     ‚ïë   5   ‚ïë\n"
"                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n"
"                    ‚ïë   2    ‚ïë     2     ‚ïë   7   ‚ïë\n"
"                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n"
"                    ‚ïë   3    ‚ïë     2     ‚ïë   9   ‚ïë\n"
"                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n"
"                    ‚ïë   4    ‚ïë     3     ‚ïë   12  ‚ïë\n"
"                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n"
"                    ‚ïë   5    ‚ïë     6     ‚ïë   18  ‚ïë\n"
"                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n"
"```"
msgstr ""

#: src/Starks_Aritmetizacion.md:35
msgid ""
"Si representamos la fila como `i` , y la columna como `j` , y los valores "
"como `A·µ¢,‚±º` , podr√≠amos escribir algunas restricciones sobre esto de la "
"siguiente manera:"
msgstr ""

#: src/Starks_Aritmetizacion.md:37
msgid ""
"* `A‚ÇÄ,‚ÇÇ=0`\n"
"* `‚àÄ1 >= i <= 5 : A·µ¢,‚ÇÇ ‚àí A·µ¢,‚ÇÅ ‚àí A·µ¢-‚ÇÅ,‚ÇÇ = 0`\n"
"* `A‚ÇÖ,‚ÇÇ = 18`"
msgstr ""

#: src/Starks_Aritmetizacion.md:41
msgid "Se trata de restricciones polin√≥micas lineales en `A·µ¢,‚±º`"
msgstr ""

#: src/Starks_Aritmetizacion.md:43
msgid ""
"N√≥tese que aqu√≠ estamos consiguiendo cierta concisi√≥n porque podr√≠amos "
"representar un n√∫mero mucho mayor de filas con s√≥lo estas 3 restricciones."
msgstr ""

#: src/Starks_Aritmetizacion.md:45
msgid ""
"El sistema de restricciones aritm√©ticas define al menos dos tipos de "
"restricciones sobre la traza de ejecuci√≥n algebraica:"
msgstr ""

#: src/Starks_Aritmetizacion.md:47
msgid ""
"1. **Restricciones de contorno:** al principio o al final del c√°lculo, un "
"registro indicado tiene un valor determinado.\n"
"2. **Restricciones de transici√≥n:** dos tuplas de estado consecutivas "
"cualesquiera evolucionan de acuerdo con la funci√≥n de transici√≥n de estado. "
"En conjunto, estas restricciones se conocen como representaci√≥n algebraica "
"intermedia o AIR."
msgstr ""

#: src/Starks_Aritmetizacion.md:50
msgid ""
"Las STARKs avanzadas pueden definir m√°s tipos de restricciones para tratar "
"con la memoria o con la consistencia de los registros dentro de un ciclo."
msgstr ""

#: src/Starks_Traza.md:1
msgid "# Polinomio para nuestra traza"
msgstr ""

#: src/Starks_Traza.md:2
msgid ""
"Tambi√©n en este caso definimos un polinomio `f(x)` tal que los elementos de "
"la traza de ejecuci√≥n son evaluaciones de `f` en potencias de alg√∫n "
"generador `g`."
msgstr ""

#: src/Starks_Traza.md:4
msgid ""
"Recordemos que nuestro campo finito tendr√° generadores, que utilizaremos "
"para indexar los pasos de nuestra traza. Tomando una secuencia de Fibonacci "
"podemos crear restricciones como:"
msgstr ""

#: src/Starks_Traza.md:6
msgid "* `‚àÄ x ‚àà {1,g¬≤,g¬≥...g‚Åµ‚Å∞‚Åπ}: f(g¬≤x) ‚Çã f(gx) ‚Çã f(x) = 0`"
msgstr ""

#: src/Starks_Traza.md:8
msgid ""
"Esto restringe los valores entre las filas subsiguientes. Tambi√©n significa "
"que los valores g son ra√≠ces de este polinomio."
msgstr ""

#: src/Starks_Traza.md:10
msgid ""
"Por lo tanto, podemos utilizar el enfoque que vimos anteriormente para "
"proporcionar el polinomio de fuga utilizando el t√©rmino `(x - g‚Å±)` y a "
"partir de √©l creamos el polinomio de composici√≥n."
msgstr ""

#: src/Starks_Traza.md:12
msgid ""
"El hecho b√°sico sobre polinomios y sus ra√≠ces es que si `p(x)` es un "
"polinomio, entonces `p(a)=0` para alg√∫n valor espec√≠fico a, si y s√≥lo si "
"existe un polinomio `q(x)` tal que `(x-a)q(x)=p(x)`, y `deg(p)=deg(q)+1.`"
msgstr ""

#: src/Starks_Traza.md:14
msgid ""
"Esta expresi√≥n coincide con el polinomio de grado 2 como m√°ximo si nuestra "
"traza de ejecuci√≥n ha sido correcta, es decir, ha obedecido a la restricci√≥n "
"de paso que hemos definido."
msgstr ""

#: src/Starks_Traza.md:16
msgid ""
"Si la traza difiere de eso, entonces es poco probable que esta expresi√≥n "
"produzca un polinomio de bajo grado."
msgstr ""

#: src/Starks_Traza.md:18
msgid "# Composici√≥n Polinomial"
msgstr ""

#: src/Starks_Traza.md:19
msgid ""
"El Polinomio de Composici√≥n en su traducci√≥n tambi√©n conocido como "
"Composici√≥n Polinomial (CP), se realiza para demostrar eficazmente la "
"validez del rastro de ejecuci√≥n, nos esforzamos por alcanzar los dos "
"objetivos siguientes:"
msgstr ""

#: src/Starks_Traza.md:21
msgid ""
"1. Componer las restricciones sobre los polinomios de la traza para hacerlas "
"cumplir en la traza.\n"
"2. Combinar las restricciones en un √∫nico polinomio (m√°s grande), denominado "
"Composici√≥n Polinomial, de modo que se pueda utilizar una √∫nica prueba de "
"grado bajo para atestiguar su grado bajo."
msgstr ""

#: src/Starks_Traza.md:24
msgid "# Ampliando el polinomio"
msgstr ""

#: src/Starks_Traza.md:25
msgid ""
"Como hemos visto antes, los polinomios pueden utilizarse para construir "
"buenos c√≥digos de correcci√≥n de errores, ya que dos polinomios de grado d, "
"evaluados en un dominio considerablemente mayor que d, son diferentes en "
"casi todas partes."
msgstr ""

#: src/Starks_Traza.md:27
msgid ""
"Observando esto, podemos extender la traza de ejecuci√≥n pensando en ella "
"como una evaluaci√≥n de un polinomio en alg√∫n dominio, y evaluando este mismo "
"polinomio en un dominio mucho mayor. Extendiendo de manera similar una traza "
"de ejecuci√≥n incorrecta, se obtiene una cadena muy diferente, lo que a su "
"vez hace posible que el verificador distinga entre estos casos utilizando un "
"peque√±o n√∫mero de consultas."
msgstr ""

#: src/Starks_Traza.md:29
msgid "## De restricciones polin√≥micas al problema de las pruebas de bajo grado"
msgstr ""

#: src/Starks_Traza.md:30
msgid ""
"En general, si nuestro c√°lculo implica `N` pasos, la traza de ejecuci√≥n "
"estar√° representada por polinomios de grado inferior a `N`"
msgstr ""

#: src/Starks_Traza.md:32
msgid "* `f(X) = c‚ÇÄ + c‚ÇÅX + c‚ÇÇX¬≤ +‚ãØ+ c…¥-‚ÇÅX·¥∫‚Åª¬π`"
msgstr ""

#: src/Starks_Traza.md:34
msgid ""
"Los coeficientes `c·µ¢` est√°n en el campo `ùîΩ` y el l√≠mite `N` en el grado es "
"t√≠picamente grande, quiz√° del orden de unos pocos millones. A pesar de ello, "
"estos polinomios se denominan de bajo grado."
msgstr ""

#: src/Starks_Traza.md:36
msgid ""
"Esto se debe a que el punto de comparaci√≥n es el tama√±o del campo. Por "
"interpolaci√≥n, toda funci√≥n sobre `ùîΩ` puede representarse mediante un "
"polinomio."
msgstr ""

#: src/Starks_Traza.md:38
msgid ""
"La mayor√≠a de ellos tendr√°n un grado igual al tama√±o total del campo, por lo "
"que, comparado con √©ste, `N` es realmente bajo."
msgstr ""

#: src/Starks_Traza.md:40
msgid ""
"Este tipo de funciones, coherentes con un polinomio de bajo grado, tambi√©n "
"se conocen como c√≥digos `Reed-Solomon`."
msgstr ""

#: src/Starks_Traza.md:42
msgid ""
"Tras la generaci√≥n de la traza, el prover se compromete con ella. Recordemos "
"que no queremos enviar los polinomios al verificador como un todo, pero "
"necesitamos que el prover se comprometa con ellos."
msgstr ""

#: src/Starks_Traza.md:44
msgid ""
"En todo el sistema, los compromisos se ejecutan construyendo √°rboles de "
"Merkle sobre las series de elementos de campo y enviando las ra√≠ces de "
"Merkle al verificador."
msgstr ""

#: src/Starks_Traza.md:46
msgid ""
"Queremos que un verificador plantee al prover un n√∫mero muy reducido de "
"preguntas y decida si acepta o rechaza la prueba con un alto nivel de "
"precisi√≥n garantizado. Idealmente, al verificador le gustar√≠a pedir al "
"prover que proporcione los valores en unos pocos lugares (aleatorios) en la "
"traza de ejecuci√≥n, y comprobar que las restricciones polin√≥micas se "
"mantienen para estos lugares."
msgstr ""

#: src/Starks_Traza.md:48
msgid "Una traza de ejecuci√≥n correcta pasar√° naturalmente esta prueba."
msgstr ""

#: src/Starks_Traza.md:50
msgid ""
"Sin embargo, no es dif√≠cil construir una traza de ejecuci√≥n completamente "
"err√≥nea (especialmente si sab√≠amos de antemano qu√© puntos se comprobar√≠an), "
"que viole las restricciones s√≥lo en un punto de la traza √∫nico y, al "
"hacerlo, llegar a un resultado completamente alejado y diferente. "
"Identificar este fallo mediante un peque√±o n√∫mero de consultas aleatorias es "
"altamente improbable."
msgstr ""

#: src/Starks_Traza.md:52
msgid "Pero recuerda que los polinomios tienen algunas propiedades √∫tiles aqu√≠:"
msgstr ""

#: src/Starks_Traza.md:54
msgid ""
"* Dos polinomios (diferentes) de grado `d` evaluados en un dominio "
"considerablemente mayor que `d` son diferentes en casi todas partes."
msgstr ""

#: src/Starks_Traza.md:56
msgid ""
"As√≠ que si tenemos un prover deshonesto, que crea un polinomio de bajo grado "
"representando su traza (que es incorrecta en alg√∫n punto) y lo eval√∫a en un "
"dominio grande, ser√° f√°cil ver que este es diferente al polinomio correcto."
msgstr ""

#: src/Starks_Bajo.md:1
msgid "# Pruebas de Bajo Grado"
msgstr ""

#: src/Starks_Bajo.md:2
msgid ""
"Las pruebas de bajo grado son realmente el coraz√≥n del proceso de "
"verificaci√≥n."
msgstr ""

#: src/Starks_Bajo.md:4
msgid ""
"El supuesto de comprobaci√≥n de bajo grado establece la existencia de un "
"verificador probabil√≠stico que comprueba si una funci√≥n f es de grado como "
"m√°ximo d ‚â™ |ùîΩ|. El verificador debe distinguir entre los dos casos "
"siguientes:"
msgstr ""

#: src/Starks_Bajo.md:6
msgid ""
"1. **La funci√≥n `f` es igual a un polinomio de bajo grado:** es decir, "
"existe un polinomio `p(x)` sobre `ùîΩ`, de grado menor que `d`, que coincide "
"con `f` en todas partes.\n"
"2. **La funci√≥n `f` est√° lejos de TODOS los polinomios de bajo grado:** por "
"ejemplo, necesitamos modificar al menos el **10%** de los valores de `f` "
"antes de obtener una funci√≥n que concuerde con un polinomio de grado "
"inferior a `d`."
msgstr ""

#: src/Starks_Bajo.md:9
msgid ""
"La aritmetizaci√≥n muestra que un prover honesto que trate con una afirmaci√≥n "
"verdadera caer√° en el primer caso, mientras que un prover (posiblemente "
"malicioso) que intente **\"probar\"** una afirmaci√≥n falsa caer√°, con alta "
"probabilidad, en el segundo caso."
msgstr ""

#: src/Starks_Bajo.md:11
msgid ""
"Otra forma de ver esto es que el polinomio de traza correcto combinado con "
"las restricciones ser√° necesariamente de grado bajo, el grado proviene del "
"n√∫mero de pasos en nuestra traza (probablemente unos pocos millones), y la "
"combinaci√≥n de esto con los polinomios de restricci√≥n (probablemente < 10)."
msgstr ""

#: src/Starks_Bajo.md:13
msgid ""
"En general, cabr√≠a esperar que los polinomios **\"correctos\"** tuvieran un "
"grado de alrededor de `10‚Å∑` , mientras que un prover tramposo que eligiera "
"puntos al azar del campo `ùîΩ` obtendr√≠a, tras la interpolaci√≥n, polinomios de "
"grado comparable al tama√±o del campo, es decir, del orden de `2¬≤‚Åµ‚Å∂`"
msgstr ""

#: src/Starks_Fri.md:1
msgid "# FRI"
msgstr ""

#: src/Starks_Fri.md:2
msgid ""
"FRI son las siglas de [Fast Reed-Solomon IOP of "
"Proximity](https://eccc.weizmann.ac.il/report/2017/134/), es un protocolo "
"que establece que un polinomio comprometido tiene un grado limitado."
msgstr ""

#: src/Starks_Fri.md:4
msgid ""
"El [**FRI**](https://book.starknet.io/chapter_10/fri.html) es complejo y "
"gran parte del procesamiento que lo compone est√° dise√±ado para que las "
"pruebas sean factibles y sucintas. Tambi√©n hay mucho procesamiento "
"involucrado con la protecci√≥n contra diversos tipos de ataques que podr√≠an "
"ser realizados por el prover, y garantizar que todo se lleva a cabo en el "
"conocimiento cero."
msgstr ""

#: src/Starks_Fri.md:6
msgid ""
"Su objetivo es encontrar si un conjunto de puntos se encuentran "
"mayoritariamente en un polinomio de bajo grado y puede alcanzar una "
"complejidad de prueba lineal y una complejidad de verificaci√≥n logar√≠tmica."
msgstr ""

#: src/Starks_Fri.md:8
msgid ""
"En general, hay 2 etapas : commit y query, contenidas en los siguientes "
"pasos repetidos."
msgstr ""

#: src/Starks_Fri.md:10
msgid ""
"1. El verifier env√≠a un n√∫mero aleatorio al prover.\n"
"2. El prover genera un nuevo polinomio.\n"
"3. El verifier genera los conjuntos puntuales de consultas y los env√≠a al "
"prover.\n"
"4. El prover eval√∫a los valores polin√≥micos correspondientes.\n"
"5. El verifier realiza una comprobaci√≥n de validez."
msgstr ""

#: src/Starks_Fri.md:16
msgid ""
"Aprendamos como FRI es un protocolo entre un probador y un verificador, que "
"establece que una codeword dada pertenece a un polinomio de grado bajo."
msgstr ""

#: src/Starks_Fri.md:18
msgid ""
"El prover conoce expl√≠citamente este codeword, mientras que el verificador "
"s√≥lo conoce su ra√≠z Merkle y las hojas de su elecci√≥n, suponiendo la "
"validaci√≥n satisfactoria de las rutas de autenticaci√≥n que establecen la "
"pertenencia de las hojas al Merkle Tree."
msgstr ""

#: src/Starks_Fri.md:20
msgid ""
"Una de las grandes ideas para los sistemas de pruebas de los √∫ltimos a√±os ha "
"sido la t√©cnica de dividir y doblar. La idea es reducir una afirmaci√≥n a dos "
"afirmaciones de la mitad de tama√±o. A continuaci√≥n, ambas afirmaciones se "
"fusionan en una sola utilizando pesos aleatorios proporcionados por el "
"verificador."
msgstr ""

#: src/Starks_Fri.md:22
msgid ""
"Despu√©s de muchos pasos, la afirmaci√≥n se ha reducido a una de tama√±o "
"trivial que es verdadera si y s√≥lo si (modulo alguna degradaci√≥n de "
"seguridad insignificante) la afirmaci√≥n original era verdadera."
msgstr ""

#: src/Starks_Fri.md:24
msgid ""
"El verfier inspecciona los Merkle Tree (en concreto: pide al prover que "
"proporcione las hojas indicadas con sus rutas de autenticaci√≥n) de rondas "
"consecutivas para comprobar una relaci√≥n lineal simple."
msgstr ""

#: src/Starks_Fri.md:26
msgid ""
"Para los provers honestos, el grado de los polinomios representados tambi√©n "
"se reduce a la mitad en cada ronda y, por tanto, es mucho menor que la "
"longitud de la codeword. Sin embargo, para los provers maliciosos, este "
"grado es uno menos que la longitud de la codeword. En el √∫ltimo paso, el "
"prover env√≠a una codeword no trivial correspondiente a un polinomio "
"constante."
msgstr ""

#: src/Starks_Fri.md:28
msgid ""
"Despu√©s de explorar los diferentes pasos en la creaci√≥n detr√°s de un STARKs "
"y la importancia de las pruebas de integridad, es evidente que estas pruebas "
"son fundamentales para garantizar la seguridad y confiabilidad de los "
"sistemas del Futuro."
msgstr ""

#: src/Cairo.md:1
msgid "# Leve introducci√≥n Cairo"
msgstr ""

#: src/Cairo.md:2
msgid ""
"Como √∫ltimo apartado para finalizar este documento, antes de adentrarnos en "
"los pr√≥ximos temas sobre la arquitectura de Starknet y Cairo, haremos una "
"breve introducci√≥n a Cairo y su relaci√≥n con la CVM. En este contexto, es "
"relevante comprender c√≥mo todos los pasos de un c√°lculo pueden ser "
"representados mediante polinomios, utilizando lo que se conoce como la "
"Representaci√≥n Algebraica Intermedia (AIR)."
msgstr ""

#: src/Cairo.md:4
msgid ""
"Los bloques de c√°lculo pueden ser representados como AIR y tienen la "
"capacidad de combinarse entre s√≠, lo que se convierte en la base de Cairo. "
"Para ilustrarlo mediante una analog√≠a con el hardware:"
msgstr ""

#: src/Cairo.md:6
msgid "* **ASIC (AIR)**\n* **CPU (varias AIR)**"
msgstr ""

#: src/Cairo.md:9
msgid "El nombre **Cairo** deriva de una CPU construida a partir de AIRs:"
msgstr ""

#: src/Cairo.md:11
msgid "* **(CPU-AIR, Oh genial -> CAIRO)**"
msgstr ""

#: src/Cairo.md:13
msgid ""
"Cairo es un lenguaje funcional de alto nivel, no determinista y Turing "
"completo, que cuenta con un modelo de memoria basado en registros y un "
"compilador, el cual  produce una tabla de pasos computacionales llamada "
"traza."
msgstr ""

#: src/Cairo.md:15
msgid ""
"> En los programas escritos en Cairo, se especifican los resultados que se "
"consideran aceptables, no c√≥mo obtenerlos."
msgstr ""

#: src/Cairo.md:17
msgid ""
"Vimos como en el proceso de construcci√≥n de pruebas STARK, el prover utiliza "
"esta traza para crear Representaciones Algebraicas Intermedias (AIRs), que "
"luego se combinan y se convierten en pruebas STARK."
msgstr ""

#: src/Conclusi√≥n.md:1
msgid "# Conclusi√≥n"
msgstr ""

#: src/Conclusi√≥n.md:2
msgid ""
"Con esto, concluimos nuestro profundo viaje por el mundo de la criptograf√≠a, "
"explorando la generaci√≥n de claves privadas y p√∫blicas, as√≠ como sus "
"diversas implementaciones. Hemos aprendido c√≥mo Starknet y los esquemas de "
"firmas pueden prevenir ataques criptoanal√≠ticos, y hemos visto c√≥mo las "
"STARKs han sido dise√±adas desde su inicio para brindar seguridad matem√°tica "
"frente a ataques cu√°nticos, siguiendo sus principios fundamentales."
msgstr ""

#: src/Conclusi√≥n.md:4
msgid ""
"Starknet est√° sentando las bases de la criptograf√≠a moderna y creando un "
"ecosistema escalable, integro y seguro por una de las mayores "
"descentralizada como Ethereum, escalemos juntos."
msgstr ""

#: src/Otras_Arquitecturas.md:1
msgid "# Otras Arquitecturas"
msgstr ""

