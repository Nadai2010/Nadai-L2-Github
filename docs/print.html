<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>L2 Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="Introducci√≥n.html"><strong aria-hidden="true">1.</strong> Introducci√≥n</a></li><li class="chapter-item "><a href="Bases_Criptogr√°ficas.html"><strong aria-hidden="true">2.</strong> Bases Criptogr√°ficas</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Criptograf√≠a_Sim√©trica.html"><strong aria-hidden="true">2.1.</strong> Criptograf√≠a Sim√©trica</a></li><li class="chapter-item "><a href="Criptograf√≠a_Asim√©trica.html"><strong aria-hidden="true">2.2.</strong> Criptograf√≠a Asim√©trica</a></li><li class="chapter-item "><a href="Criptograf√≠a_H√≠bridas.html"><strong aria-hidden="true">2.3.</strong> Criptograf√≠a H√≠bridas</a></li><li class="chapter-item "><a href="Firmas_Digitales.html"><strong aria-hidden="true">2.4.</strong> Firmas Digitales</a></li><li class="chapter-item "><a href="Generador_de_Claves.html"><strong aria-hidden="true">2.5.</strong> Generador de Claves</a></li><li class="chapter-item "><a href="Funciones_Hash.html"><strong aria-hidden="true">2.6.</strong> Funciones Hash</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Merkle_Tree_en_Blockchain.html"><strong aria-hidden="true">2.6.1.</strong> Merkle Tree en Blockchain</a></li><li class="chapter-item "><a href="Patricia_Merkle_Trie.html"><strong aria-hidden="true">2.6.2.</strong> Patricia Merkle Trie</a></li><li class="chapter-item "><a href="Sha256.html"><strong aria-hidden="true">2.6.3.</strong> SHA-256</a></li><li class="chapter-item "><a href="Keccak.html"><strong aria-hidden="true">2.6.4.</strong> Keccak - El nuevo SHA-3</a></li></ol></li><li class="chapter-item "><a href="Quantum_Secure.html"><strong aria-hidden="true">2.7.</strong> Quantum Secure</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Grover.html"><strong aria-hidden="true">2.7.1.</strong> Grover</a></li><li class="chapter-item "><a href="Shor.html"><strong aria-hidden="true">2.7.2.</strong> Shor</a></li><li class="chapter-item "><a href="Lattice.html"><strong aria-hidden="true">2.7.3.</strong> Lattice</a></li><li class="chapter-item "><a href="Kyber_Crystal.html"><strong aria-hidden="true">2.7.4.</strong> Kyber Crystal</a></li><li class="chapter-item "><a href="EOA_AA.html"><strong aria-hidden="true">2.7.5.</strong> EOA y AA - Firmantes</a></li></ol></li><li class="chapter-item "><a href="Starknet_AA.html"><strong aria-hidden="true">2.8.</strong> Starknet AA</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Stark_Curve.html"><strong aria-hidden="true">2.8.1.</strong> EC en Cairo - STARK Curve</a></li><li class="chapter-item "><a href="Secp256r1.html"><strong aria-hidden="true">2.8.2.</strong> MyBraavos Secp256r1</a></li><li class="chapter-item "><a href="Stark_Key.html"><strong aria-hidden="true">2.8.3.</strong> Creaci√≥n de una Stark Key en StarkEx</a></li></ol></li><li class="chapter-item "><a href="Starknet_funciones_hash.html"><strong aria-hidden="true">2.9.</strong> Starknet y Funciones Hash</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Keccak_Starknet.html"><strong aria-hidden="true">2.9.1.</strong> Hash Keccak</a></li><li class="chapter-item "><a href="Pedersen_Starknet.html"><strong aria-hidden="true">2.9.2.</strong> Hash Pedersen</a></li><li class="chapter-item "><a href="Poseidon_Starknet.html"><strong aria-hidden="true">2.9.3.</strong> Hash Poseidon</a></li><li class="chapter-item "><a href="Hashing_Array.html"><strong aria-hidden="true">2.9.4.</strong> Hashing de Array</a></li></ol></li><li class="chapter-item "><a href="Starks.html"><strong aria-hidden="true">2.10.</strong> S-T-ARKs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starks_Propiedades.html"><strong aria-hidden="true">2.10.1.</strong> Propiedades de las STARKs</a></li><li class="chapter-item "><a href="Starks_Eficientes.html"><strong aria-hidden="true">2.10.2.</strong> STARKs eficientes</a></li><li class="chapter-item "><a href="Starks_Iops.html"><strong aria-hidden="true">2.10.3.</strong> IOPs</a></li><li class="chapter-item "><a href="Starks_Polinomios.html"><strong aria-hidden="true">2.10.4.</strong> Polinomios</a></li></ol></li><li class="chapter-item "><a href="Starks_Creacion.html"><strong aria-hidden="true">2.11.</strong> Creaci√≥n de un STARK</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starks_Aritmetizacion.html"><strong aria-hidden="true">2.11.1.</strong> Aritmetizaci√≥n</a></li><li class="chapter-item "><a href="Starks_Traza.html"><strong aria-hidden="true">2.11.2.</strong> Polinomio y Composici√≥n para nuestra Traza</a></li><li class="chapter-item "><a href="Starks_Bajo.html"><strong aria-hidden="true">2.11.3.</strong> Pruebas de Bajo Grado</a></li><li class="chapter-item "><a href="Starks_Fri.html"><strong aria-hidden="true">2.11.4.</strong> FRI</a></li></ol></li><li class="chapter-item "><a href="Cairo.html"><strong aria-hidden="true">2.12.</strong> Leve introducci√≥n a Cairo (AIR)</a></li><li class="chapter-item "><a href="Conclusi√≥n.html"><strong aria-hidden="true">2.13.</strong> Conclusiones</a></li></ol></li><li class="chapter-item "><a href="Arquitectura_Starkware.html"><strong aria-hidden="true">3.</strong> Arquitectura Starkware</a></li><li class="chapter-item "><a href="Otras_Arquitecturas.html"><strong aria-hidden="true">4.</strong> Otras Arquitecturas</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">L2 Book</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                <a id="en">English</a>
                            </button></li>
                            <li role="none"><button role="menuitem" class="theme">
                                <a id="es">Espa√±ol</a>
                            </button></li>
                            <li role="none"><button role="menuitem" class="theme">
                                <a id="fr">Fran√ßais</a>
                            </button></li>
                            <li role="none"><button role="menuitem" class="theme">
                                <a id="zh-cn">ÁÆÄ‰Ωì‰∏≠Êñá</a>
                            </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("es");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            let full_path_to_root = "../";
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "print.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introducci√≥n"><a class="header" href="#introducci√≥n">Introducci√≥n</a></h1>
<p>¬°Hola comunidad! üëã</p>
<p>Antes que nada nos gustar√≠a expresar nuestro m√°s sincero agradecimiento a todos aquellos que han contribuido y hecho posible la realizaci√≥n de esta exhaustiva investigaci√≥n y documento sobre criptograf√≠a y como se adaptan en StarkWare. Especial reconocimiento a los expertos @X, @Y, @Z y @A, quienes han brindado sus valiosas correcciones y orientaci√≥n en numerosos aspectos del trabajo. Su experiencia y conocimientos han sido fundamentales para alcanzar los resultados y conclusiones presentados en este informe.</p>
<p>En esta ocasi√≥n, estamos emocionados de presentar una serie de art√≠culos profundos sobre el desarrollo detr√°s de Starkware. Recomendamos a los lectores que previamente hayan le√≠do otros documentos y tengan conocimientos t√©cnicos para una mejor comprensi√≥n, para este documento en concreto recomendamos:</p>
<p><a href="https://starkware.co/resource/stark-endgame/">Stark END-Game</a> | <a href="https://starkware.co/resource/stark-endgame/">Recursive Stark</a> |  <a href="https://starkware.co/resource/account-abstraction-improving-security-and-user-experience-for-mainstream-crypto-adoption/">Account Abstraction</a> | <a href="https://starkware.co/stark-math-a-very-short-primer/">Intro Maths Starks</a></p>
<p>El panorama actual es complejo, pero nos enorgullece contar con las mentes m√°s brillantes trabajando en el ecosistema, una STARK que los une a todos.</p>
<p>¬øEres o ser√°s uno de ellos? Antes de sumergirnos, exploraremos una serie de conceptos para establecer bases e historias sobre criptograf√≠a, lo que nos permitir√° adentrarnos a√∫n m√°s en el ecosistema STARKs. ¬°Comencemos!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bases-criptogr√°ficas"><a class="header" href="#bases-criptogr√°ficas">Bases Criptogr√°ficas</a></h1>
<p>La <a href="https://en.wikipedia.org/wiki/Cryptography"><strong>criptograf√≠a</strong></a> es el campo de estudio y desarrollo de t√©cnicas y algoritmos para asegurar la confidencialidad, integridad y autenticidad de la informaci√≥n. Utilizando claves secretas o p√∫blicas, <strong>la criptograf√≠a transforma los datos en un formato incomprensible para terceros no autorizados</strong>, garantizando que solo los destinatarios leg√≠timos puedan acceder a la informaci√≥n original. La criptograf√≠a desempe√±a un papel vital en la seguridad de las comunicaciones y el almacenamiento de datos, protegiendo la privacidad y la confianza en diversos √°mbitos de la vida moderna.</p>
<ul>
<li>
<p><strong>Encryption:</strong> <a href="https://en.wikipedia.org/wiki/Encryption">el cifrado</a> es el proceso de convertir informaci√≥n legible en un formato ilegible llamado texto cifrado, mediante el uso de algoritmos y una clave. El objetivo principal del cifrado es proteger la confidencialidad de los datos, asegurando que solo las personas autorizadas puedan acceder y comprender la informaci√≥n cifrada. Para ello, se aplica una serie de transformaciones matem√°ticas al texto original, lo que dificulta su interpretaci√≥n sin la clave correspondiente.</p>
</li>
<li>
<p><strong>Cryptographic protocol:</strong> <a href="https://en.wikipedia.org/wiki/Cryptographic_protocol">un protocolo criptogr√°fico</a> o protocolo de seguridad (tambi√©n llamado protocolo de cifrado) es un protocolo abstracto o concreto que realiza funciones relacionadas con la seguridad, aplicando m√©todos criptogr√°ficos.‚Äã Un protocolo describe la forma en que un algoritmo debe usarse.</p>
</li>
<li>
<p><strong>Algorithm:</strong> <a href="https://es.wikipedia.org/wiki/Algoritmo">un algoritmo</a> de cifrado es un procedimiento que convierte un mensaje de texto plano en un texto cifrado. Los algoritmos modernos utilizan matem√°ticas avanzadas y una o varias claves de cifrado. Esto hace que sea relativamente f√°cil cifrar un mensaje, pero pr√°cticamente imposible descifrarlo sin conocer las claves requeridas.</p>
</li>
</ul>
<h2 id="esquema-de-cifrado"><a class="header" href="#esquema-de-cifrado">Esquema de cifrado</a></h2>
<p>Estos esquemas definen c√≥mo se realiza la transformaci√≥n de los datos originales en texto cifrado y c√≥mo se realiza la operaci√≥n inversa para recuperar los datos originales a partir del texto cifrado. Un esquema de cifrado generalmente consta de los siguientes elementos:</p>
<ul>
<li>
<p><strong>Encryption Algorithm:</strong> vimos que es el conjunto de operaciones matem√°ticas utilizadas para cifrar los datos en texto cifrado.</p>
</li>
<li>
<p><strong>Decryption Algorithm:</strong> es el conjunto de operaciones matem√°ticas inversas utilizadas para descifrar el texto cifrado y recuperar los datos originales.</p>
</li>
<li>
<p><strong>Key:</strong> conocida como clave, es un valor secreto que se utiliza como entrada para el algoritmo de cifrado. La key determina c√≥mo se realiza la transformaci√≥n de los datos y es esencial para descifrar el texto cifrado.</p>
</li>
<li>
<p><strong>Protocols:</strong> establecen c√≥mo se utiliza el esquema de cifrado, incluyendo la generaci√≥n y distribuci√≥n segura de claves, el manejo de errores y la gesti√≥n de la seguridad.</p>
</li>
</ul>
<p>Existen varios tipos de esquemas de cifrado:</p>
<ol>
<li>
<p>El <a href="https://academy.bit2me.com/que-es-criptografia-simetrica/"><strong>cifrado sim√©trico</strong></a> (donde se utiliza una sola clave tanto para cifrar como para descifrar),</p>
</li>
<li>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_asim%C3%A9trica"><strong>cifrado asim√©trico</strong></a> o de clave p√∫blica (donde se utilizan pares de claves p√∫blica y privada)</p>
</li>
<li>
<p>Otras variantes de esquemas de cifrados como de <a href="https://es.wikipedia.org/wiki/Cifrador_de_flujo">flujo</a> y de <a href="https://es.wikipedia.org/wiki/Cifrado_por_bloques">bloque</a>. Cada esquema tiene sus propias caracter√≠sticas y se utiliza en diferentes contextos seg√∫n los requisitos de seguridad y las necesidades espec√≠ficas de la aplicaci√≥n, pero nos centraremos en las principales para entender su funcionamiento antes de pasar a la evoluci√≥n de las STARKs.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptograf√≠a-sim√©trica"><a class="header" href="#criptograf√≠a-sim√©trica">Criptograf√≠a Sim√©trica</a></h2>
<p>La historia de la criptograf√≠a sim√©trica se remonta a tiempos antiguos, pero su uso moderno se consolid√≥ en el siglo XX con el desarrollo de m√©todos m√°s sofisticados. Un ejemplo ic√≥nico es la <a href="https://en.wikipedia.org/wiki/Enigma_machine">m√°quina Enigma</a>, utilizada por los alemanes durante la Segunda Guerra Mundial para cifrar y descifrar mensajes, esta m√°quina demostr√≥ la eficacia de la criptograf√≠a sim√©trica en entornos militares.</p>
<p>Podemos ver la criptograf√≠a sim√©trica como una antigua y confiable llave maestra en el mundo de la seguridad inform√°tica. Es una t√©cnica que ha sido utilizada desde hace mucho tiempo y a√∫n en la actualidad sigue siendo efectiva y segura para proteger informaci√≥n en diversas situaciones.</p>
<p>Imag√≠nate una llave que puede tanto cerrar como abrir una puerta. Los algoritmos criptogr√°ficos de clave sim√©trica funcionan de manera similar, utilizan la misma clave para cifrar el texto original y descifrar el texto cifrado, esta clave compartida es como el secreto que solo t√∫ y los destinatarios autorizados conocen.</p>
<p><img src="./assets/simetrico.gif" alt="graph" /></p>
<div align="center">
<em>Criptograf√≠a Sim√©trica - √önica Key</em>
</div>
<p>Sin embargo, a medida que la tecnolog√≠a avanzaba y las capacidades de c√≥mputo aumentaban, se hizo evidente que era necesario fortalecer los sistemas de cifrado. Surgieron nuevos desaf√≠os y amenazas que requer√≠an niveles m√°s altos de seguridad. Es por eso que se desarrollaron otros m√©todos criptogr√°ficos, como la criptograf√≠a asim√©trica, que utiliza pares de claves diferentes para el cifrado y el descifrado.</p>
<p>Aunque la criptograf√≠a sim√©trica ha evolucionado con el tiempo, todav√≠a se utiliza ampliamente en muchos sistemas y aplicaciones. Su simplicidad y eficiencia la convierten en una opci√≥n popular para proteger datos en redes privadas, sistemas de comunicaci√≥n y almacenamiento de informaci√≥n sensible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptograf√≠a-asim√©trica"><a class="header" href="#criptograf√≠a-asim√©trica">Criptograf√≠a Asim√©trica</a></h1>
<p>Ahora hablemos como el concepto de algoritmos criptogr√°ficos de clave asim√©trica, fue un enfoque revolucionario que introdujo un concepto completamente diferente, <strong>el uso de un par de claves complementarias, una p√∫blica y una privada</strong>, para asegurar la confidencialidad de los datos. Cada clave del par ten√≠a una funci√≥n espec√≠fica:</p>
<ul>
<li><strong>Public key</strong>: esta clave p√∫blica se compart√≠a abiertamente y se utilizaba para cifrar la informaci√≥n.</li>
<li><strong>Private key:</strong> esta clave privada se guardaba cuidadosamente y se utilizaba para descifrarla.</li>
</ul>
<p>Con la criptograf√≠a de clave p√∫blica, los mensajes cifrados pod√≠an ser transmitidos a trav√©s de redes inseguras sin el temor de que fueran interceptados y descifrados por personas no autorizadas, pero en este caso diferenci√°ndose de la sim√©trica en que estos mensajes requer√≠an un Private key y una Public key. Era como si se hubiera descubierto una nueva forma de comunicaci√≥n secreta y segura en el mundo digital, fue un avance revolucionario en el campo de la criptograf√≠a.</p>
<p><img src="./assets/asimetrico.gif" alt="graph" /></p>
<div align="center">
<em>Criptograf√≠a Asim√©trica - Creaci√≥n de PK y PB</em>
</div>
<p>Algunos de los m√°s destacados y utilizados son los siguiente:</p>
<ul>
<li>
<p><strong>RSA -</strong> <a href="https://es.wikipedia.org/wiki/RSA"><strong>Rivest-Shamir-Adleman:</strong></a> es un sistema criptogr√°fico asim√©trico de clave p√∫blica desarrollado en 1979. Su seguridad radica en el problema de la factorizaci√≥n de n√∫meros enteros y se utiliza en diversos √°mbitos de la transmisi√≥n de datos en Internet debido a su facilidad de uso. Este sistema consta de una clave p√∫blica RSA y una clave privada RSA.</p>
</li>
<li>
<p><strong>ECC -</strong> <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_de_curva_el%C3%ADptica"><strong>Elliptic Curve Cryptography:</strong></a> en la d√©cada de 1980 se desarroll√≥ este enfoque de curva el√≠ptica criptogr√°fica, una variante de la criptograf√≠a asim√©trica o de clave p√∫blica basada en las matem√°ticas de las curvas el√≠pticas que proporciona niveles de seguridad similares o superiores a RSA pero con claves m√°s cortas.</p>
</li>
<li>
<p><strong>ECDSA -</strong> <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf"><strong>Elliptic Curve Digital Signature Algorithm:</strong></a> en los A√±os 1990 naci√≥ ECDSA, un algoritmo de firma digital y autenticaci√≥n en criptograf√≠a asim√©trica, basado en curvas el√≠pticas. Se utiliza en criptograf√≠a para garantizar la autenticidad, integridad de los datos. ECDSA se basa en la dificultad computacional de resolver el problema del logaritmo discreto en curvas el√≠pticas.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptograf√≠a-h√≠brida"><a class="header" href="#criptograf√≠a-h√≠brida">Criptograf√≠a H√≠brida</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_h%C3%ADbrida"><strong>cifrado h√≠brido</strong></a> utiliza las propiedades √∫nicas de la criptograf√≠a de clave p√∫blica para intercambiar informaci√≥n secreta a trav√©s de un canal no confiable, combinando la eficacia del cifrado sim√©trico. Esto proporciona una soluci√≥n pr√°ctica de extremo a extremo para garantizar la privacidad de los datos.</p>
<p>Aunque los algoritmos de clave p√∫blica, como RSA-OAEP, son menos eficientes que los algoritmos sim√©tricos, generalmente no se utilizan directamente para cifrar los datos. Sin embargo, desempe√±an un papel importante en el ecosistema criptogr√°fico al permitir el intercambio seguro de claves.</p>
<p>Para utilizar el cifrado sim√©trico, las partes deben compartir una clave. Si ya existe un canal seguro, se puede enviar la clave a trav√©s de √©l. Sin embargo, si no hay un canal seguro disponible, se resuelve el problema del intercambio de claves utilizando la criptograf√≠a de clave p√∫blica.</p>
<ul>
<li><strong>DH -</strong> <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"><strong>Diffie‚ÄìHellman:</strong></a> el intercambio de claves DH es un algoritmo criptogr√°fico de clave p√∫blica dise√±ado espec√≠ficamente para acordar una clave sim√©trica en ausencia de un canal seguro.
La combinaci√≥n de criptograf√≠a de clave p√∫blica para el intercambio de claves y el cifrado sim√©trico para el cifrado de datos en masa se conoce como cifrado h√≠brido.</li>
</ul>
<p>El cifrado h√≠brido se utiliza ampliamente en los protocolos de transferencia de datos para la web, como en la capa de seguridad de transporte <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">(TLS)</a>. Cuando te conectas a un sitio web que utiliza <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a> (HTTP seguro con TLS), tu navegador negocia los algoritmos criptogr√°ficos que aseguran la conexi√≥n. Estos algoritmos incluyen m√©todos para el intercambio de claves, cifrado sim√©trico y firmas digitales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="firmas-digitales"><a class="header" href="#firmas-digitales">Firmas digitales</a></h1>
<p>Los esquemas de firma digital son un tipo de criptograf√≠a de clave p√∫blica que garantiza la integridad, autenticidad y no repudio de los datos.</p>
<p>Es importante destacar que el esquema de firma digital puede variar dependiendo del algoritmo utilizado, ECDSA, es un ejemplo com√∫n de esquema de firma basado en criptograf√≠a de curva el√≠ptica. Aqu√≠ EC recordemos que representa la curva el√≠ptica utilizada y <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm"><strong>DSA</strong></a> (una variante de los esquemas de firma <a href="https://en.wikipedia.org/wiki/Schnorr_signature">Schnorr</a> y <a href="https://en.wikipedia.org/wiki/ElGamal_signature_scheme">ElGamal</a>) el algoritmo de firma digital. Cada esquema tiene sus propias caracter√≠sticas y propiedades de seguridad, y se selecciona seg√∫n los requisitos y consideraciones espec√≠ficas de la aplicaci√≥n.</p>
<p>Cuando se trata de firmas digitales, los pasos generales suelen ser los siguientes:</p>
<ul>
<li>
<p><strong>Key generation:</strong> el Generador de Claves es un protocolo o algoritmo que genera <strong>un Keypar</strong>, un par de claves asim√©tricas como se explic√≥ anteriormente compuestas por una public key y una private key. En el caso de la criptograf√≠a de curva el√≠ptica (como ECDSA), se generan los par√°metros necesarios para definir la curva y se elige una clave privada aleatoria. A partir de la clave privada, se calcula la clave p√∫blica correspondiente utilizando operaciones matem√°ticas espec√≠ficas.</p>
</li>
<li>
<p><strong>Hash del mensaje:</strong> antes de firmar el mensaje, se aplica una funci√≥n hash criptogr√°fica al contenido del mensaje. Esto reduce el mensaje a un valor de longitud fija llamado resumen o hash. El objetivo es garantizar la integridad y eficiencia del proceso de firma, ya que es m√°s r√°pido firmar y verificar un resumen m√°s corto que el mensaje completo.</p>
</li>
<li>
<p><strong>Digital Signature:</strong> este proceso tiene el prop√≥sito de realizar una serie de operaciones matem√°ticas utilizando la clave privada y el hash del mensaje para generar la firma digital.</p>
</li>
<li>
<p><strong>Verify Signature:</strong> para verificar la autenticidad de la firma, se necesita la clave p√∫blica del firmante. Se aplica nuevamente la funci√≥n hash al mensaje original y se utiliza la clave p√∫blica junto con la firma para realizar operaciones matem√°ticas espec√≠ficas. Si el resultado coincide con la firma original, se considera que la firma es v√°lida y se confirma la autenticidad del mensaje y del firmante.</p>
</li>
</ul>
<p>El proceso de firma puede considerarse como el cifrado del archivo mediante la clave privada. Para ello, la persona que firma utiliza su clave privada para producir una firma.</p>
<p>Exploraremos a continuaci√≥n la relevancia de los diversos esquemas de firmas para garantizar la seguridad de nuestros datos, as√≠ como la forma en que Starknet usa AA para abstraer la firma de la validaci√≥n. En este contexto, se pueden dise√±ar diferentes esquemas o configuraciones, como el <code>secp256r1</code>, una variante de STARK Curve, la versi√≥n amigable de ECDSA optimizada en Starknet. Este esquema de firma se puede utilizar para incorporar firmas en dispositivos modernos de manera biom√©trica, aislada y abstra√≠da por naturaleza, lo que mejora significativamente la eficiencia, tal como se discutir√° en detalle m√°s adelante.</p>
<p>Por lo tanto, resulta crucial abordar el siguiente apartado relacionado con el uso de Key generation que desempe√±an un papel fundamental en este contexto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-generator"><a class="header" href="#key-generator">Key generator</a></h1>
<p>Tenemos que entender c√≥mo el generador de claves <a href="https://en.wikipedia.org/wiki/Key_generator"><strong>(Key generator)</strong></a> genera el Keypair, para lograrlo, es necesario trabajar con valores pseudoaleatorios que se utilizan en la generaci√≥n de la private key. Un Key generator se puede implementar en un sistema con el prop√≥sito de generar y autenticar claves.</p>
<p>Key generator puede implementarse en cualquier sistema criptogr√°fico que utilice la curva el√≠ptica, como es el caso de <code>secp256k1</code> (una curva optimizada basada en las propiedades matem√°ticas de las curvas el√≠pticas para proporcionar un esquema de firma digital seguro y eficiente), como Bitcoin y Ethereum.</p>
<p>Este generador de claves garantiza que, con alta probabilidad, las claves privadas generadas sean √∫nicas y seguras, lo que a su vez respalda la integridad y autenticidad de las transacciones realizadas en la red.</p>
<h2 id="generadores-de-n√∫meros-pseudoaleatorios"><a class="header" href="#generadores-de-n√∫meros-pseudoaleatorios">Generadores de n√∫meros pseudoaleatorios</a></h2>
<p>Para garantizar la seguridad usando la pseudoaleatoriedad estad√≠stica de un <strong>PRNG -</strong> <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator"><strong>Pseudorandom number generator</strong></a>, es crucial contar con una semilla inicial. Si la semilla es f√°cilmente predecible, generar√° valores predecibles de n√∫meros y todo el proceso ser√° inseguro.</p>
<p>Para lograr una inicializaci√≥n segura del generador pseudoaleatorio, es necesario recolectar <a href="https://en.wikipedia.org/wiki/Entropy_(computing)"><strong>Entrop√≠a</strong></a>, que representa la aleatoriedad necesaria en el proceso.</p>
<h2 id="entrop√≠a"><a class="header" href="#entrop√≠a">Entrop√≠a</a></h2>
<p>La entrop√≠a o aleatoriedad impredecible en computaci√≥n, generalmente se mide en bits. Tenemos varios ejemplos para entender el concepto y grado de aleatoriedad. Si mueve el mouse de su computadora, generar√° algunos eventos dif√≠ciles de predecir, como la ubicaci√≥n de inicio y la ubicaci√≥n final del cursor del mouse.</p>
<blockquote>
<p>Si suponemos que el mouse ha cambiado su posici√≥n en el rango de <code>[ 0 ... 255 p√≠xeles ]</code>, la entrop√≠a recolectada de este movimiento del mouse debe ser de aproximadamente <strong>8 bits</strong>, porque <code>2‚Å∏ = 255</code></p>
</blockquote>
<blockquote>
<p>Si se le pide al usuario que piense en un n√∫mero en el rango <code>[ 0 ... 1000 ]</code>, este n√∫mero tendr√° alrededor de <strong>9-10 bits</strong> de entrop√≠a porque, <code>2¬π‚Å∞ = 1024</code></p>
</blockquote>
<p>Para recolectar 256 bits de entrop√≠a, es decir, para generar de forma segura un n√∫mero entero de 256 bits, deber√° tener en cuenta una secuencia de varios eventos similares (como movimientos del mouse e interracidades del teclado del usuario).</p>
<p>Aqu√≠ la importancia de d√≥nde y c√≥mo hemos generado nuestras claves privadas y p√∫blicas y las posibles vulnerabilidades en algunos malos usos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funciones-hash-y-funciones-hash-criptogr√°ficas"><a class="header" href="#funciones-hash-y-funciones-hash-criptogr√°ficas">Funciones hash y funciones hash criptogr√°ficas</a></h1>
<p>Este apartado es de suma importancia para comprender el funcionamiento de las funciones hash. A diferencia de los esquemas de cifrado o las firmas, las funciones hash no requieren de una clave. Cualquier persona puede calcular el hash de una entrada determinada, y la funci√≥n hash siempre producir√° la misma salida para la misma entrada.</p>
<p>As√≠ que podemos definir una <a href="https://en.wikipedia.org/wiki/Hash_function"><strong>funci√≥n hash</strong></a> como un algoritmo que toma una entrada, como un mensaje o un archivo, y produce una salida de longitud fija llamada hash o resumen. Esta salida es √∫nica para cada entrada espec√≠fica, lo que permite la verificaci√≥n de la integridad de los datos y garantiza que cualquier cambio en la entrada resultar√° en un hash completamente diferente.</p>
<p>Una <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function"><strong>funci√≥n hash criptogr√°fica</strong></a>, por otro lado, es aquella funci√≥n hash que se utiliza en el √°mbito de la criptograf√≠a, para evaluar la seguridad de una funci√≥n de hash criptogr√°fica, se consideran las siguientes propiedades:</p>
<ul>
<li><strong>Resistencia a la preimagen:</strong> partiendo de un valor <code>hash h</code>, es dif√≠cil encontrar un mensaje <code>m</code> que genere ese <code>hash</code>, es decir, <code>h = hash(m)</code>, este concepto est√° relacionado con el de una funci√≥n de sentido √∫nico. Las funciones que carecen de esta propiedad son vulnerables a ataques de preimagen.</li>
<li><strong>Resistencia a la segunda preimagen:</strong> dado un mensaje <code>m‚ÇÅ</code>, es dif√≠cil encontrar otro mensaje <code>m‚ÇÇ</code> distinto a <code>m‚ÇÅ</code> que produzca el mismo valor de hash, es decir, <code>hash(m‚ÇÅ) = hash(m‚ÇÇ)</code>. Esta propiedad tambi√©n se conoce como resistencia d√©bil a colisiones. Las funciones que no cumplen esta propiedad son vulnerables a ataques de segunda preimagen.</li>
<li><strong>Resistencia a colisiones:</strong> es dif√≠cil encontrar dos mensajes diferentes <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code> que produzcan el mismo valor de hash, es decir, <code>hash(m‚ÇÅ) = hash(m‚ÇÇ)</code>. Estas colisiones son conocidas como colisiones criptogr√°ficas de hash. Esta propiedad tambi√©n se conoce como resistencia fuerte a colisiones. Se requiere que el tama√±o del hash sea al menos el doble de largo para garantizar la resistencia a la preimagen.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-tree-en-blockchain"><a class="header" href="#merkle-tree-en-blockchain">Merkle Tree en Blockchain</a></h1>
<p>Ahora que hemos comprendido mejor qu√© es un hash, veamos c√≥mo en criptograf√≠a y <a href="https://en.wikipedia.org/wiki/Computer_science">ciencias de la computaci√≥n</a>, un √°rbol hash, tambi√©n conocido c√≥mo <a href="https://en.wikipedia.org/wiki/Merkle_tree"><strong>Merkle Tree o binary Merkle tree</strong></a>, es una <a href="https://en.wikipedia.org/wiki/Data_structure">estructura de datos</a> utilizada para garantizar la integridad de los contenidos almacenados en un sistema, como la tecnolog√≠a blockchain.</p>
<p>Podemos ver los Merkle Trees como una estructura de √°rbol en la que cada &quot;hoja&quot; o nodo terminal, est√° etiquetado con el hash criptogr√°fico de un bloque de datos. A su vez, cada nodo que no es una hoja, tambi√©n conocido como rama, nodo interior o inodo, est√° etiquetado con el hash criptogr√°fico de las etiquetas de sus nodos secundarios.</p>
<p>La construcci√≥n de un Merkle Tree implica dividir los datos en bloques m√°s peque√±os y aplicar una funci√≥n de hash criptogr√°fico a cada uno de ellos. Luego, los bloques hash se combinan en pares y se vuelven a hashear, repitiendo este proceso hasta obtener un √∫nico hash llamado ra√≠z de Merkle o ‚ÄúMerkle root‚Äù. Esta ra√≠z se coloca en la cabecera de un bloque o transacci√≥n y se utiliza como una firma digital que representa y verifica la integridad de todos los datos incluidos en el bloque.</p>
<p><img src="./assets/merkle.gif" alt="graph" /></p>
<div align="center">
<em>Ejemplo de estructura de un Merkle Tree</em>
</div>
<p>Una de las principales ventajas de los Merkle Trees es su capacidad para proporcionar una verificaci√≥n eficiente y segura de los contenidos de una gran estructura de datos. Como cada nodo intermedio en el √°rbol est√° etiquetado con el hash criptogr√°fico de las etiquetas de sus nodos secundarios, cualquier cambio realizado en los datos se reflejar√° en cambios en los hashes correspondientes.</p>
<p>En la tecnolog√≠a blockchain que usan los Merkle Trees, los utilizan para garantizar la integridad de los datos almacenados en cada bloque de la cadena. Cada bloque contiene una lista de transacciones, y el Merkle Tree se construye utilizando los hashes de estas transacciones.</p>
<p>Cuando se agrega un nuevo bloque a la cadena, la ra√≠z de Merkle del bloque anterior se incluye en el nuevo bloque, creando una cadena enlazada de √°rboles de Merkle. Esto permite verificar r√°pidamente la integridad de cualquier bloque en la cadena sin necesidad de verificar todos los datos desde el inicio. Adem√°s, si alg√∫n dato se modifica en un bloque, el hash del bloque cambiar√°, lo que afectar√° la ra√≠z de Merkle y se√±alar√° la alteraci√≥n en la cadena.</p>
<p>Algunos casos posibles de uso de los binary Merkle Trees para los diferentes esquemas pueden ser:</p>
<ul>
<li><strong>Los binary Merkle Trees:</strong> son estructuras de datos muy eficientes para autenticar informaci√≥n que se presenta en formato de &quot;lista&quot;, es decir, una secuencia de elementos consecutivos.</li>
<li><strong>Los transaction trees:</strong> tambi√©n resultan beneficiosos, ya que una vez creado el √°rbol, no importa cu√°nto tiempo se tarde en editarlo, ya que permanecer√° inmutable.</li>
<li><strong>Los State trees:</strong> sin embargo, cuando se trata de un √°rbol que almacena estados la situaci√≥n se vuelve m√°s compleja, el estado en Ethereum, que consiste en un mapa de valores clave donde:
<ul>
<li><strong>Las claves son direcciones</strong></li>
<li><strong>Los valores son las declaraciones de cuenta que incluyen:</strong> saldo, nonce, c√≥digo y almacenamiento asociados a cada cuenta, r</li>
<li><strong>Requiere la construcci√≥n de una prueba de transici√≥n de estado de Merkle</strong> <a href="https://medium.com/@chiqing/verify-ethereum-account-balance-with-state-proof-83b51ceb15cf">(Merkle state transition proof)</a></li>
</ul>
</li>
</ul>
<p>As√≠ que, comprender el funcionamiento de los State Trees y su optimizaci√≥n de datos es crucial en el contexto actual donde los datos y los hashes desempe√±an un papel fundamental. En el caso de Ethereum, uno de los principales actores en el √°mbito de los State Trees, se han incorporado modificaciones interesantes usando Patricia Merkle Trie.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patricia-merkle-trie"><a class="header" href="#patricia-merkle-trie">Patricia Merkle Trie</a></h1>
<p>La especificaci√≥n de Ethereum define el <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/"><strong>Modified Merkle Patricia Trie</strong></a> (tambi√©n conocido como MPT) este m√©todo se utiliza para guardar estados. B√°sicamente, el MPT es una combinaci√≥n del Patricia trie y el Merkle tree, con algunas optimizaciones adicionales adaptadas a las caracter√≠sticas de Ethereum.</p>
<p>Patricia trie, <a href="https://en.wikipedia.org/wiki/Radix_tree">(Radix tree o Radix trie)</a>, √°rbol de prefijos compacto <strong>(compact prefix tree)</strong> o √°rbol de prefijos comprimido <strong>(compressed trie)</strong>, es una sofisticada estructura de datos que ofrece una optimizaci√≥n espacial en la representaci√≥n de [Tries] (√°rboles de prefijos). Una de las caracter√≠sticas clave de este tipo de √°rbol es la fusi√≥n de nodos cuando un nodo es hijo √∫nico de su padre, lo que contribuye a una mayor eficiencia y rendimiento.</p>
<p>Esta estructura es un tipo de <strong>√°rbol de b√∫squeda k-ary</strong>, siendo un <a href="https://en.wikipedia.org/wiki/M-ary_tree">m-ary tree</a> (tambi√©n conocido como <code>n-ary tree</code>, <code>k-ary tree</code> o <code>k-way tree</code>) un √°rbol ra√≠z en el cual cada nodo tiene como m√°ximo m hijos. Ambas estructuras de datos se utilizan para localizar claves espec√≠ficas dentro de un conjunto.</p>
<p>Estos √°rboles son completamente deterministas, lo que significa que aquellos con las mismas asociaciones de (clave, valor) est√°n garantizados de ser id√©nticos, hasta el √∫ltimo byte. Esto asegura que tengan el mismo hash ra√≠z, lo que proporciona la deseada eficiencia de <code>O(log(n))</code> para inserciones, b√∫squedas y eliminaciones. Adem√°s, son m√°s f√°ciles de entender y programar que alternativas m√°s complejas basadas en comparaciones, como los <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree.</a></p>
<p>El Patricia Merkle Trie combina la estructura de un √°rbol de b√∫squeda binario con la estructura de √°rbol de Merkle, lo cual permite verificar eficientemente la integridad de los datos y proporciona una representaci√≥n compacta del estado completo de la cadena.</p>
<p>El uso del Patricia Merkle Trie en Ethereum ofrece ventajas significativas en t√©rminos de eficiencia y escalabilidad. Permite realizar consultas r√°pidas sobre el estado de las cuentas y los contratos, evitando la necesidad de recorrer todo el estado completo. En cambio, solo es necesario verificar y acceder a los nodos relevantes en el √°rbol, lo que ahorra tiempo y recursos.</p>
<p>Adem√°s, esta estructura de √°rbol facilita la implementaci√≥n de funciones de snapshot y revert en Ethereum. Estas funciones permiten crear instant√°neas del estado del sistema en momentos espec√≠ficos y revertir cambios en caso de errores o ataques, brindando una capa adicional de seguridad y confiabilidad a la red blockchain.</p>
<p><img src="" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>La comprensi√≥n de los Merkle Trees y el MPT resulta especialmente relevante al explorar otras estructuras de datos criptogr√°ficas, como las Merkle Mountain Ranges (MMRs) en Herodotus para las Storage Proof. Las MMRs pueden considerarse una lista de √Årboles de Merkle, donde cada √°rbol se representa como una monta√±a y la lista completa forma el rango. La utilizaci√≥n de funciones hash espec√≠ficas y sus caracter√≠sticas de seguridad se explorar√°n para comprender c√≥mo crear estos √°rboles de manera eficiente y √≥ptima.</p>
<p>Por lo tanto, es crucial comprender a fondo las diferentes funciones hash y sus propiedades para tomar decisiones informadas sobre la selecci√≥n y optimizaci√≥n de las mismas en la construcci√≥n de estructuras de datos criptogr√°ficas m√°s eficientes y seguras en los √Årboles de Merkle.</p>
<p>Las funciones hash desempe√±an un papel fundamental en garantizar la integridad y la seguridad de los datos almacenados en los √°rboles de Merkle, ya que se utilizan para calcular los hashes de los nodos y verificar su integridad durante la construcci√≥n y la verificaci√≥n del √°rbol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha-256"><a class="header" href="#sha-256">SHA-256</a></h1>
<p>Es hora de examinar algunos ejemplos de funciones hash criptogr√°ficas ampliamente utilizadas, un ejemplo es <code>SHA-256</code> <a href="https://es.wikipedia.org/wiki/SHA-2"><strong>(Secure Hash Algorithm 256-bit)</strong></a>, <strong>que es una funci√≥n de hash criptogr√°fica perteneciente a la familia de algoritmos SHA-2.</strong> Esta funci√≥n acepta una entrada de cualquier longitud y genera una salida de 256 bits que se considera √∫nica y asociada de forma irreversible a dicha entrada.</p>
<p>Pueden probar la generaci√≥n de un hash utilizando cualquier <a href="https://miniwebtool.com/es/sha256-hash-generator/">generador en l√≠nea</a>. En este caso, <a href="https://bfotool.com/category/encode-decoder">realizamos pruebas</a> utilizando la funci√≥n hash <code>SHA-256</code> y <code>keccak-256</code>, tambi√©n pueden explorar y probar <a href="https://bfotool.com/category/encode-decoder">m√°s funciones hash desde aqu√≠.</a></p>
<p>El cambio de un solo bit causa un efecto avalancha, lo que significa que incluso un cambio m√≠nimo como un <code>.</code> en la entrada, produce un cambio significativo en la salida. Puedes revisar el hash de <code>L2 en Espa√±ol</code> y <code>L2 en Espa√±ol.</code></p>
<p><img src="./assets/Sha256.png" alt="graph" /></p>
<div align="center">
<em>Salida de datos completamente diferente a√±adiendo un "."</em>
</div>
<p><code>SHA-256</code> se utiliza ampliamente en criptograf√≠a, y cuenta con diversos casos de uso destacados:</p>
<ol>
<li><strong>Verificaci√≥n de integridad:</strong> <code>SHA-256</code> se utiliza para verificar la integridad de los datos almacenados en un sistema. Al calcular el hash de un archivo o conjunto de datos, se puede comparar con el hash original para detectar cualquier cambio o alteraci√≥n en los datos.</li>
<li><strong>Firmas digitales:</strong> las firmas digitales se generan mediante algoritmos criptogr√°ficos y se basan en la funci√≥n SHA-256 para asegurar la autenticidad e integridad de los mensajes. El hash <code>SHA-256</code> se utiliza para resumir y proteger la informaci√≥n que se firma digitalmente.</li>
<li><strong>Almacenamiento seguro de contrase√±as:</strong> en lugar de almacenar contrase√±as en texto plano, los sistemas de seguridad suelen almacenar el hash <code>SHA-256</code> de las contrase√±as. Cuando un usuario ingresa su contrase√±a, se calcula el hash y se compara con el valor almacenado, lo que permite verificar la autenticidad de la contrase√±a sin almacenarla directamente.</li>
<li><strong>Generaci√≥n de claves criptogr√°ficas:</strong> <code>SHA-256</code> se utiliza en algoritmos de generaci√≥n de claves criptogr√°ficas para producir claves aleatorias y seguras.</li>
</ol>
<p>En resumen, <code>SHA-256</code> es una funci√≥n hash criptogr√°fica ampliamente utilizada que forma parte de la familia de algoritmos <code>SHA-2</code>, la hace ideal para verificar la integridad de los datos, generar firmas digitales, almacenar contrase√±as de forma segura y generar claves criptogr√°ficas. <code>SHA-256</code> ha demostrado su robustez y eficacia en numerosos casos de uso en criptograf√≠a. Ahora es el turno de explorar otra funci√≥n hash criptogr√°fica m√°s moderna llamada Keccak.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak---el-nuevo-sha-3"><a class="header" href="#keccak---el-nuevo-sha-3">Keccak - El nuevo SHA-3</a></h1>
<p>Ahora nos centraremos en el <code>SHA-3</code> <a href="https://en.wikipedia.org/wiki/SHA-3"><strong>(Secure Hash Algorithm 3)</strong></a>, es un est√°ndar de funci√≥n hash criptogr√°fica dise√±ado por los cript√≥grafos Joan Daemen y Gilles Van Assche. El algoritmo utilizado en <code>SHA-3</code> se llama <a href="https://keccak.team/index.html"><strong>Keccak</strong></a>, el cual fue <a href="https://www.federalregister.gov/documents/2015/08/05/2015-19181/announcing-approval-of-federal-information-processing-standard-fips-202-sha-3-standard"><strong>seleccionado como el ganador del concurso</strong></a> organizado por el Instituto Nacional de Est√°ndares y Tecnolog√≠a <a href="https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology">(NIST)</a> para encontrar un nuevo est√°ndar de funci√≥n hash criptogr√°fica.</p>
<p>A diferencia de <code>SHA-256</code>, <code>Keccak</code> utiliza una estructura y operaciones diferentes. En lugar de rondas, <code>Keccak</code> se basa en una construcci√≥n llamada funci√≥n de esponja <a href="https://en.wikipedia.org/wiki/Sponge_function">(Sponge function)</a>, que se basa en una funci√≥n pseudoaleatoria amplia o <a href="https://keccak.team/glossary.html#permutation">(permutation)</a> pseudoaleatorio permitiendo ingresar <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<p><code>Keccak-256</code> es una funci√≥n hash criptogr√°fica utilizada en Ethereum. Pertenece a la familia de algoritmos <code>SHA-3</code> y se emplea ampliamente en la plataforma Ethereum para diversos prop√≥sitos.</p>
<p>Algunos casos de uso de <code>Keccak-256</code> incluyen:</p>
<ul>
<li>Ethereum utiliza <code>Keccak-256</code> para garantizar la integridad de los datos y generar identificadores √∫nicos (hash) para verificar la autenticidad de los archivos y mensajes en sistemas criptogr√°ficos.</li>
<li>Tambi√©n se utiliza en la firma criptogr√°fica de peque√±o tama√±o, donde en lugar de firmar la entrada completa, se firma el hash <code>Keccak-256</code> del mensaje o dato.</li>
<li><code>Keccak-256</code> es utilizado para obtener una identificaci√≥n √∫nica y determinista de una colecci√≥n de datos. Por ejemplo, en Ethereum, las direcciones de Ethereum se derivan de claves p√∫blicas o contratos utilizando la funci√≥n hash unidireccional <code>Keccak-256</code>.</li>
</ul>
<p>Las direcciones Ethereum son n√∫meros hexadecimales, identificadores derivados de los √∫ltimos 20 bytes del hash <code>Keccak-256</code> de la clave p√∫blica.</p>
<p>A diferencia de las direcciones de Bitcoin, que est√°n codificadas en la interfaz de usuario de todos los clientes para incluir una suma de verificaci√≥n incorporada para proteger contra direcciones mal escritas, las direcciones de Ethereum se presentan como hexadecimales sin ninguna suma de verificaci√≥n.</p>
<p><img src="./assets/Keccak.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El algoritmo <strong>Keccak</strong> utiliza la <a href="https://keccak.team/glossary.html#sponge_construction"><strong>Sponge construction</strong></a> para procesar los datos de entrada de longitud variable para generar una salida de longitud variable. Esta construcci√≥n se basa en una funci√≥n interna llamada <code>&quot;F&quot;</code> que opera en un n√∫mero fijo de bits, denotado como <code>&quot;width&quot;</code> <a href="https://keccak.team/glossary.html#width">(anchura)</a>.</p>
<p>La anchura total del algoritmo Keccak se determina sumando dos componentes, el valor de <code>&quot;r&quot;</code> <a href="https://keccak.team/glossary.html#rate">(rate)</a> y el valor de <code>&quot;c&quot;</code> <a href="https://keccak.team/glossary.html#capacity">(capacity)</a>, donde <code>b = r + c</code>.</p>
<ul>
<li>El valor de <code>&quot;r&quot;</code> representa la cantidad de bits absorbidos en cada paso de la funci√≥n esponja, es decir, <strong>la capacidad de absorci√≥n de la esponja.</strong> Un valor de <code>&quot;r&quot;</code> m√°s grande permite procesar m√°s informaci√≥n en cada paso, lo que reduce la cantidad de pasos necesarios para procesar una entrada espec√≠fica.</li>
<li>El valor de <code>&quot;c&quot;</code> representa la capacidad de la esponja, es decir, <strong>la cantidad de bits que se mantienen en el estado interno del algoritmo despu√©s de cada paso de absorci√≥n</strong>. Estos bits se mezclan con los datos de entrada y el resultado de la funci√≥n interna <code>&quot;F&quot;</code>. La capacidad afecta la resistencia del algoritmo a ataques criptogr√°ficos como colisiones o preimagen.</li>
</ul>
<p>La suma de <code>&quot;r&quot;</code> y <code>&quot;c&quot;</code> da como resultado el n√∫mero total de bits, <code>&quot;b&quot;</code>, utilizados en la funci√≥n esponja de Keccak. Este valor determina la longitud del estado interno y, por lo tanto, la longitud de la salida generada por el algoritmo.</p>
<h2 id="funcionamiento-keccak"><a class="header" href="#funcionamiento-keccak">Funcionamiento keccak</a></h2>
<p>El algoritmo funciona de la siguiente manera, inicialmente la cadena de entrada se rellena con bits adicionales para enmascarar el mensaje inicial y se divide en bloques de longitud <code>&quot;r&quot;</code> bits. Luego, los <code>&quot;b&quot;</code> bits de estado se inicializan a <code>0</code>, que da inicio a la <strong>Sponge construction</strong> en dos fases <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<ul>
<li><strong>Fase Absorbing:</strong> a los bloques de entrada de longitud <code>r-bits</code> se les aplica un <a href="https://en.wikipedia.org/wiki/XOR_cipher">XOR</a> (toma dos bits y devuelve un resultado que es 1 si solo uno de los bits es 1, y 0 en caso contrario) a los primeros <code>r</code> bits del estado, altern√°ndose con la funci√≥n <code>f</code>. Cuando todos los bloques han sido procesados, se pasa a la siguiente fase.</li>
<li><strong>Fase Squeezing:</strong> los primeros <code>r</code> bits del estado son devueltos como bloques de salida, altern√°ndose con ejecuciones de la funci√≥n <code>f</code>. El n√∫mero de bloques de salida es seleccionado por el usuario.</li>
</ul>
<p>A continuaci√≥n os dejamos una tabla que enumeran algunas de las diferencias entre <code>SHA-256</code> y <code>Keccak-256</code>.</p>
<p><img src="./assets/Comparativa_Sha_keccak.png" alt="graph" /></p>
<div align="center">
<em>Algunas diferencias entre SHA-256 y Keccak-256</em>
</div>
<p>Vemos c√≥mo cada tipo de criptograf√≠a o funci√≥n hash tiene caracter√≠sticas distintas. En el contexto actual de la computaci√≥n cu√°ntica en constante evoluci√≥n, es crucial abordar las preocupaciones emergentes sobre seguridad. Algunos algoritmos criptogr√°ficos podr√≠an ser vulnerables a los ataques cu√°nticos en un futuro cercano. Es en este punto donde entra en juego el concepto de criptograf√≠a <a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography">Post-Quantum</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantum-secure"><a class="header" href="#quantum-secure">Quantum Secure</a></h1>
<p>As√≠ que es hora de aprovechar lo que hemos aprendido y explorar lo que podr√≠a suceder en un escenario te√≥rico apocal√≠ptico. Pero antes comencemos con una breve descripci√≥n sobre <a href="https://es.wikipedia.org/wiki/Computaci%C3%B3n_cu%C3%A1ntica">computaci√≥n cu√°ntica</a> para sumergirnos en el tema. <strong>No es m√°s que un modelo de computaci√≥n basado en la</strong> <a href="https://es.wikipedia.org/wiki/Mec%C3%A1nica_cu%C3%A1ntica"><strong>f√≠sica cu√°ntica</strong></a>, que funciona de manera diferente a las computadoras cl√°sicas (el tipo de computadoras que usamos habitualmente) y tiene la capacidad de realizar tareas que estas √∫ltimas no pueden, como romper ciertos algoritmos de manera eficiente.</p>
<blockquote>
<p><strong>¬°As√≠ que espera un momento!</strong> Antes de que tu imaginaci√≥n se desborde y te veas rodeado de supercomputadoras cu√°nticas capaces de solucionar todos nuestros problemas, d√©jame contarte una peque√±a an√©cdota.</p>
</blockquote>
<blockquote>
<p><em>Ah, las computadoras cu√°nticas, esas criaturas de la f√≠sica cu√°ntica que nos hacen so√±ar con un futuro lleno de posibilidades. Pero, ¬øsab√≠as que no son m√°quinas m√°gicas capaces de resolver todos nuestros problemas inform√°ticos en un abrir y cerrar de ojos?</em></p>
</blockquote>
<blockquote>
<p><strong>Imagina esto:</strong> las computadoras cu√°nticas son como esas personas brillantes que son s√∫per eficientes en ciertas tareas, pero bastante d√©biles en otras. Son como el genio matem√°tico que resuelve complicados problemas de c√°lculo en segundos, pero se le olvida c√≥mo atarse los zapatos.</p>
</blockquote>
<blockquote>
<p><em>Entonces, s√≠, las computadoras cu√°nticas pueden ser incre√≠blemente poderosas cuando se trata de ciertos problemas espec√≠ficos, como el factorizar n√∫meros grandes o buscar en enormes bases de datos. Pero cuando se trata de tareas cotidianas, como revisar correos electr√≥nicos o navegar por la web, bueno, digamos que son como un caracol tratando de correr una marat√≥n.</em></p>
</blockquote>
<p>Despu√©s de esta peque√±a relato, es importante comprender el concepto de criptograf√≠a post-cu√°ntica <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>(PQC)</strong></a>, tambi√©n conocida como <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>Resistente a la Computaci√≥n Cu√°ntica</strong></a>, se refiere a algoritmos criptogr√°ficos especialmente algoritmos de clave p√∫blica, que se consideran seguros contra los ataques criptoanal√≠ticos llevados a cabo por computadoras cu√°nticas.</p>
<p>A medida que avanza la computaci√≥n cu√°ntica, se espera que algunos algoritmos y t√©cnicas criptogr√°ficas tradicionales utilizadas en los sistemas de seguridad actuales sean vulnerables a los ataques cu√°nticos. Esto se debe a la capacidad de las computadoras cu√°nticas para realizar c√°lculos a una escala exponencialmente mayor que las computadoras cl√°sicas, lo que podr√≠a comprometer la seguridad de los sistemas criptogr√°ficos actuales.</p>
<p>Es bien sabido en inform√°tica que las computadoras cu√°nticas podr√°n romper algunos algoritmos criptogr√°ficos, especialmente los criptosistemas de clave p√∫blica como <strong>RSA</strong>, el intercambio de llaves <strong>Diffie‚ÄìHellman</strong> y <strong>ECDSA</strong>, que dependen del <a href="https://es.wikipedia.org/wiki/Factorizaci%C3%B3n_de_enteros"><strong>IFP</strong></a> (problema de factorizaci√≥n en n√∫meros primos), el <a href="https://es.wikipedia.org/wiki/Logaritmo_discreto"><strong>DLP</strong></a> (problema del logaritmo discreto) y el ECDLP (problema del logaritmo discreto de curva el√≠ptica). Todos estos problemas podr√≠an resolverse f√°cilmente en una computadora cu√°ntica suficientemente poderosa que ejecute el algoritmo de Shor.</p>
<p>Pero los algoritmos cu√°nticos no significar√°n el fin de la criptograf√≠a, porque:</p>
<ul>
<li>Solo algunos criptosistemas son inseguros frente a la computaci√≥n cu√°ntica (como RSA, DHKE, ECDSA y ECDH).</li>
<li>Algunos criptosistemas son seguros frente a la computaci√≥n cu√°ntica y solo se ver√°n ligeramente afectados (como los hash criptogr√°ficos, algoritmos <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_de_autenticaci%C3%B3n_de_mensaje">MAC</a> y cifrados de clave sim√©trica como <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard?wprov=srpw1_0">AES</a>, siempre que se utilicen tama√±os de clave suficientemente grandes).</li>
</ul>
<p>A diferencia de la amenaza que representa la computaci√≥n cu√°ntica para los algoritmos de clave p√∫blica actuales, <strong>la mayor√≠a de los algoritmos criptogr√°ficos sim√©tricos y las funciones hash actuales se consideran relativamente seguros contra ataques de computadoras cu√°nticas.</strong> Si bien el algoritmo cu√°ntico de Grover acelera los ataques contra los cifrados sim√©tricos, duplicar el tama√±o de la clave puede bloquear eficazmente estos ataques. Por lo tanto, la criptograf√≠a sim√©trica post-cu√°ntica no necesita diferir significativamente de la criptograf√≠a sim√©trica actual.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-grover-y-la-b√∫squeda-no-estructurada"><a class="header" href="#el-algoritmo-de-grover-y-la-b√∫squeda-no-estructurada">El algoritmo de Grover y la b√∫squeda no estructurada</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Algoritmo_de_Grover">algoritmo de Grover</a> es un <a href="https://es.wikipedia.org/wiki/Algoritmo_cu%C3%A1ntico">algortimo cu√°ntico</a> para la b√∫squeda en una secuencia no ordenada de datos con <code>N</code> componentes en un tiempo <a href="https://es.wikipedia.org/wiki/Cota_superior_asint%C3%B3tica">O</a>(N¬π/‚ÇÇ), y con una necesidad adicional de espacio de almacenamiento de <code>O(logN)</code>. Fue inventado por Lov K. Grover en <a href="https://es.wikipedia.org/wiki/1996">1996</a>.</p>
<p>Aunque el algoritmo de Grover es eficiente, su paralelizaci√≥n √≥ptima resulta complicada y no se espera que las computadoras cu√°nticas actuales tengan suficiente potencia para comprometer la seguridad de esquemas como ECDSA o de funciones de hash como SHA256.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-shor-te√≥rico-y-su-impacto-en-ecdsa"><a class="header" href="#el-algoritmo-de-shor-te√≥rico-y-su-impacto-en-ecdsa">El algoritmo de Shor te√≥rico y su impacto en ECDSA</a></h1>
<p>El <a href="https://en.wikipedia.org/wiki/Shor&#x27;s_algorithm"><strong>algoritmo de Shor</strong></a> es un algoritmo cu√°ntico desarrollado por Peter Shor en 1994. Este algoritmo es conocido por su capacidad para factorizar grandes n√∫meros enteros de manera mucho m√°s eficiente que los algoritmos cl√°sicos conocidos, lo que tiene implicaciones importantes para la seguridad de algunos sistemas criptogr√°ficos basados en la factorizaci√≥n de n√∫meros enteros.</p>
<p>En el contexto de sistemas centralizados, como los sistemas bancarios, ECDSA se utiliza para garantizar la autenticidad de las transacciones, proteger la confidencialidad de la informaci√≥n y asegurar la integridad de los datos. En el √°mbito de Bitcoin y Ethereum, si bien los algoritmos de b√∫squeda cu√°ntica, como el algoritmo de Shor, podr√≠an eventualmente romper la ECDSA, es importante destacar que estos algoritmos a√∫n est√°n en una etapa te√≥rica.</p>
<p>Cada implementaci√≥n de algoritmos o protocolos puede ser diversa, ya sea privada o abstracta. Nos hemos centrado en los principios b√°sicos comunes de ECDSA, adem√°s se espera que la implementaci√≥n pr√°ctica de algoritmos de b√∫squeda cu√°ntica sea un desaf√≠o t√©cnico debido a los requisitos de recursos y la necesidad de superar errores cu√°nticos.</p>
<p>Aqu√≠ tienes una descripci√≥n general de en qu√© consisten algunos problemas que se consideran complejos de resolver mediante la computaci√≥n cl√°sica.</p>
<h2 id="ifp"><a class="header" href="#ifp">IFP</a></h2>
<p>El IFP se refiere al desaf√≠o de descomponer un n√∫mero entero grande en sus factores primos. En el caso de n√∫meros peque√±os, esto puede hacerse f√°cilmente mediante el uso de algoritmos como <a href="https://yosoytuprofe.20minutos.es/2022/11/09/que-es-la-criba-de-eratostenes-y-cual-es-su-importancia-en-las-matematicas/">el cribado de Erat√≥stenes</a> o <a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm_for_logarithms">el algoritmo de factorizaci√≥n de Pollard</a>.</p>
<p>A modo de ejemplo simplificado, supongamos que queremos factorizar el n√∫mero compuesto <code>N = 35</code> utilizando el algoritmo de Shor. Despu√©s de aplicar el algoritmo, encontrar√≠amos que los factores primos de <code>N</code> son <code>5 y 7</code>.</p>
<p>Sin embargo, a medida que los n√∫meros crecen en tama√±o, el IFP se vuelve cada vez m√°s dif√≠cil de resolver. De hecho, la seguridad de muchos sistemas criptogr√°ficos se basa en la dificultad de factorizar n√∫meros grandes en tiempo razonable, como el popular algoritmo RSA.</p>
<h2 id="dlp"><a class="header" href="#dlp">DLP</a></h2>
<p>Por otro lado, el DLP implica encontrar el exponente desconocido de una potencia modular dada. En t√©rminos m√°s sencillos, se trata de resolver la ecuaci√≥n <code>(y = gÀ£ mod p)</code> para el exponente desconocido <code>(x)</code>, donde <code>(g)</code> y <code>(p)</code> son n√∫meros conocidos e <code>(y)</code> es el resultado de la operaci√≥n de potenciaci√≥n modular. Para valores peque√±os de <code>(p)</code>, el DLP puede resolverse mediante la aplicaci√≥n de m√©todos exhaustivos como la prueba y error.</p>
<p>A modo de ejemplo simplificado, ser√≠a encontrar el logaritmo discreto de <code>base 2</code> para el n√∫mero <code>5</code> <code>m√≥dulo 11</code>. Esto implica encontrar el valor de <code>x</code> en la ecuaci√≥n <code>2À£ ‚â° 5 (mod 11).</code></p>
<p>Realizando los c√°lculos paso a paso:</p>
<ul>
<li>2¬π ‚â° 2 (mod 11)</li>
<li>2¬≤ ‚â° 4 (mod 11)</li>
<li>2¬≥ ‚â° 8 (mod 11)</li>
<li>2‚Å¥ ‚â° 5 (mod 11)</li>
</ul>
<p>Entonces, el valor de <code>x</code> que satisface la ecuaci√≥n <code>2À£ ‚â° 5 (mod 11)</code> es <code>x = 4</code>.</p>
<h2 id="ecdlp"><a class="header" href="#ecdlp">ECDLP</a></h2>
<p>La seguridad de esquemas criptogr√°ficos basados en <strong>ECC</strong>, como <strong>ECDSA</strong>, se basa en la dificultad de resoluci√≥n del problema del logaritmo discreto de curva el√≠ptica o <strong>ECDLP</strong>. Las curvas el√≠pticas son objetos matem√°ticos utilizados en criptograf√≠a de clave p√∫blica, y el <strong>ECDLP</strong> ser√≠a el problema de hallar el valor de <code>‚ÄòK‚Äô</code> en esta ecuaci√≥n, <code>P =k‚ãÖG</code>, donde <code>P</code> es un punto en la curva, <code>k</code> es el valor que debemos hallar y <code>G</code> es un punto base conocido (el generador).</p>
<p>Al igual que en el caso del <strong>DLP</strong>, el <strong>ECDLP</strong> se vuelve m√°s dif√≠cil de resolver a medida que el tama√±o de los n√∫meros involucrados en esas expresiones matem√°ticas aumentan</p>
<h2 id="ecdsa"><a class="header" href="#ecdsa">ECDSA</a></h2>
<p>Por √∫ltimo llegamos a un algoritmo ampliamente utilizado y conocido como es el <strong>ECDSA</strong>, que se utiliza com√∫nmente en blockchain. La clave p√∫blica se obtiene multiplicando un punto base conocido (llamado generador) en la curva el√≠ptica por un entero, que representa la llave privada. El desaf√≠o radica en encontrar ese valor privado a partir del punto p√∫blico conocido en la curva.</p>
<p>La curva el√≠ptica <strong>secp256k1</strong> est√° definida por la ecuaci√≥n: <code>y¬≤ = x¬≥ + ax + b</code> sobre <code>ùîΩp</code> donde <code>p</code> es un n√∫mero primo grande.</p>
<p>El algoritmo de Shor, en su versi√≥n completa y ejecutado en un computador cu√°ntico lo suficientemente grande y estable, podr√≠a factorizar el n√∫mero primo <code>p</code> en esta ecuaci√≥n, lo que proporcionar√≠a informaci√≥n sobre el orden del subgrupo c√≠clico relacionado con la curva.</p>
<p>Si se pudiera determinar el orden del subgrupo c√≠clico relacionado con la curva <code>secp256k1</code> utilizando el algoritmo de <strong>Shor</strong>, ser√≠a posible encontrar el valor privado a partir de la clave p√∫blica. Esto comprometer√≠a la seguridad de <strong>ECDSA</strong>, ya que la clave privada es fundamental para generar firmas digitales y autenticar transacciones. Es importante destacar que el algoritmo de Shor plantea un desaf√≠o para los sistemas criptogr√°ficos actuales basados en la factorizaci√≥n de n√∫meros enteros o en el logaritmo discreto, como <strong>RSA</strong> y <strong>ECDSA</strong>.</p>
<p>No obstante, la implementaci√≥n pr√°ctica de un algoritmo cu√°ntico capaz de realizar estos c√°lculos, como los mencionados ejemplos, todav√≠a se encuentra en desarrollo y no representa una amenaza inmediata para los sistemas criptogr√°ficos utilizados en la actualidad. La investigaci√≥n y el desarrollo continuo en criptograf√≠a pos-cu√°ntica son fundamentales para garantizar la seguridad en un entorno tecnol√≥gico en constante evoluci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptograf√≠a-basada-en-lattice-previene-shor"><a class="header" href="#criptograf√≠a-basada-en-lattice-previene-shor">Criptograf√≠a basada en Lattice previene Shor</a></h2>
<p>Ahora deberemos aprender c√≥mo una verificaci√≥n de esquemas de firmas puede ser lo suficientemente fuerte para prevenirnos contra un posible ataque ejecutado con el algoritmo de Shor, la criptograf√≠a basada en ret√≠culos <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_basada_en_ret%C3%ADculos"><strong>(Lattice)</strong></a>, es una forma segura de protegerse frente a muchos algoritmos.</p>
<p>Pensemos en un <a href="https://es.wikipedia.org/wiki/Red_(grupo)">ret√≠culo</a>, como una estructura matem√°tica que se forma mediante una red de puntos en un espacio n-dimensional. Es similar a una cuadr√≠cula o una rejilla en dos dimensiones, pero se extiende a cualquier n√∫mero de dimensiones. Cada punto en el ret√≠culo est√° ubicado en una posici√≥n determinada y est√° conectado a los puntos vecinos por l√≠neas rectas de igual longitud.</p>
<p>En el contexto de la criptograf√≠a basada en ret√≠culos, se utilizan ret√≠culos en <a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_n%C3%BAmeros">teor√≠a de n√∫meros</a> para construir sistemas criptogr√°ficos. Estos ret√≠culos se definen mediante un conjunto de vectores base, que son combinaciones lineales de vectores de coordenadas con coeficientes enteros. Los ret√≠culos tienen propiedades matem√°ticas interesantes, como la propiedad de ser densos y uniformes en el espacio.</p>
<p>Los problemas computacionales basados en ret√≠culos, como el problema de la aproximaci√≥n m√°s cercana en ret√≠culos o el problema del vector corto m√°s cercano, se utilizan en criptograf√≠a para establecer la seguridad de los esquemas basados en ret√≠culos. Estos problemas son dif√≠ciles de resolver y se cree que no existen algoritmos eficientes para resolverlos en el caso general, lo que brinda seguridad a los sistemas criptogr√°ficos basados en ret√≠culos.</p>
<p>La criptograf√≠a basada en ret√≠culos es el t√©rmino gen√©rico para las construcciones de primitivas criptogr√°ficas que involucran ret√≠culos, ya sea en la construcci√≥n misma o en la prueba de seguridad.</p>
<p><strong>Las construcciones basadas en ret√≠culos son actualmente candidatas importantes para la criptograf√≠a post-cu√°ntica.</strong> A diferencia de los esquemas de clave p√∫blica m√°s ampliamente utilizados y conocidos, como RSA, Diffie-Hellman o los criptosistemas de curva el√≠ptica, que te√≥ricamente podr√≠an ser derrotados utilizando el algoritmo de Shor en un computador cu√°ntico, algunas construcciones basadas en ret√≠culos parecen ser resistentes a los ataques tanto de computadoras cl√°sicas como cu√°nticas. Adem√°s, muchas construcciones basadas en ret√≠culos se consideran seguras bajo la suposici√≥n de que ciertos problemas computacionales bien estudiados en ret√≠culos no pueden ser resueltos.</p>
<p>Aqu√≠ hay una breve explicaci√≥n de las diferencias entre los esquemas de criptograf√≠a basados en ret√≠culos en t√©rminos de encriptaci√≥n, funciones hash y intercambio de claves:</p>
<ol>
<li><strong>Encriptaci√≥n basada en ret√≠culos:</strong> los esquemas de encriptaci√≥n basados en ret√≠culos aprovechan las propiedades matem√°ticas de los ret√≠culos para proporcionar seguridad en la comunicaci√≥n.</li>
<li><strong>Funciones hash basadas en ret√≠culos:</strong> las funciones hash basadas en ret√≠culos utilizan ret√≠culos y operaciones matem√°ticas relacionadas para calcular los hashes y se utilizan en diversas aplicaciones criptogr√°ficas, como la integridad de datos y la firma digital.</li>
<li><strong>Intercambio de claves basado en ret√≠culos:</strong> el intercambio de claves basado en ret√≠culos como el <a href="https://newhopecrypto.org/">(Intercambio NewHope Protocol)</a> implica el establecimiento de una clave compartida entre dos o m√°s partes que desean comunicarse de manera segura. Los protocolos de intercambio de claves basados en ret√≠culos utilizan los ret√≠culos y los problemas computacionales relacionados con ellos para garantizar que las partes puedan acordar una clave sin que un tercero pueda determinarla. Estos esquemas se basan en la dificultad de resolver ciertos problemas matem√°ticos relacionados con los ret√≠culos para asegurar la confidencialidad de la clave compartida.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kyber-crystal"><a class="header" href="#kyber-crystal">Kyber Crystal</a></h1>
<p>En el √∫ltimo estudio post-quantum veremos <a href="https://pq-crystals.org/kyber/resources.shtml"><strong>Kyber</strong></a>, antes de entrar dentro del ecosistema de Starkware y aprender c√≥mo se generan los contratos de cuentas, as√≠ como las caracter√≠sticas criptogr√°ficas y matem√°ticas detr√°s de las STARKs.</p>
<p>Kyber es un m√©todo de encapsulaci√≥n de clave <a href="https://en.wikipedia.org/wiki/Key_encapsulation">(KEM)</a> dise√±ado para resistir ataques criptoanal√≠ticos realizados por futuras computadoras cu√°nticas poderosas. Se utiliza para establecer un secreto compartido entre dos partes que se comunican, sin que un atacante <a href="https://en.wikipedia.org/wiki/Ciphertext_indistinguishability">(IND-CCA2)</a> en el sistema de transmisi√≥n pueda descifrarlo. Este criptosistema asim√©trico utiliza una variante del problema de redes de aprendizaje con errores <a href="https://en.wikipedia.org/wiki/Learning_with_errors">(learning with errors, LWE)</a> como su <a href="https://en.wikipedia.org/wiki/Trapdoor_function">funci√≥n b√°sica con trampa</a>. Gan√≥ la competencia del NIST para el primer est√°ndar de criptograf√≠a PQ.</p>
<p>La generaci√≥n de claves en Kyber no se basa en la factorizaci√≥n de enteros o en problemas relacionados con las curvas el√≠pticas, sino que utiliza el problema de aprendizaje con errores en ret√≠culos como base para la seguridad del algoritmo.</p>
<p>El sistema se basa en el aprendizaje con errores en m√≥dulos (M-LWE) del campo del aprendizaje autom√°tico, en conjunto con anillos ciclot√≥micos. Recientemente, tambi√©n se ha logrado una reducci√≥n formal matem√°tica estrecha de la problem√°tica del anillo LWE al MLWE. <strong>En comparaci√≥n con otros m√©todos de criptograf√≠a post-cu√°ntica, tiene las ventajas t√≠picas de los m√©todos basados en ret√≠culos, como el tiempo de ejecuci√≥n, el tama√±o de los textos cifrados y el material clave.</strong></p>
<p>En cuanto a los par√°metros, Kyber proporciona diferentes conjuntos para alcanzar diferentes niveles de seguridad. Por ejemplo, <code>Kyber-512</code> tiene una seguridad aproximada equivalente a <code>AES-128</code>, <code>Kyber-768</code> tiene una seguridad aproximada equivalente a <code>AES-192</code> y <code>Kyber-1024</code> tiene una seguridad aproximada equivalente a <code>AES-256</code>.</p>
<p>En resumen, Kyber utiliza un enfoque matem√°tico diferente a ECDSA en la generaci√≥n de claves. Se basa en el problema de aprendizaje con errores en ret√≠culos y en la selecci√≥n adecuada de par√°metros de seguridad. La seguridad de Kyber radica en la dificultad de resolver problemas criptogr√°ficos espec√≠ficos asociados a ese enfoque matem√°tico.</p>
<p>Con esto hemos concluido las bases criptogr√°ficas que nos han brindado los detalles de c√≥mo se generan los distintos tipos de criptograf√≠a sim√©trica o asim√©trica, as√≠ como las funciones hash y su importancia en la seguridad. Nos adentramos en c√≥mo se integraban en los Merkle Tree o Patricia Trie, para luego explorar el √°mbito de la computaci√≥n cu√°ntica y ver c√≥mo se pod√≠an resolver algunos de los problemas planteados por ciertas criptograf√≠as. Tambi√©n destacamos la importancia de las firmas y las verificaciones de firmas en los avances de la tecnolog√≠a de la computaci√≥n cu√°ntica.</p>
<p>La computaci√≥n cu√°ntica se mostr√≥ resistente a las bases sim√©tricas de una llave maestra o a las funciones hash en s√≠. Adem√°s, presenciamos avances en la prevenci√≥n de ataques cu√°nticos y en algoritmos cu√°nticos como Lattice o encapsulamientos por Kyber. Con estos avances en mente, es hora de pasar a ver las EOA (Externally Owned Accounts) y los firmantes en Ethereum, para luego diferenciarlos de la Account Abstraction nativa en Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eoa-y-aa---firmantes"><a class="header" href="#eoa-y-aa---firmantes">EOA y AA - Firmantes</a></h1>
<p>Las cuentas de EOA <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>(Externally Owned Accounts)</strong></a> en Ethereum, al igual que muchas otras criptomonedas, utilizan el algoritmo ECDSA que aprendimos antes para generar claves y firmar transacciones digitalmente. Esto les permite participar de manera segura en la red y realizar operaciones. Las EOA son cuentas que pertenecen a usuarios externos a la cadena de bloques.</p>
<p>En Ethereum, el estado de una cuenta solo puede ser modificado a trav√©s de transacciones, las cuales deben ser iniciadas por una EOA. sin embargo, no cualquier persona puede activar una transacci√≥n desde cualquier EOA, aqu√≠ es donde entra en juego el concepto de firmante.</p>
<p>Cada cuenta en Ethereum est√° asociada con un objeto criptogr√°fico llamado keypair, como aprendimos antes.</p>
<p>La clave privada, se utiliza para firmar mensajes digitales, mientras que la clave p√∫blica permite que cualquiera pueda verificar que una firma en particular fue generada por la clave privada correspondiente.</p>
<p>La asociaci√≥n entre una cuenta y un firmante se realiza mediante la direcci√≥n de la cuenta. La direcci√≥n de un EOA se deriva de la clave p√∫blica del firmante, espec√≠ficamente, <strong>la direcci√≥n se obtiene tomando los √∫ltimos 20 bytes del hash Keccak-256 de la clave p√∫blica.</strong></p>
<p>El propietario de una cuenta puede autorizar una transacci√≥n desde su cuenta firmando los par√°metros de la transacci√≥n con la clave privada correspondiente.</p>
<p>La <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>curva el√≠ptica secp256k1</strong></a>  es una de las curvas el√≠pticas m√°s utilizadas en criptograf√≠a, especialmente en el contexto de criptomonedas como Bitcoin o Ethereum. Esto ha permitido establecer esquemas de firmas digitales que garantizan la integridad de las transacciones al asegurar la autenticidad de las claves.</p>
<p>La abstracci√≥n de firma y clave privada es una propiedad presente en algunos sistemas criptogr√°ficos, como ciertos esquemas de firmas digitales basados en identidad. Sin embargo, en el caso del algoritmo ECDSA utilizado en Ethereum y muchas otras blockchain, la firma est√° inherentemente vinculada a la clave privada de la cuenta y no es posible separarlas o abstraerlas, como podr√≠a ser el caso en otros esquemas dise√±ados con estos principios.</p>
<p>Ahora que ya hemos adquirido los conceptos b√°sicos y hemos prestado atenci√≥n para adquirir la formaci√≥n adecuada y avanzada, podemos sumergirnos en el apasionante ecosistema de StarkWare, Starknet, StarkEx y STARKs. Nuestra mente est√° mejor preparada para embarcarnos en el viaje que nos espera en el resto del documento y en las futuras series.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starknet-aa"><a class="header" href="#starknet-aa">Starknet AA</a></h2>
<p>Esperamos que haya disfrutado de la primera parte, donde se presentaron conceptos generales de criptograf√≠a. Ahora nos adentraremos en un tema a√∫n m√°s interesante, <a href="https://www.starknet.io/en"><strong>Starknet</strong></a> y c√≥mo mejora el ecosistema, exploraremos c√≥mo los contratos de cuentas (CA) y el esquema de firmas abstra√≠das de Starknet ofrecen beneficios significativos frente al <a href="https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a">ERC-4337</a>.</p>
<p><em>Si deseas aprender m√°s sobre el concepto y las variantes del ERC-4337, te recomendamos leer esta serie de art√≠culos en el blog de <a href="https://www.argent.xyz/argent-x/">Argent</a>. La serie est√° compuesta por la <a href="https://www.argent.xyz/blog/wtf-is-account-abstraction/">Parte 1</a>, <a href="https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/">Parte 2</a> y <a href="https://www.argent.xyz/blog/part-3-wtf-is-account-abstraction/">Parte 3</a>. Argent y <a href="https://braavos.app/">Braavos</a> son Smart wallets que aprovechan el poder del AA nativo en Starknet. Tambi√©n te recomendamos leer los art√≠culos de Braavos de <a href="https://braavos.app/account-abstraction-ethereum-comprehensive-guide/">Guide 101 AA</a> y <a href="https://braavos.app/account-abstraction-security-pyramid/">Security Pyramid AA</a>, los cuales presentan optimizaciones adicionales y capas de seguridad que exploraremos m√°s adelante. Estos recursos te proporcionar√°n una mejor comprensi√≥n del concepto de <strong>AA</strong> y del <strong>ERC-4337</strong>.</em></p>
<p><strong>¬°As√≠ que sin m√°s pre√°mbulos, bienvenidos a Starknet!</strong></p>
<p>En el ecosistema de Starknet, se encuentran diversas metodolog√≠as para generar claves y firmas. A diferencia de las cuentas EOA, en Starknet se emplea <strong>Account Abstraction</strong> <a href="https://book.starknet.io/chapter_5/index.html"><strong>(AA)</strong></a> para la implementaci√≥n de <strong>Contract Accounts</strong> <a href="https://book.starknet.io/chapter_5/index.html#ethereums_current_account_system_a_closer_look">(CA)</a>. Estos contratos son responsables de establecer la l√≥gica en nuestras cuentas dentro de Starknet, incluyendo la validaci√≥n del esquema de firma abstra√≠do.</p>
<p>En lugar de utilizar ECDSA, Starknet utiliza una variaci√≥n llamada [<strong>STARK Curve</strong>], un tipo de curva el√≠ptica m√°s amigable y optimizada que es nativa en el ecosistema, esta variante nos ofrece mejoras y caracter√≠sticas espec√≠ficas para las necesidades de Starknet.</p>
<p>Lo grandioso de tener esta abstracci√≥n nativa es que permite a√±adir diferentes l√≥gicas en tus esquemas o capas adicionales. Normalmente, se utiliza un sistema asim√©trico usando la curva el√≠ptica <code>secp256k1</code>, basado en la pseudoaleatoriedad y diversas operaciones matem√°ticas utilizando dicha curva, para generar claves privadas y p√∫blicas. Sin embargo, tambi√©n se pueden a√±adir curvas adicionales de forma nativa al crear un CA, como lo ha hecho Braavos con la <a href="https://github.com/myBraavos/efficient-secp256r1">secp256r1</a>. Esta curva cuenta con un sistema de firmas integrado, mejor optimizado y preparado para dispositivos modernos, donde el signer puede almacenar los datos habilitados por biometricidad en dispositivos aislados y seguros, como el m√≥dulo &quot;Enclave&quot; de Apple.</p>
<p>La AA desempe√±a un papel crucial al abstraer el esquema de firmas o verificaci√≥n de firmas de la ejecuci√≥n. Como vimos anteriormente, podemos generar una clave privada y mediante ECDSA generar una clave p√∫blica. En este caso el poseedor de esta clave privada y del esquema de firma asociado tiene el poder de realizar transacciones en Starknet, los <a href="https://book.starknet.io/chapter_8/transactions.html">dos tipos de transacciones</a> son <code>DEPLOY</code> o <code>INVOKE</code>.</p>
<p><img src="./assets/Invoke.png" alt="graph" /></p>
<div align="center">
<em>Contrato de Cuenta de usuario</em>
</div>
<p>Con AA podemos modificar estas firmas o curvas. Por ejemplo, la curva <code>Secp256r1</code>, vimos que ofrece una seguridad adicional en Braavos al configurar una firma biom√©trica en el m√≥dulo de seguridad del enclave. De esta manera, esta firma biom√©trica solo puede ser a√±adida gracias a AA.</p>
<p>Todo esto es posible gracias al lenguaje de programaci√≥n utilizado en la implementaci√≥n, el poderoso <a href="https://starkware.co/cairo/"><strong>Cairo</strong></a>, as√≠ que analicemos c√≥mo Cairo incorpora esta abstracci√≥n en su programaci√≥n.</p>
<p>En primer lugar, se necesita validar la firma y comprobar que coincide con la generada mediante ECDSA antes de proceder a la ejecuci√≥n. Estas dos funciones principales son <code>validate</code> y <code>execute</code>. Adem√°s, <code>execute</code> tambi√©n puede realizar m√∫ltiples llamadas utilizando <code>execute_calls</code>.</p>
<p><img src="./assets/invoke_execute.gif" alt="graph" /></p>
<div align="center">
<em>Informaci√≥n de la L√≥gica separada de las funciones validate, execute</em>
</div>
<p>Ahora analicemos c√≥mo Cairo incorpora esta abstracci√≥n en su programaci√≥n.</p>
<p>Veamos c√≥mo funciona un ciclo de transacci√≥n con AA nativa y c√≥mo se representa gr√°ficamente este ciclo completo de firmas para detectar si es correcto y realizar la operaci√≥n.</p>
<p>Tambi√©n pensemos en c√≥mo se podr√≠an combinar de manera eficiente firmas como ha realizado Braavos con la EC <code>secp256r1</code> o incluso realizar la verificaci√≥n de firmas, como vimos con Lattice para prevenir ataques cu√°nticos.</p>
<p><img src="./assets/transaccion.gif" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validaci√≥n de una trnasacci√≥n</em>
</div>
<p>Los conocimientos previos adquiridos nos han ense√±ado muchas cosas, una de ellas es c√≥mo el algoritmo de Shor puede te√≥ricamente romper ECDSA, pero no podr√° romper una prueba STARK. </p>
<p>En la secci√≥n de generaci√≥n de STARKs, aprenderemos como gracias a sus bases de criptograf√≠a sim√©trica y otras variables, si alguien nos roba, hackea o perdemos la cuenta, el esquema <strong>PQS</strong> para la prueba no ser√° de mucha utilidad, ya que no se ha alterado la integridad del estado de los datos, sino que por oun te√≥rico ataque criptoanal√≠tico se habr√° obtenido tu PK, lo que permitir√≠a mover los fondos de forma justa.</p>
<p><strong>Pero, ¬øqu√© suceder√≠a si tuvi√©ramos un esquema de verificaci√≥n de firmas seguro frente a un ataque cu√°ntico?</strong></p>
<p>Aqu√≠ es donde entran en juego peque√±os cambios, espec√≠ficamente en la parte de validaci√≥n y no de ejecuci√≥n, con las mejoras en Starknet y con la ayuda de AA nativo, est√° implementando para prepararse para el futuro. Una posibilidad ser√≠a el uso de Lattice o Kyber, aunque el futuro no est√° escrito, as√≠ que ha llegado el momento de ver c√≥mo se genera la parte de la EC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-en-cairo---stark-curve"><a class="header" href="#ec-en-cairo---stark-curve">EC en Cairo - STARK Curve</a></h1>
<p>Como hemos visto en el contexto de los sistemas criptogr√°ficos, la elecci√≥n de la curva el√≠ptica adecuada es de suma importancia. En este caso, se utiliza una variante de EC la cual ha sido especialmente dise√±ada y optimizada para su aplicaci√≥n en el entorno de Starknet.</p>
<p>La STARK Curve <a href="https://github.com/starkware-libs/cairo-lang/blob/361fe32d5930db340ea78fe05aedfe706f6c9405/src/starkware/cairo/common/ec.cairo"><strong>(EC.cairo)</strong></a> se define mediante la ecuaci√≥n:</p>
<p><img src="./assets/stark_curve.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Los valores espec√≠ficos de <code>Œ±</code>, <code>Œ≤</code> y <code>p</code> utilizados en esta curva han sido cuidadosamente seleccionados para proporcionar propiedades criptogr√°ficas s√≥lidas y un rendimiento eficiente en el contexto de los contratos de cuenta nativos en Starknet.</p>
<p>En particular, los valores de <code>Œ±</code>, <code>Œ≤</code> (notese que es <code>œÄ</code> ‚ÄúPI‚Äù sin decimales usando 67 digitos) y <code>p</code> son los siguientes:</p>
<p><img src="./assets/stark_curve1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Estos valores aseguran que la curva el√≠ptica Stark-friendly cumple con los requisitos de seguridad necesarios para su aplicaci√≥n en sistemas criptogr√°ficos.</p>
<p>Adem√°s se utiliza un punto generador <a href="https://docs.starkware.co/starkex/crypto/stark-curve.html">(G)</a> espec√≠fico asociado a esta curva. El punto generador <code>G</code> se define como:</p>
<p><img src="./assets/stark_curve_g.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Este punto generador desempe√±a un papel fundamental en el esquema de firmas digitales ECDSA, permitiendo la generaci√≥n de claves p√∫blicas, como aprendimos al momento de hablar del Generador de Claves.</p>
<p>La elecci√≥n de la curva el√≠ptica Stark-friendly y el punto generador <code>G</code> asociado a ella proporcionan una base s√≥lida y optimizada para la implementaci√≥n de esquemas criptogr√°ficos en el entorno de Starknet. Estos elementos garantizan la seguridad y eficiencia necesarias para la creaci√≥n de contratos de cuenta nativos y la verificaci√≥n de firmas digitales en el sistema.</p>
<p>Si desea probar y adentrarse en el despliegue de cuentas en Starknet, o si est√° interesado en aprender c√≥mo se generan y calculan off-chain, y luego financiar esas cuentas para que los contratos de cuenta se autodesplieguen, le animamos a seguir los ejercicios oficiales de <a href="https://github.com/starknet-edu/starknet-accounts/blob/answers/ES%20README.md"><strong>Starknet-Edu Account</strong></a> o las <a href="https://github.com/Nadai2010/Nadai-StarknetEs-Guia-Cairo1#configuraci%C3%B3n-de-una-cuenta"><strong>Gu√≠as Completas Cairo 1</strong></a> proporcionadas por <a href="https://twitter.com/StarkNetEs">Starknet-Es</a> para realizar pruebas reales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-braavos---secp256r1"><a class="header" href="#my-braavos---secp256r1">My Braavos - Secp256r1</a></h1>
<p>Empecemos con un dato que no hab√≠amos comentando antes, la <code>k</code> en <code>sepc256k1</code> significa <a href="https://es.wikipedia.org/wiki/Neal_Koblitz"><strong>Koblitz</strong></a>¬†y el <code>r</code> en <code>sepc256r1</code> significa random.</p>
<p>Braavos ha incorporado la firma y validaci√≥n de transacciones utilizando <code>secp256r1</code>, lo que brinda una excelente experiencia al usuario final al permitir transacciones con firma biom√©trica en el dispositivo del usuario. Esto a√±ade un nivel adicional de seguridad. Braavos ha presentado en su blog una <a href="https://braavos.app/account-abstraction-security-pyramid/">Pir√°mide de Seguridad AA</a>.</p>
<p><img src="./assets/Mybraavos.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Podemos ver en la c√∫spide de la pir√°mide al Multi-Signer (3FA). El Multi-Signer combina la protecci√≥n de la frase de recuperaci√≥n (seed phrase) en la extensi√≥n del navegador y el Hardware Signer o Protected Signer utilizando el dispositivo m√≥vil.</p>
<p>Ahora se requieren dos firmas de dos claves diferentes para ejecutar la transacci√≥n en la cadena, obteniendo una autenticaci√≥n de 3FA:</p>
<ul>
<li><strong>Algo que sabemos:</strong> la clave derivada de tu frase de recuperaci√≥n en la extensi√≥n del navegador.</li>
<li><strong>Algo que tenemos:</strong> tu dispositivo m√≥vil.</li>
<li><strong>Algo que somos:</strong> tu huella dactilar o identificaci√≥n biom√©trica facial.</li>
</ul>
<p>Cabe destacar que aunque se ha agregado otro firmante, no se ha a√±adido otra seed phrase, esto tambi√©n tiene el beneficio adicional de alejarse de las seed phrase a una mejor seguridad en los dispositivos m√≥viles/computadoras port√°tiles modernas, y seguridad superior cuando el dispositivo del usuario admite un chip de seguridad dedicado, como el <a href="https://cloud.google.com/blog/products/identity-security/titan-in-depth-security-in-plaintext">elemento seguro Titan de Android</a> o <a href="https://support.apple.com/es-us/guide/security/sec59b0b31ff/web">Enclave Secure de Apple</a>, etc.</p>
<p>Este chip Secure Enclave/Titan es un subsistema dedicado y aislado, totalmente separado del procesador de aplicaciones que puede generar claves privadas y mensajes de signo. Genera las teclas utilizando un generador interno de n√∫meros aleatorios verdaderos <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator"><strong>(TRNG)</strong></a> y firma mensajes a trav√©s de la curva el√≠ptica <code>secp256r1</code> a trav√©s de su acelerador interno de claves p√∫blicas <a href="https://www.rambus.com/security/crypto-accelerator-cores/pka-ip-28/"><strong>(PKA)</strong></a>. Las claves privadas nunca abandonan el sistema seguro y son desconocidas / inaccesibles para cualquier persona, ni siquiera para el usuario o para la aplicaci√≥n en s√≠.</p>
<p>Esto significa que incluso si el n√∫cleo del procesador de la aplicaci√≥n del dispositivo se ve comprometido, <strong>¬°Nuestras claves se mantendr√°n seguras!</strong></p>
<p><img src="./assets/Enclave.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Vemos que esta implementaci√≥n de la firma ECDSA <code>secp256r1</code> en Cairo no es nativa, lo que significa que no tiene un Builtin dedicado nativo, esto puede llevar a un alto costo de gas al validar la firma. Sin embargo, Braavos es uno de los que han adoptado esta maravillosa novedad y est√° trabajando en mejorar la eficiencia de este proceso.</p>
<p>Adem√°s, aprovechando la funcionalidad de Multi-Call incorporada, los usuarios pueden agrupar m√∫ltiples transacciones en una √∫nica transacci√≥n at√≥mica. Esto no solo acelera y reduce los costos de las transacciones, sino que tambi√©n permite a los usuarios aprobar la cantidad exacta que desean depositar, lo cual mejora la seguridad al eliminar la necesidad de <a href="https://hackernoon.com/erc20-infinite-approval-a-battle-between-convenience-and-security-lk60350r">aprobaci√≥n infinita</a></p>
<p>En cuanto a la <strong>gesti√≥n de firmantes</strong>, cuando se a√±ade un firmante adicional, como un Hardware Signer o Protected Signer, el firmante original basado en semillas ya no puede firmar transacciones, a menos que se solicite la eliminaci√≥n del firmante adicional y se regrese al firmante basado en semillas. <strong>Esta solicitud tiene un retraso de tiempo (actualmente de 4 d√≠as)</strong> para su procesamiento.</p>
<p>Por otro lado, la funci√≥n de multifirma permite configurar la cuenta en modo de multifirma (actualmente admite 2 de 2), lo que significa que ninguna transacci√≥n se ejecutar√° hasta que los 2 firmantes definidos en la cuenta firmen la transacci√≥n. La seed phrase puede solicitar la desactivaci√≥n de la multifirma, pero esto <strong>tambi√©n tiene un retraso de tiempo (actualmente 4 d√≠as)</strong> antes de que se haga efectiva.</p>
<p>Vemos la importancia de las firmas y como vimos en el contexto del PQS, entendemos la relevancia de poder modificar nuestros esquemas de verificaci√≥n de firmas, como la utilizaci√≥n de Lattice o Kyber, por ejemplo. Ahora, centr√©monos en aprender c√≥mo creamos una Stark Key para StarkEx, el motor de escalabilidad de Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creaci√≥n-de-una-stark-key-en-starkex"><a class="header" href="#creaci√≥n-de-una-stark-key-en-starkex">Creaci√≥n de una Stark Key en StarkEx</a></h1>
<p>Es importante comprender c√≥mo <a href="https://mirror.xyz/dashboard/edit/KJVQJ6X6wvbf6ps1oy96zpE3TztWyhSIDZd2IHu5NuI">StarkEx</a> se comunica con otras billeteras en t√©rminos de firmas, y c√≥mo mantiene todo el motor de transacciones y pruebas STARKs en su interior.</p>
<p>StarkEx ofrece soluciones altamente especializadas para diferentes aplicaciones que deseen construir sobre su servicio, y esto es parte de lo que StarkWare, como compa√±√≠a, proporciona a grandes empresas o cualquier otra entidad que desee aprovechar su conjunto de profesionales y servicios adaptables.</p>
<p>Aplicaciones populares como Sorare, Rhino y Apex Pro, por ejemplo, aprovechan las soluciones ofrecidas por StarkWare. Estas aplicaciones espec√≠ficas se construyen sobre el marco de Starknet. Si bien no profundizaremos en los detalles espec√≠ficos de estas aplicaciones aqu√≠, se recomienda visitar la <a href="https://layer2es.notion.site/39d63a8af9ca4524a7237b1f2456e745">Biblioteca de Layer 2 en Espa√±ol</a> para obtener informaci√≥n m√°s detallada sobre cada una de ellas y comprender mejor c√≥mo se integran en las soluciones de escalado de capa 2 de Ethereum.</p>
<p>Para utilizar StarkEx y asociar tu cuenta de MetaMask u otra billetera a Starknet, es necesario crear una Stark Key. StarkEx admite diferentes tipos de billeteras y m√©todos para crear esta clave, dependiendo de c√≥mo se utilizar√° posteriormente. A continuaci√≥n, se detallan las opciones disponibles:</p>
<h2 id="billeteras-compatibles-con-bip32"><a class="header" href="#billeteras-compatibles-con-bip32">Billeteras compatibles con BIP32</a></h2>
<p>Si est√°s utilizando una billetera compatible con <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki"><strong>BIP32</strong></a>, como Ledger, se recomienda seguir el EIP-2645. Este est√°ndar describe una ruta denominada <code>starkPath</code> y un algoritmo de derivaci√≥n de clave que utiliza esta ruta para obtener la <code>starkPrivateKey</code>.</p>
<p>La <code>starkPath</code> est√° compuesta por cuatro par√°metros pasados y dos par√°metros internos, y sigue la siguiente estructura:</p>
<p><code>m/purpose'/layer'/application'/ethAddress1'/ethAddress2'/index</code></p>
<p>Los par√°metros externos pasados son los siguientes:</p>
<ul>
<li><strong>Purpose:</strong> el n√∫mero de EIP correspondiente (en este caso, 2645).</li>
<li><strong>Layer:</strong> se utiliza para diferenciar entre tecnolog√≠as y se calcula como <code>sha256(layer) &amp; ((1 &lt;&lt; 31) - 1))</code>. En el contexto de StarkEx, el valor es <code>579218131</code> seg√∫n lo descrito en el EIP-2645.</li>
<li><strong>Application:</strong> sirve para diferenciar entre aplicaciones y se calcula como: <code>sha256(application_name) &amp; ((1 &lt;&lt; 31) - 1))</code>.</li>
<li><strong>Index:</strong> permite tener m√∫ltiples claves por direcci√≥n de Ethereum.</li>
</ul>
<p>Los par√°metros internos usados son los siguientes:</p>
<ul>
<li><strong>ethAddress1:</strong> Los 31 LSB de la direcci√≥n Ethereum del usuario, es decir, <code>(ethAddress &amp; 1 &lt;&lt; 31) - 1</code></li>
<li><strong>ethAddress2:</strong> Los 31 LSB siguientes de la direcci√≥n Ethereum del usuario, es decir, <code>(ethAddress &gt;&gt; 31) &amp; 1 &lt;&lt; 31) - </code>.</li>
</ul>
<p>Adem√°s, es importante que las billeteras compatibles con BIP32 mantengan un estado persistente en relaci√≥n con su propia direcci√≥n de Ethereum.</p>
<h2 id="billeteras-no-compatibles-con-bip32"><a class="header" href="#billeteras-no-compatibles-con-bip32">Billeteras NO compatibles con BIP32</a></h2>
<p>Si est√°s utilizando una billetera que no es compatible con BIP32, como MetaMask, se recomienda seguir el siguiente proceso:</p>
<ol>
<li>El usuario firma un mensaje utilizando su clave privada de Ethereum a trav√©s de MetaMask u otra billetera similar. Se recomienda utilizar el est√°ndar  IP-712 para brindar transparencia al usuario durante el proceso de firma. Es importante que el mensaje incluya una advertencia, indicando al usuario que so1lo debe firmarlo si proviene de un dominio espec√≠fico.</li>
<li>La firma <code>(r, s, v)</code> se utiliza como entrada para el algoritmo de derivaci√≥n de clave, que generar√° la <code>starkPrivateKey</code>. Para realizar este c√°lculo, puedes utilizar la biblioteca <a href="https://www.npmjs.com/package/@starkware-industries/starkware-crypto-utils">StarkEx Crypto SDK</a>. Primero, llama a la funci√≥n <code>getPrivateKeyFromEthSignature</code> para obtener la clave privada a partir de la firma, y luego utiliza la funci√≥n <code>privateToStarkKey</code> para calcular la <code>StarkKey</code>.</li>
</ol>
<p>Al seguir estos pasos, podr√°s crear una Stark Key asociada a tu cuenta de MetaMask u otra billetera compatible. Esta clave te permitir√° interactuar con StarkEx y otras aplicaciones dentro del ecosistema de Starknet, realizar transacciones seguras y aprovechar las funcionalidades ofrecidas por esta plataforma.</p>
<p><img src="./assets/Stark_Key.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-y-funciones-hash"><a class="header" href="#starknet-y-funciones-hash">Starknet y Funciones Hash</a></h1>
<p>Hemos visto la importancia de las firmas, el poder de AA y la asociaci√≥n de los hash dentro del ecosistema de Starknet y StarkEx. Ahora, profundicemos en c√≥mo se utilizan y los diferentes tipos de hash que podemos encontrar.</p>
<h2 id="dominio-y-rango"><a class="header" href="#dominio-y-rango">Dominio y rango</a></h2>
<p>Todas las salidas de las funciones de hash se mapean eventualmente a elementos en <code>ùîΩ‚Çö</code> con <code>p = 2¬≤‚Åµ¬π + 17 ‚ãÖ 2¬π‚Åπ¬≤ + 1</code> como vimos en la Stark Curve.</p>
<p>Las funciones hash son componentes clave en las especificaciones de Starknet, y se utilizan para mapear las salidas de los c√°lculos a elementos en el campo finito <code>ùîΩ‚Çö</code>. A continuaci√≥n, explicaremos las tres funciones hash utilizadas en Starknet de manera m√°s clara:</p>
<p><img src="./assets/Stark_func_hash.png" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validaci√≥n de una trnasacci√≥n</em>
</div>
<ol>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#starknet_keccak"><strong>sn_keccak:</strong></a> Esta funci√≥n hash se basa en el algoritmo KECCAK, que es una familia de funciones hash criptogr√°ficas como vimos antes. Su dominio es el conjunto de cadenas de bits compuestas por ceros y unos <code>{0,1}*</code> y su rango es el campo finito <code>ùîΩ‚Çö</code> La funci√≥n toma una cadena de bits como entrada y produce una salida en el campo finito <code>ùîΩ‚Çö</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash"><strong>Pedersen:</strong></a> La funci√≥n hash Pedersen es una funci√≥n hash computacionalmente segura que se utiliza en la construcci√≥n de criptograf√≠a de compromiso cero y otras primitivas criptogr√°ficas. Su dominio es el conjunto de pares de elementos del campo finito <code>ùîΩ¬≤p</code>, donde <code>p</code> es un n√∫mero primo, y su rango es el campo finito <code>ùîΩp</code>. La funci√≥n toma un par de elementos del campo finito <code>ùîΩ¬≤p</code> como entrada y produce una salida en el campo finito <code>ùîΩp</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#poseidon_hash"><strong>Poseidon:</strong></a> La funci√≥n hash Poseidon es una funci√≥n hash criptogr√°fica. Su dominio es un conjunto de elementos del campo finito <code>ùîΩp</code>, que incluye el cero y los elementos inversos multiplicativos, y su rango tambi√©n es el campo finito <code>ùîΩp</code>. La funci√≥n toma un conjunto de elementos del campo finito <code>ùîΩp</code> como entrada y produce una salida en el campo finito <code>ùîΩp</code>.</li>
</ol>
<p>Las funciones de hash mencionadas son a√±adidas como <a href="https://mirror.xyz/0x7D1c14939AcEE5ca141c8beDF3474AFBf3884041/RTgQnMxeVGRCczih1pGXKy2KGFcU_xmf2NMx52wDgH0"><strong>Builtin</strong></a> (AIR integradas espec√≠ficas de aplicaciones), que se utilizan como herramientas adicionales en el protocolo para garantizar la seguridad y la integridad de las transacciones y los datos.</p>
<p>Estas funciones hash desempe√±an un papel fundamental en las operaciones de Starknet al garantizar la integridad y seguridad de los c√°lculos realizados en el sistema.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak-starknet"><a class="header" href="#keccak-starknet">Keccak Starknet</a></h1>
<p>Keccak en Starknet es una implementaci√≥n espec√≠fica de la funci√≥n hash <code>Keccak256</code> adaptada para su uso en la red Starknet. Proporciona un m√©todo confiable y eficiente para calcular hashes dentro del entorno de Starknet.</p>
<p>Generalmente denotado por <code>sn_keccak</code>, se define como los primeros <strong>250 bits del hash Keccak256</strong> (esto es simplemente <code>Keccak256</code> ampliado para ajustarse a un field element ‚Äúelemento de campo‚Äù).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen-hash-starknet"><a class="header" href="#pedersen-hash-starknet">Pedersen Hash Starknet</a></h1>
<p>El <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash">Pedersen hash</a> es una funci√≥n hash criptogr√°fica utilizada en criptograf√≠a propuesta por Torben Pedersen en 1991.</p>
<p>Uno de los aspectos interesantes del <a href="https://en.wikipedia.org/wiki/Commitment_scheme">esquema de compromiso de Pedersen</a> es su propiedad homom√≥rfica, que permite realizar la adici√≥n entre dos compromisos. En otras palabras, dados dos mensajes <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code>, y sus respectivas aleatoriedades <code>r‚ÇÅ</code> y <code>r‚ÇÇ</code>, el Pedersen hash permite combinarlos de manera segura.</p>
<p>La funci√≥n Pedersen Hash utilizada en Starknet es resistente a colisiones para entradas de longitud fija, siempre y cuando la funci√≥n de codificaci√≥n subyacente sea inyectiva. Una funci√≥n inyectiva asigna elementos distintos de su dominio a elementos distintos de su codominio, esto hace que el Pedersen hash sea resistente a ciertos tipos de ataques, como colisiones y preim√°genes.</p>
<p>Sin embargo, es importante destacar que la implementaci√≥n y el contexto en el que se utilice esta funci√≥n pueden influir en su resistencia. Para obtener m√°s informaci√≥n se recomienda realizar una lectura sobre <a href="https://research.nccgroup.com/2023/03/22/breaking-pedersen-hashes-in-practice/">Pedersen hashes in Practice</a>.</p>
<p>En Starknet, se utiliza la EC amigable STARK curve sobre el campo finito <code>ùîΩ‚Çö</code> para calcular el Pedersen hash de manera eficiente y segura.</p>
<p><img src="./assets/Pedersen_Starknet.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<ul>
<li>Œ± = 1</li>
<li>Œ≤ = 31415926535897932384626433832795028841971693993751058209749 44592307816406665</li>
</ul>
<p>Los par√°metros <code>Œ±</code> y <code>Œ≤</code> de la curva son importantes en t√©rminos de seguridad y eficiencia en los algoritmos utilizados en la construcci√≥n del Pedersen hash y los protocolos de ZKP o basados en STARK.</p>
<p>Dada una entrada <code>(a, b) ‚àà ùîΩ¬≤p</code>, se divide en <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, donde la parte <code>low</code> consiste en los <strong>248 bits menos significativos del elemento</strong> y la parte <code>high</code> consiste en los <strong>4 bits m√°s significativos del elemento.</strong> El c√°lculo del Pedersen hash se define de la siguiente manera:</p>
<p><img src="./assets/Pedersen_Starknet1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En esta f√≥rmula, <code>[P]x</code> denota la coordenada <code>x</code> del punto <code>P</code>. Para calcular el hash, se realiza una combinaci√≥n lineal de los puntos <code>P0, P1, P2 y P3</code>, ponderados por los valores <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, respectivamente. Luego, se suma el punto <code>shift_point</code> y se extrae la coordenada <code>x</code> del resultado.</p>
<p>Los valores de las constantes <code>shift_point</code>, <code>P0</code>, <code>P1</code>, <code>P2</code> y <code>P3</code> se encuentran en el archivo <a href="https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/crypto/signature/fast_pedersen_hash.py">fast_pedersen_hash.py</a>. Este archivo contiene la implementaci√≥n espec√≠fica del algoritmo necesario para calcular el Pedersen hash.</p>
<p>No se trata de puntos en la EC en s√≠ misma, sino de valores espec√≠ficos que se han elegido para el c√°lculo del hash y tampoco est√°n relacionadas con la EC ni con el punto generador <code>G</code>, revise minuciosamente la informaci√≥n oficial en caso de querer hacer pruebas sobre Stark Curve o Hash en Starknet. Estas constantes se eligen de forma independiente para el c√°lculo del hash y se utilizan en combinaci√≥n con los valores de entrada para obtener el hash resultante.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon-hash-starknet"><a class="header" href="#poseidon-hash-starknet">Poseidon hash Starknet</a></h1>
<p>La funci√≥n <strong>Poseidon hash</strong> es un <a href="https://www.poseidon-hash.info/">ZK-friendly Hashing</a>, pertenece a una familia de funciones hash dise√±adas para ser muy eficientes en circuitos algebraicos. Como tal, pueden ser muy √∫tiles en sistemas ZK proof como STARKs y otros.</p>
<p>Poseidon es una construcci√≥n de esponja basada en la permutaci√≥n Hades, la estrategia de dise√±o Hades se basa en dividir el proceso en diferentes rondas para garantizar la seguridad y eficiencia del algoritmo:</p>
<ul>
<li>En las primeras rondas, denominadas <code>Rf</code>, se aplican las <code>S-boxes</code> al estado completo. Las <code>S-boxes</code> son funciones no lineales que mezclan y transforman los datos. En esta etapa inicial, se busca lograr una alta dispersi√≥n de los bits en el estado.</li>
<li>Despu√©s de estas rondas iniciales, se llevan a cabo las rondas intermedias, denominadas <code>RP</code>. En cada ronda intermedia, se aplica √∫nicamente una <code>S-box</code>, mientras que el resto del estado permanece sin cambios, es decir, se utiliza una funci√≥n identidad en lugar de las <code>S-boxes</code> faltantes. Esta simplificaci√≥n reduce el costo computacional y la complejidad del algoritmo.</li>
<li>Finalmente, en las √∫ltimas rondas, nuevamente se utilizan las <code>S-boxes</code> para el estado completo. Estas rondas finales, al igual que las rondas iniciales, permiten obtener una mezcla y transformaci√≥n adicional de los datos.</li>
</ul>
<p>Para una revisi√≥n m√°s profunda sobre su integridad en sistema de Proof pueden revisar <a href="https://eprint.iacr.org/2019/458.pdf">POSEIDON: A New Hash Function for Zero-Knowledge Proof Systems (Updated Version)</a>.</p>
<p>La versi√≥n de <strong>Poseidon</strong> utilizada en Starknet se basa en una permutaci√≥n de estado de tres elementos.</p>
<p>El campo <strong>ùîΩ</strong>, sobre el que se definen las declaraciones aritm√©ticas que utilizan Poseidon. A menudo es determinado por el sistema de prueba ZK. Lo m√°s probable es que sea un subgrupo de primer orden del grupo de puntos de una curva el√≠ptica. Poseidon mapea secuencias de elementos <strong>ùîΩ</strong> a una secuencia de longitud fija de elementos <strong>ùîΩ</strong>.</p>
<p>A continuaci√≥n, se define el <strong>Poseidon hash</strong> de hasta 2 elementos, y tambi√©n se menciona una versi√≥n que admite un n√∫mero arbitrario de entradas.</p>
<p><img src="./assets/Poseidon_Starknet.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-de-array-matrices"><a class="header" href="#hashing-de-array-matrices">Hashing de Array (matrices)</a></h1>
<p>Estas definiciones explican c√≥mo se realizan los hashing de matrices utilizando las funciones Pedersen y Poseidon en el contexto de Starknet. Estas operaciones son fundamentales para asegurar la integridad y la seguridad de los c√°lculos realizados en el sistema.</p>
<p>El hashing de un array implica aplicar la funci√≥n de hash correspondiente a cada elemento del array, de manera secuencial o iterativa. Esto permite resumir y representar de manera compacta la informaci√≥n contenida en el array, independientemente de su longitud o contenido espec√≠fico.</p>
<p>El hashing de un array es √∫til en muchas aplicaciones, como la verificaci√≥n de integridad de datos, la indexaci√≥n eficiente de informaci√≥n y la identificaci√≥n √∫nica de elementos.</p>
<h2 id="pedersen"><a class="header" href="#pedersen">Pedersen</a></h2>
<p>La funci√≥n hash Pedersen, denotada como <code>h</code>, se utiliza para calcular el hash de un array de elementos de campo. Consideremos un arreglo <code>a‚ÇÅ</code>, <code>a‚ÇÇ</code>, ..., <code>a‚Çô</code> que contiene <code>n</code> elementos. La definici√≥n de <code>h(a‚ÇÅ a‚ÇÇ, ..., a‚Çô)</code> es la siguiente:</p>
<ol>
<li>Comenzamos con un valor inicial de 0.</li>
<li>Aplicamos la funci√≥n de hash h al primer elemento a‚ÇÅ junto con el valor inicial. El resultado se convierte en el nuevo valor inicial.</li>
<li>Continuamos aplicando la funci√≥n de hash h al siguiente elemento a‚ÇÇ junto con el valor anteriormente obtenido. Nuevamente, el resultado se convierte en el nuevo valor inicial.</li>
<li>Repetimos este proceso hasta llegar al √∫ltimo elemento a‚Çô, aplicando la funci√≥n de hash en cada paso.</li>
<li>Finalmente, aplicamos la funci√≥n de hash h al √∫ltimo elemento an junto con el valor obtenido en el paso anterior.</li>
</ol>
<p>De esta manera, obtenemos el resultado final que representa el hash del array completo.</p>
<p><img src="./assets/Hash_Array.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Esta construcci√≥n en capas nos permite combinar de manera secuencial los elementos del array a medida que calculamos el hash. Cada iteraci√≥n agrega un nivel adicional de seguridad y complejidad al resultado final.</p>
<h2 id="poseidon"><a class="header" href="#poseidon">Poseidon</a></h2>
<p>La funci√≥n de hash Poseidon utiliza la permutaci√≥n Hades, representada por hades: <code>ùîΩ¬≥‚Çö‚ÜíùîΩ‚Çö</code>, con los par√°metros de Starknet. Dado un array <code>a‚ÇÅ</code>, <code>a‚ÇÇ</code>, ..., <code>a‚Çô</code> que contiene <code>n</code> field elements, definimos <code>poseidon(a‚ÇÅ, a‚ÇÇ, ..., a‚Çô)</code> como la primera coordenada de <code>H(a‚ÇÅ, a‚ÇÇ, ..., a‚Çô; 0, 0, 0)</code>,</p>
<ul>
<li><code>H(a‚ÇÅ, a‚ÇÇ, ..., a‚Çô; s‚ÇÅ, s‚ÇÇ, s‚ÇÉ)</code> se define de la siguiente manera:</li>
</ul>
<p><img src="./assets/Hash_Poseidon.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<ul>
<li><strong>Si n ‚â• 2:</strong> entonces <code>H(a‚ÇÅ,a‚ÇÇ,...,a‚Çô;s‚ÇÅ,s‚ÇÇ,s‚ÇÉ) = H(a‚ÇÉ, a‚ÇÑ, ..., a‚Çô;hades(s‚ÇÅ + a‚ÇÅ, s‚ÇÇ + a‚ÇÇ, s‚ÇÉ))</code>.</li>
<li><strong>Si n = 1:</strong> entonces <code>H(a‚ÇÅ; s‚ÇÅ, s‚ÇÇ, s‚ÇÉ) = hades(s‚ÇÅ + a‚ÇÅ, s‚ÇÇ + 1, s‚ÇÉ)</code>.</li>
<li><strong>Si n = 0:</strong> entonces <code>H(); s‚ÇÅ, s‚ÇÇ, s‚ÇÉ) = hades(s‚ÇÅ + 1, s‚ÇÇ, s‚ÇÉ)</code>.</li>
</ul>
<p>En resumen, la <code>funci√≥n poseidon(a‚ÇÅ,a‚ÇÇ,...,a‚Çô)</code> toma el array de field elements y aplica la permutaci√≥n Hades en capas. Cada iteraci√≥n de la permutaci√≥n combina los elementos del array en funci√≥n de los valores de  <code>s‚ÇÅ</code>, <code>s‚ÇÇ</code> y <code>s‚ÇÉ</code>, generando as√≠ una salida √∫nica. La primera coordenada de la salida final se considera el resultado de la funci√≥n de hash Poseidon.</p>
<p>Esta construcci√≥n en capas y la utilizaci√≥n de la permutaci√≥n Hades permiten obtener un hash seguro y resistente a ciertos ataques criptogr√°ficos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="s-t-arks"><a class="header" href="#s-t-arks">S-T-ARKs</a></h1>
<p>Ahora, adentr√©monos en una de las partes m√°s fascinantes del ecosistema, los <strong>STARKs</strong> <a href="https://starkware.co/stark/">(Scalable Transparent Argument of Knowledge)</a> se basan en los principios de la criptograf√≠a sim√©trica combinados con matem√°ticas modernas, la existencia de funciones hash criptogr√°ficas seguras y resistentes a las colisiones. Muchas de estas primitivas existen hoy en d√≠a como instrucciones de hardware, y la criptograf√≠a magra conduce a dos beneficios m√°s:</p>
<ol>
<li>
<p><strong>Seguridad poscu√°ntica:</strong> los <strong>STARK</strong> son plausiblemente seguros frente a ordenadores cu√°nticos eficientes.</p>
</li>
<li>
<p><strong>Eficiencia concreta:</strong> el prover <strong>STARK</strong> es al menos <strong>10 veces m√°s r√°pido</strong> que el prover SNARK y el prover <a href="https://eprint.iacr.org/2017/1066.pdf">Bulletproofs</a>.</p>
<p>El verificador <strong>STARK</strong> es al menos <strong>2 veces m√°s r√°pido</strong> que el verificador <strong>SNARK</strong> y m√°s de <strong>10 veces m√°s r√°pido</strong> que el verificador <strong>Bulletproof</strong>.</p>
<p>A medida que StarkWare contin√∫e optimizando <strong>STARKs</strong> estos ratios probablemente mejorar√°n. Sin embargo, la longitud de una prueba <strong>STARK es ~100x mayor</strong> que la correspondiente <strong>SNARK</strong> y <strong>~20x mayor que BulletProofs</strong>.</p>
</li>
</ol>
<p>Puede encontrar una imagen animada en una comparativa con los datos expuestos sobre el Proving Time y Verification Time, Tama√±o de la Proof, Configuraci√≥n inicial y PQS entre STARKs y SNARKs, veremos como cada una cumple con propiedades que puede ser recomendada para darle mejor uso.</p>
<p><img src="./assets//Stark_Prover.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Ahora que tenemos conceptos m√°s profundos sobre algunos aspectos de la criptograf√≠a, funciones hash y las operaciones detr√°s de cada una, veamos la importancia de la Integridad Computacional (CI), una propiedad fundamental para el d√≠a a d√≠a. Esta propiedad se refiere a la confianza en que la salida de un c√°lculo es correcta, permiti√©ndonos confiar en el saldo de una cuenta o en el monto de una factura en una tienda.</p>
<blockquote>
<p><strong>Pero, ¬øc√≥mo podemos garantizar esta integridad en un entorno digital donde no siempre podemos confiar en todas las partes involucradas?</strong></p>
</blockquote>
<p>Aqu√≠ es donde entra en juego la tecnolog√≠a STARK, que se basa en estas Validity Proofy para garantizar que la computaci√≥n se realice correctamente, <strong>incluso si nadie est√° observando <code>‚ÄúINTEGRO‚Äù</code></strong>. STARKs utiliza matem√°ticas para lograr este objetivo y est√° dise√±ado para monitorear y garantizar la integridad de un gran c√°lculo realizado por un grupo de supercomputadoras poco confiables.</p>
<p>Las Validity Proofs son una herramienta crucial para garantizar la integridad y validez de los cambios realizados fuera de la cadena principal. Los sistemas de ZKP, en los que el prover posee informaci√≥n secreta que no es conocida por el verifier, son clave para las Validity Proofs. En el caso de Starknet, se trata de un Validity Rollup que utiliza STARKs.</p>
<p>Es importante tener en cuenta que ZK en Starknet, es una propiedad adicional que se utiliza para afirmar al probador que no tiene que revelar ninguna informaci√≥n incluida en el c√°lculo. Sin embargo, en el caso de Starknet como una capa 2 p√∫blica, los datos de transacci√≥n son p√∫blicos, lo que significa que no se ofrece privacidad como tal en transacciones, ocultar saldos u otras operaciones opacas, aunque los zk-STRAKs est√°n listas para eso.</p>
<p>En Starknet, el enfoque principal es el Validity Rollup, que se utiliza para probar la validez del c√°lculo computacional, a diferencia de otros protocolos que utilizan mal nombrado ZK Rollup. La propiedad ZK se utiliza en Starknet para escalar el rendimiento, no para garantizar privacidad, por lo tanto, los STARKs en Starknet son Validity Proofs en lugar de ZK Proofs.</p>
<p>Los STARKs utilizan funciones de criptograf√≠a sim√©trica y hash criptogr√°ficos como componentes fundamentales en su construcci√≥n, las vulnerabilidades cu√°nticas conocidas en criptograf√≠a, como el algoritmo de Shor que puede factorizar n√∫meros enteros grandes y romper sistemas de criptograf√≠a asim√©trica basados en factorizaci√≥n, no afectan a las STARKs.</p>
<p><img src="./assets//Stark_1.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En la imagen superior, se puede observar que las pruebas pueden basarse en principios de criptograf√≠a sim√©trica o asim√©trica, como aprendimos al principio del documento. Adem√°s, se pueden apreciar las diferentes propiedades de cada una en cuanto a escalabilidad, transparencia, seguridad en el futuro post-cu√°ntico o tama√±o de la prueba.</p>
<p>Como conclusi√≥n final antes de pasar a sus propiedades podemos ver para pruebas cortas como se recomienda utilizar <strong>Groth16</strong> o <strong>SNARKs</strong>, mientras que para todo lo dem√°s se sugiere <strong>STARK</strong>. Es importante destacar que este campo se encuentra en constante desarrollo y cada uno sigue optimizando sus propias soluciones. Tanto las <strong>STARKs</strong> como Starknet tambi√©n experimentar√°n optimizaciones para mejorar <strong>STARK</strong> y/o admitir diferentes tipos de pruebas. Un ejemplo de esto es como <a href="https://github.com/keep-starknet-strange">Keep-Starknet-Strange</a> el equipo detr√°s de <a href="https://github.com/keep-starknet-strange/garaga"><strong>Garaga</strong></a>, que est√° trabajando en diversas librer√≠as criptogr√°ficas como <a href="https://eprint.iacr.org/2019/953.pdf">Plonk</a>, <a href="https://eprint.iacr.org/2016/260.pdf">Groth16</a>, <strong>SNARK</strong>, entre otras.</p>
<p>Si desea obtener m√°s informaci√≥n sobre como los STARKs est√°n en diversas arquitectura y sus diversos casos de uso para asentar las bases dela criptograf√≠a moderna, recomendamos leer el articulo que sacamos para L2 Espa√±ol <a href="https://mirror.xyz/layer2es.eth/8TUEfpZPgl1u3-HyyGaUA0YMrFm8XSHfYtY6tfqFX7s">Profundizando en el Ecosistema STARKs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="propiedas-de-las-starks"><a class="header" href="#propiedas-de-las-starks">Propiedas de las STARKs</a></h2>
<p>Hemos visto c√≥mo diferenciar los tipos de pruebas seg√∫n su criptograf√≠a, as√≠ como la comparativa entre varias de ellas. Ahora veamos cu√°les son las dos propiedades esenciales en las pruebas y c√≥mo se pueden lograr, antes de pasar a la definici√≥n de STARK</p>
<ol>
<li><strong>Succintness (Sucintez):</strong> exigimos que nuestras pruebas y, en particular, el tiempo de verificaci√≥n sean sucintos, es decir, que sean √≥rdenes de magnitud m√°s peque√±os que el tiempo necesario para calcular nuestro programa. De lo contrario, no habr√≠a ninguna ventaja para el verificador en utilizar la prueba en lugar del c√°lculo original.</li>
<li><strong>Heur√≠stica Fiat-Shamir:</strong> este es un proceso mediante el cual podemos convertir una prueba interactiva en una no interactiva. Funciona proporcionando compromisos a los mensajes que formar√≠an la interacci√≥n y las funciones hash se utilizan como fuente de aleatoriedad.</li>
</ol>
<p>Uno de los protocolos que se utiliza en sistemas criptogr√°ficos, como los STARKs, para abordar el desaf√≠o de verificar eficientemente la correcci√≥n de grandes c√°lculos polinomiales es FRI (Fast Reed-Solomon Interactive Oracle Proofs of Proximity).</p>
<p>FRI utiliza c√≥digos de correcci√≥n de errores Reed-Solomon para permitir pruebas interactivas eficientes. Esto significa que el probador puede proporcionar una prueba corta de la correcci√≥n del c√°lculo, mientras que el verificador puede verificar de manera eficiente la validez de la prueba. Este proceso interactivo permite realizar pruebas de proximidad, donde el verificador puede verificar de manera eficiente si el c√°lculo reclamado se acerca al resultado correcto sin tener que evaluar por completo todo el polinomio.</p>
<blockquote>
<p>El conjunto de operaciones matem√°ticas, bases criptogr√°ficas, FRI y otras propiedades, como Fiat-Shamir, permite que las STARKs logren seguridad cu√°ntica y escalabilidad, al tiempo que proporcionan una verificaci√≥n transparente y eficiente de c√°lculos complejos.</p>
</blockquote>
<p>Podemos decir entonces que los STARKs demuestran la correcta operaci√≥n de una m√°quina virtual al demostrar que la traza de ejecuci√≥n asociada es v√°lida con respecto al AIR dado. En t√©rminos generales, las trazas de ejecuci√≥n se organizan como tablas de n√∫meros, y el protocolo STARK demuestra que estos n√∫meros resuelven conjuntamente un sistema de polinomios.</p>
<p>As√≠ vemos c√≥mo algunas de estas propiedades, como la succintez, pueden venir de forma natural en las STARKs, y c√≥mo el principio de Fiat-Shamir permite realizar pruebas interactivas. Adem√°s, contar con FRI como correcci√≥n de errores ampl√≠a las capacidades y visi√≥n de las STARKs, as√≠ que ahora vayamos a su definici√≥n</p>
<h2 id="s--scalable"><a class="header" href="#s--scalable">S = Scalable</a></h2>
<p>Una de las principales ventajas de STARKs es que al trasladar un c√°lculo fuera de la cadena, se reducen de manera exponencial los costos de verificaci√≥n en la cadena de bloques. El proceso de creaci√≥n de una prueba fuera de la cadena tiene un costo similar al de solicitar a un √∫nico nodo de la cadena de bloques que realice el c√°lculo.</p>
<p>La producci√≥n de pruebas no resulta considerablemente m√°s costosa que la ejecuci√≥n del c√°lculo original, y la validaci√≥n de las pruebas es <strong>exponencialmente m√°s r√°pida</strong> que la ejecuci√≥n del c√°lculo original. Adem√°s, las pruebas son <strong>considerablemente m√°s cortas</strong> en tama√±o que el c√°lculo original.</p>
<p>Otra ventaja importante es que a medida que se incrementa la cantidad de c√≥mputo, su crecimiento es casi lineal. Esto la convierte en una opci√≥n ideal para procesar transacciones a gran escala.</p>
<p><img src="./assets//Stark_2.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Adem√°s, se puede aprovechar la capacidad de paralelizaci√≥n de pruebas por el prover y recursividad de los STRAKs eficentes para mejorar significativamente la escalabilidad.</p>
<p><img src="./assets//Stark_3.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<h2 id="t--transparent"><a class="header" href="#t--transparent">T = Transparent</a></h2>
<p>La seguridad de las STARKs no depende de ceremonias de configuraci√≥n elaboradas que puedan generar residuos t√≥xicos criptogr√°ficos, como ocurre en otras tecnolog√≠as de pruebas.</p>
<p>El uso de STARKs para iniciar la prueba bas√°ndose en criptograf√≠a sim√©trica, pseudoaleatoriedad y las matem√°ticas proporciona un inicio de ceremonia transparente y elimina la necesidad de una configuraci√≥n de confianza inicial (trusted setup), lo que asegura la ausencia de residuos t√≥xicos y mejora la seguridad y confiabilidad general del sistema criptogr√°fico.</p>
<p>Una caracter√≠stica importante de las STARKs es su construcci√≥n basada en el trabajo de <a href="https://es.wikipedia.org/wiki/Silvio_Micali">Micali</a>. En esta construcci√≥n, la √∫nica criptograf√≠a necesaria para producir o validar una prueba corta <code>ùõë</code> es una <strong>funci√≥n hash criptogr√°fica</strong> <code>H</code>, como <code>SHA-256</code> o <code>Keccak</code>. La elecci√≥n de <code>H</code> se convierte en el √∫nico <strong>&quot;par√°metro global&quot;</strong> que todos los usuarios del sistema de prueba deben conocer, y <strong>esta elecci√≥n puede hacerse de manera p√∫blica, garantizando la transparencia de las pruebas criptogr√°ficas obtenidas a trav√©s de las STARKs.</strong></p>
<p>Sin embargo siempre comparamos STARKs con SNARKs o pruebas derivadas de criptograf√≠a asim√©trica como las <a href="https://eprint.iacr.org/2013/279.pdf">Pinocchio</a> de ECC, pero cada una tiene sus varientes y esquemas diversos,  aunque para una explicaci√≥n m√°s clara cogeremos el ejemplo de <a href="https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6">VB en un art√≠culo sobre zk-SNARKs</a>.</p>
<p><img src="./assets//Stark_4.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Imaginemos que tenemos un par de puntos <code>P</code> y <code>Q</code>, donde <code>P * k = Q</code>, y tienes un punto <code>C</code>, entonces no es posible obtener <code>C * k</code> a menos que <code>C</code> est√© <strong>&quot;derivado&quot;</strong> de alguna manera que conozcas a partir de <code>P</code>. Esto puede parecer intuitivamente obvio, pero esta suposici√≥n en realidad no puede derivarse de ninguna otra suposici√≥n (por ejemplo, la dificultad del logaritmo discreto) que usualmente utilizamos al probar la seguridad de los protocolos basados en EC. Por lo tanto, los SNARKs se basan en una base un tanto m√°s fr√°gil que la ECC en general.</p>
<p>Supongamos que cae del cielo un par de puntos <code>(P, Q)</code>, donde <code>P * k = Q</code>, pero nadie conoce el valor de <code>k</code>. Ahora, supongamos que yo presento un par de puntos <code>(R, S)</code> donde <code>R * k = S</code>. Entonces, la suposici√≥n de conocimiento del extremo de la curva (KoE, por sus siglas en ingl√©s) implica que la √∫nica forma en que podr√≠a haber creado ese par de puntos es tomando <code>P</code> y <code>Q</code>, y multiplic√°ndolos por un factor <code>r</code> que <strong>solo yo conozco</strong>. Tambi√©n hay que tener en cuenta que, gracias a la magia de las parejas de curvas el√≠pticas, verificar que <code>R = k * S</code> no requiere conocer <code>k</code>; en su lugar, simplemente puedes comprobar si <code>e(R, Q) = e(P, S)</code>, donde e es una funci√≥n de emparejamiento de curvas el√≠pticas.</p>
<p>Hagamos algo m√°s interesante. Supongamos que caen del cielo diez pares de puntos: <code>(P_1, Q_1), (P_2, Q_2) ... (P_10, Q_10)</code>. En todos los casos, se cumple que <code>P_i * k = Q_i</code>, ahora, supongamos que te proporciono un par de puntos <code>(R, S)</code> donde <code>R * k = S</code>.</p>
<p><strong>¬øQu√© sabemos ahora?</strong> Que <code>R</code> es una combinaci√≥n lineal de la forma <code>P_1 * i_1 + P_2 * i_2 + ... + P_10 * i_10</code>, donde yo conozco los coeficientes <code>i_1, i_2 ... i_10</code>, es decir, la √∫nica forma de obtener un par de puntos <code>(R, S)</code> de esta manera es tomando algunos m√∫ltiplos de <code>P_1, P_2 ... P_10</code> y sum√°ndolos, y hacer el mismo c√°lculo con <code>Q_1, Q_2 ... Q_10.</code></p>
<p>Enrtonces tenemos que tener en cuenta que dado cualquier conjunto espec√≠fico de puntos <code>P_1‚Ä¶P_10</code> para los que puedas querer verificar combinaciones lineales, en realidad no puedes crear los puntos correspondientes <code>Q_1‚Ä¶Q_10</code> sin conocer el valor de <code>k</code>, y si conoces el valor de <code>k</code>, entonces puedes crear un par <code>(R, S)</code> donde <code>R * k = S</code> para cualquier <code>R</code> que desees, sin necesidad de crear una combinaci√≥n lineal.</p>
<p><strong>Por lo tanto, para que esto funcione, es absolutamente imperativo que quien cree esos puntos sea confiable y realmente elimine <code>k</code> una vez que haya creado los diez puntos.</strong></p>
<p>Se debe destacar la importancia de las ceremonias de ajuste inicial en ciertos casos, como en implementaciones de sistemas de votaci√≥n. En estos casos, es crucial tener en cuenta qui√©n ha sido el creador de los puntos y si existe alguna posibilidad de manipulaci√≥n o si se ha eliminado correctamente el valor de k. Esto es necesario para lograr transparencia y evitar depender de estas verificaciones. En este sentido, los STARKs se presentan como una soluci√≥n prometedora y <strong>EFICIENTE</strong>, ya que proporcionan una base s√≥lida que elimina la necesidad de confiar en dichas ceremonias de ajuste inicial.</p>
<h2 id="ark--argument-of-knowledge"><a class="header" href="#ark--argument-of-knowledge">ARK = Argument of Knowledge</a></h2>
<p>Los argumentos de conocimiento ‚ÄúARK‚Äù son llevados a cabo por el prover que opera fuera de la cadena principal. Este probador se encarga de ejecutar el c√°lculo requerido para la prueba, utilizando las entradas auxiliares necesarias, la realizaci√≥n de la prueba fuera de la cadena principal es clave, ya que debe garantizar la integridad y la confiabilidad del proceso.</p>
<p>La principal ventaja de esta metodolog√≠a es que permite una verificaci√≥n aut√©ntica y matem√°ticamente s√≥lida. Despu√©s de que el probador haya realizado el c√°lculo, puede proporcionar la prueba generada a cualquier computadora o entidad interesada para su verificaci√≥n, haciendo uso de ARK sto significa que cualquier sistema inform√°tico puede confirmar la validez de la prueba de manera independiente.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starks-eficientes"><a class="header" href="#starks-eficientes">STARKS eficientes</a></h2>
<p>Est√° llegando el momento de comprender como los STARKs son una versi√≥n m√°s eficiente de las <a href="https://en.wikipedia.org/wiki/Probabilistically_checkable_proof"><strong>(PCP)</strong></a>, un protocolo que permite establecer la exactitud de las declaraciones de <strong>CI</strong>, mediante una verificaci√≥n aleatoria local en una prueba larga, este protocolo se realiza entre un prover <strong>PCP</strong> y un verifier <strong>PCP</strong>.</p>
<p>El prover <strong>PCP</strong> produce una cadena de prueba <code>ùöø</code> que codifica el seguimiento de c√°lculo de la declaraci√≥n de <code>CI</code>, a pesar de que <code>ùöø</code> es m√°s larga que la traza de c√°lculo de pasos <code>T</code>. Sin embargo, la cadena de prueba <code>ùöø</code> tiene la propiedad especial de que puede ser validada a trav√©s de una prueba probabil√≠stica que lee solo una peque√±a parte de <code>ùöø</code>.</p>
<p>El verifier <strong>PCP</strong>, al recibir la misma declaraci√≥n de <strong>CI</strong> <code>(A, x, y, T)</code>, puede validar la cadena de prueba <code>ùöø</code> leyendo aleatoriamente unas pocas ubicaciones de <code>ùöø</code> y luego realizar una <strong>&quot;verificaci√≥n local&quot;</strong> econ√≥mica en los valores le√≠dos. El n√∫mero de ubicaciones de lectura puede ser una peque√±a constante, como 3, independientemente de la longitud de la traza de c√°lculo <code>T</code>.</p>
<p>Si la declaraci√≥n de CI es verdadera, el verifier siempre aceptar√°. Sin embargo, si la declaraci√≥n de CI es falsa, el verificador la rechazar√° con alta probabilidad, sin importar c√≥mo se haya elegido la cadena de prueba <code>ùöø</code>.</p>
<p><img src="./assets/Stark_Sudoku.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En la imagen animada podemos ver un ejemplo de <strong>PCP</strong> con un conjunto de resticciones un sudoku y ahora veremos como los STARKs eficiente pueden mejorar la eficiencia de las <strong>PCP</strong> y <strong>MPCP</strong> con <strong>IOPs</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iops---interactive-oracle-proof"><a class="header" href="#iops---interactive-oracle-proof">IOPs - Interactive Oracle Proof</a></h1>
<p>Las Interactive Orcale Proof <a href="https://eprint.iacr.org/2016/116"><strong>(IOP)</strong></a> son un nuevo tipo de sistema de prueba que combina las propiedades clave de <strong>pruebas interactivas</strong> y <strong>PCP</strong>, las <strong>IOP</strong> permiten que un verifier est√© convencido de la exactitud de una declaraci√≥n al interactuar con un prover no confiable mientras lee solo algunos bits de los mensajes enviados por el prover. Las <strong>IOP</strong> se han vuelto muy prominentes en el dise√±o de sistemas de prueba eficientes en los √∫ltimos a√±os.</p>
<blockquote>
<p><strong>Las construcciones STARK eficientes se obtienen combinando IOP eficientes y funciones hash criptogr√°ficas. El IOP le confiere al STARK su escalabilidad, mientras que la funci√≥n hash le confiere al STARK su transparencia.</strong></p>
</blockquote>
<p>Las STARKs eficientes se basan en IOP, de manera informal, un prover y un verifier participan en un protocolo interactivo en el que, en cada ronda, el verifier env√≠a algo de aleatoriedad <code>ùõî·µ¢</code> al prover, y el prover responde con una proof larga <code>ùöø·µ¢</code>. Al final de la interacci√≥n, el verificador realiza una verificaci√≥n local aleatoria de todas las proof largas <code>(ùöø‚ÇÅ,ùöø‚ÇÇ,‚Ä¶)</code> enviadas por el prover a lo largo de la interacci√≥n.</p>
<p>Ahora, antes de sumergirnos en el mundo de los pasos de creaci√≥n de un STARKs y su eficiencia, es importante comprender qu√© es un polinomio, ya que desempe√±an un papel crucial en la construcci√≥n y verificaci√≥n de STARKs. Son utilizados para representar y manipular datos de manera eficiente, lo que permite lograr un alto nivel de compresi√≥n y optimizaci√≥n en el proceso de verificaci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="polinomios"><a class="header" href="#polinomios">Polinomios</a></h2>
<p>Los polinomios son una poderosa herramienta algebraica que se utiliza en diversas ramas de las matem√°ticas y la f√≠sica. Estas expresiones algebraicas est√°n formadas por t√©rminos que contienen variables y coeficientes. Los t√©rminos son la suma o resta de monomios, que son productos de constantes y variables elevadas a exponentes enteros no negativos.</p>
<p>Un polinomio puede tener una o varias variables, y su grado est√° determinado por el exponente m√°s alto presente en los t√©rminos del polinomio. Por ejemplo, el polinomio <code>3x¬≤ - 2x + 1</code>  es un polinomio de grado 2, ya que el t√©rmino de mayor grado tiene un exponente de 2.</p>
<p>Los polinomios se pueden sumar, restar, multiplicar y dividir, y se emplean en ecuaciones algebraicas, c√°lculo, geometr√≠a y muchas otras ramas de las ciencias exactas.</p>
<p><strong>¬øPor qu√© no eval√∫a el verifier los propios polinomios?</strong></p>
<ul>
<li>Prque, en realidad, el prover no env√≠a todos los polinomios al verificador, si lo hiciera perder√≠amos sucintez, contienen m√°s informaci√≥n que nuestra declaraci√≥n original, por lo que el prover s√≥lo proporciona un compromiso con los polinomios.</li>
</ul>
<p><strong>¬øQu√© propiedades de los polinomios son importantes en este caso?</strong></p>
<ul>
<li>Los polinomios son buenos c√≥digos de correcci√≥n de errores.</li>
</ul>
<p>Si tenemos polinomios de grado <code>d</code> sobre un dominio de codificaci√≥n <code>D</code>, y dos mensajes <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code>, entonces  <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code> diferir√°n en <code>|D|-d</code> puntos. Esto es importante porque queremos que la diferencia entre una declaraci√≥n correcta y una incorrecta sea grande, de modo que sea f√°cil de encontrar.</p>
<p>Esto conduce a un buen muestreo, lo que ayuda a la sucintez, s√≥lo necesitamos muestrear unos pocos valores para estar seguros de que la probabilidad de error es lo suficientemente baja como para ser insignificante.</p>
<ul>
<li>Disponer de pruebas eficaces de lote cero mantiene la sucintez.</li>
</ul>
<p>Tener la capacidad de realizar pruebas de lote cero eficaces es fundamental. Esto nos permite demostrar de manera conjunta que un conjunto de elementos cumple con una determinada propiedad, en lugar de tener que probar cada elemento de forma individual, esta t√©cnica de prueba en lote nos permite lograr una mayor concisi√≥n y eficiencia en la verificaci√≥n.</p>
<p>Imaginemos que queremos demostrar que un polinomio de grado grande <code>P(x) (grado ~ 10 millones)</code> eval√∫a a <code>0</code> en los puntos <code>1...1 mill√≥n</code>, pero queremos hacerlo con una sola consulta.</p>
<p>Imaginemos que nuestra afirmaci√≥n es que <code>P</code> desaparece en estos puntos. Si el verifier s√≥lo utiliza el muestreo, el prover podr√≠a hacer trampas f√°cilmente proporcionando un punto que se eval√∫e como <code>0</code>, pero los otros <code>999.999</code> podr√≠an ser distintos de <code>0</code>.</p>
<h2 id="resolviendo-el-problema"><a class="header" href="#resolviendo-el-problema">Resolviendo el problema</a></h2>
<p>Consideremos un conjunto <code>S = 1...10‚Å∂</code></p>
<p>Definir <code>V</code> como el polinomio que se anula en estos puntos, es decir: <code>(x - 1)(x - 2)(x - 3)...</code> el grado de <code>V = tama√±o de S</code> y esto es beneficioso porque:</p>
<ol>
<li><code>P(x) = P'(x) ‚Ä¢ V(x)</code></li>
<li><code>Grado de P = Grado de P' - Tama√±o de S.</code></li>
</ol>
<p>La introducci√≥n de <code>V(x)</code> nos permite verificar en todo el dominio.</p>
<ul>
<li>Estos polinomios tienen una propiedad <strong>&quot;multiplicadora&quot;</strong>. Podemos <strong>&quot;envolver&quot;</strong> una restricci√≥n alrededor de un polinomio.</li>
</ul>
<p>Por ejemplo, si tenemos la restricci√≥n <strong>C</strong>, que indica que nuestra evaluaci√≥n siempre ser√° 0 o 1, podr√≠amos expresarla como <code>C(x) = x ‚Ä¢ (x - 1)</code>. Esto se podr√≠a interpretar como restringir una salida para que sea un booleano, lo cual es √∫til en t√©rminos de integridad computacional.</p>
<p>En lugar de tener <code>x</code> como un simple punto, podr√≠amos considerar la evaluaci√≥n de un  de un polinomio <code>P‚ÇÅ(x)</code> en un punto espec√≠fico, es decir, <code>C(P‚ÇÅ(x)) = P‚ÇÅ(x)‚Ä¢(P‚ÇÅ(x)-1)</code></p>
<p>Los grados de los polinomios resultantes de la multiplicaci√≥n son aditivos, por lo que el grado de <code>C(x) = 2 ‚Ä¢ grado de P‚ÇÅ(x)</code></p>
<p>Podemos afirmar que si <code>P‚ÇÅ(x)</code> cumple con esta restricci√≥n para nuestro conjunto <code>S</code>, entonces, como mencionamos anteriormente, existe un polinomio <code>P'(x)</code> tal que:</p>
<ul>
<li><code>C(P‚ÇÅ(x)) = P'(x) ‚Ä¢ V(x)</code></li>
</ul>
<p>Si <code>P‚ÇÅ(x)</code> no cumpliera con la restricci√≥n (por ejemplo, si para un valor de <code>x, P‚ÇÅ(x) = 93</code>), entonces no podr√≠amos encontrar esos polinomios, la igualdad no se cumplir√≠a y habr√≠a un residuo en la ecuaci√≥n anterior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creando-un-stark"><a class="header" href="#creando-un-stark">Creando un STARK</a></h1>
<p>En esta parte final del documento y despu√©s de haber explicado algunas propiedades  importantes de los polinomios y que resuelven, exploraremos la creaci√≥n de una STARK desde los fundamentos matem√°ticos m√°s profundos. Para obtener una comprensi√≥n completa de los procesos involucrados y c√≥mo se puede combinar un PCP con criptograf√≠a ligera para obtener un STARK, te recomendamos revisar la serie lanzada por Starkware,que proporciona una profundizaci√≥n inicial m√°s detallada.</p>
<p>Adem√°s, encontrar√°s a continuaci√≥n los enlaces a cinco art√≠culos fundamentales  traducidos al espa√±ol que complementar√°n tu aprendizaje:</p>
<ol>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Comienza%20el%20viaje.md">Comienza el Viaje</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20I.md">Aritmetizaci√≥n I</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20II.md">Aritmetizaci√≥n II</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Prueba%20de%20bajo%20grado.md">Pruebas de Bajo Grado</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Un%20marco%20para%20STARKs%20eficientes.md">Un Frameword para STARKs Eficientes</a></li>
</ol>
<p>Estos recursos adicionales te brindar√°n una visi√≥n m√°s completa y pr√°ctica del proceso de creaci√≥n de una STARK. Tambi√©n te recomendamos revisar los repositorios relacionados y los videos de creaci√≥n de una STARK en Pioneros Clases 3, un Basecamp descentralizado en Espa√±ol creado por Starknet, o el den ingl√©s impartido por Eli Ben Saason</p>
<p>Nos interesa la Integridad Computacional (CI), por ejemplo, saber que el programa de Cairo que escribiste se calcul√≥ correctamente.</p>
<ul>
<li>Tenemos que pasar por una serie de transformaciones desde el trazado de nuestro programa, hasta la prueba.</li>
<li>La primera parte de esto se llama aritmetizaci√≥n, y consiste en tomar nuestra traza y convertirla en un conjunto de polinomios.</li>
<li>Nuestro problema se convierte entonces en uno en el que el prover intenta convencer a un verificador de que el polinomio es de grado bajo.</li>
<li>El verificador est√° convencido de que el polinomio es de grado bajo si y s√≥lo si el c√°lculo original es correcto (salvo una probabilidad infinitesimalmente peque√±a).</li>
</ul>
<p><img src="./assets/Stark_5.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El uso de la aletoriedad es muy importante para el prover y el verifier, mientras que el prover utiliza la aleatoriedad para alcanzar el conocimiento cero, el verificador utiliza la aleatoriedad al generar consultas al prover, para detectar trampas por parte del prover.</p>
<p>Gran parte del trabajo que se realiza al crear una prueba consiste en garantizar que sea sucinta y que pueda elaborarse y verificarse en un tiempo razonable. Por tanto, nuestro plan consistir√° en:</p>
<ul>
<li>Reformular la traza de ejecuci√≥n como un polinomio,</li>
<li>Extenderlo a un gran dominio,</li>
<li>Transformarlo, utilizando las restricciones polin√≥micas, en otro polinomio que se garantiza que es de grado bajo si y s√≥lo si la traza de ejecuci√≥n es v√°lida.</li>
<li>Queremos lograr una verificaci√≥n sucinta, en la que el verificador de la declaraci√≥n CI requiera exponencialmente menos recursos que los necesarios para la repetici√≥n ingenua.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aritmetizaci√≥n"><a class="header" href="#aritmetizaci√≥n">Aritmetizaci√≥n</a></h1>
<p>Tenemos dos pasos principales en este proceso:</p>
<ol>
<li>Generaci√≥n de una traza de ejecuci√≥n y restricciones polin√≥micas.</li>
<li>Transformar estos dos objetos en un √∫nico polinomio de bajo grado.</li>
</ol>
<p>En t√©rminos de interacci√≥n prover-verifier, realmente lo que ocurre es que entre ambos acuerdan de antemano cu√°les son las restricciones polin√≥micas.</p>
<p>A continuaci√≥n, el prover genera una traza de ejecuci√≥n y, en la interacci√≥n posterior, intenta convencer al verificador de que las restricciones polin√≥micas se cumplen en esta traza de ejecuci√≥n, sin que el verificador lo vea.</p>
<p>La traza de ejecuci√≥n es una tabla que representa los pasos del c√°lculo subyacente, donde cada fila representa un √∫nico paso y el tipo de traza de ejecuci√≥n que buscamos generar debe tener la caracter√≠stica especial de ser sucintamente comprobable:</p>
<ul>
<li>Cada fila puede ser verificada bas√°ndose s√≥lo en las filas que est√°n cerca de ella en la traza, y el mismo procedimiento de verificaci√≥n se aplica a cada par de filas.</li>
</ul>
<p>Por ejemplo, imaginemos que nuestra traza representa un total en ejecuci√≥n, con cada paso de la siguiente manera.</p>
<pre><code class="language-bash">                    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
                    ‚ïë  PASO  ‚ïë  IMPORTE  ‚ïë TOTAL ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   0    ‚ïë     0     ‚ïë   0   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   1    ‚ïë     5     ‚ïë   5   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   2    ‚ïë     2     ‚ïë   7   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   3    ‚ïë     2     ‚ïë   9   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   4    ‚ïë     3     ‚ïë   12  ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   5    ‚ïë     6     ‚ïë   18  ‚ïë
                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
</code></pre>
<p>Si representamos la fila como <code>i</code> , y la columna como <code>j</code> , y los valores como <code>A·µ¢,‚±º</code> , podr√≠amos escribir algunas restricciones sobre esto de la siguiente manera:</p>
<ul>
<li><code>A‚ÇÄ,‚ÇÇ=0</code></li>
<li><code>‚àÄ1 &gt;= i &lt;= 5 : A·µ¢,‚ÇÇ ‚àí A·µ¢,‚ÇÅ ‚àí A·µ¢-‚ÇÅ,‚ÇÇ = 0</code></li>
<li><code>A‚ÇÖ,‚ÇÇ = 18</code></li>
</ul>
<p>Se trata de restricciones polin√≥micas lineales en <code>A·µ¢,‚±º</code></p>
<p>N√≥tese que aqu√≠ estamos consiguiendo cierta concisi√≥n porque podr√≠amos representar un n√∫mero mucho mayor de filas con s√≥lo estas 3 restricciones.</p>
<p>El sistema de restricciones aritm√©ticas define al menos dos tipos de restricciones sobre la traza de ejecuci√≥n algebraica:</p>
<ol>
<li><strong>Restricciones de contorno:</strong> al principio o al final del c√°lculo, un registro indicado tiene un valor determinado.</li>
<li><strong>Restricciones de transici√≥n:</strong> dos tuplas de estado consecutivas cualesquiera evolucionan de acuerdo con la funci√≥n de transici√≥n de estado. En conjunto, estas restricciones se conocen como representaci√≥n algebraica intermedia o AIR.</li>
</ol>
<p>Las STARKs avanzadas pueden definir m√°s tipos de restricciones para tratar con la memoria o con la consistencia de los registros dentro de un ciclo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polinomio-para-nuestra-traza"><a class="header" href="#polinomio-para-nuestra-traza">Polinomio para nuestra traza</a></h1>
<p>Tambi√©n en este caso definimos un polinomio <code>f(x)</code> tal que los elementos de la traza de ejecuci√≥n son evaluaciones de <code>f</code> en potencias de alg√∫n generador <code>g</code>.</p>
<p>Recordemos que nuestro campo finito tendr√° generadores, que utilizaremos para indexar los pasos de nuestra traza. Tomando una secuencia de Fibonacci podemos crear restricciones como:</p>
<ul>
<li><code>‚àÄ x ‚àà {1,g¬≤,g¬≥...g‚Åµ‚Å∞‚Åπ}: f(g¬≤x) ‚Çã f(gx) ‚Çã f(x) = 0</code></li>
</ul>
<p>Esto restringe los valores entre las filas subsiguientes. Tambi√©n significa que los valores g son ra√≠ces de este polinomio.</p>
<p>Por lo tanto, podemos utilizar el enfoque que vimos anteriormente para proporcionar el polinomio de fuga utilizando el t√©rmino <code>(x - g‚Å±)</code> y a partir de √©l creamos el polinomio de composici√≥n.</p>
<p>El hecho b√°sico sobre polinomios y sus ra√≠ces es que si <code>p(x)</code> es un polinomio, entonces <code>p(a)=0</code> para alg√∫n valor espec√≠fico a, si y s√≥lo si existe un polinomio <code>q(x)</code> tal que <code>(x-a)q(x)=p(x)</code>, y <code>deg(p)=deg(q)+1.</code></p>
<p>Esta expresi√≥n coincide con el polinomio de grado 2 como m√°ximo si nuestra traza de ejecuci√≥n ha sido correcta, es decir, ha obedecido a la restricci√≥n de paso que hemos definido.</p>
<p>Si la traza difiere de eso, entonces es poco probable que esta expresi√≥n produzca un polinomio de bajo grado.</p>
<h1 id="composici√≥n-polinomial"><a class="header" href="#composici√≥n-polinomial">Composici√≥n Polinomial</a></h1>
<p>El Polinomio de Composici√≥n en su traducci√≥n tambi√©n conocido como Composici√≥n Polinomial (CP), se realiza para demostrar eficazmente la validez del rastro de ejecuci√≥n, nos esforzamos por alcanzar los dos objetivos siguientes:</p>
<ol>
<li>Componer las restricciones sobre los polinomios de la traza para hacerlas cumplir en la traza.</li>
<li>Combinar las restricciones en un √∫nico polinomio (m√°s grande), denominado Composici√≥n Polinomial, de modo que se pueda utilizar una √∫nica prueba de grado bajo para atestiguar su grado bajo.</li>
</ol>
<h1 id="ampliando-el-polinomio"><a class="header" href="#ampliando-el-polinomio">Ampliando el polinomio</a></h1>
<p>Como hemos visto antes, los polinomios pueden utilizarse para construir buenos c√≥digos de correcci√≥n de errores, ya que dos polinomios de grado d, evaluados en un dominio considerablemente mayor que d, son diferentes en casi todas partes.</p>
<p>Observando esto, podemos extender la traza de ejecuci√≥n pensando en ella como una evaluaci√≥n de un polinomio en alg√∫n dominio, y evaluando este mismo polinomio en un dominio mucho mayor. Extendiendo de manera similar una traza de ejecuci√≥n incorrecta, se obtiene una cadena muy diferente, lo que a su vez hace posible que el verificador distinga entre estos casos utilizando un peque√±o n√∫mero de consultas.</p>
<h2 id="de-restricciones-polin√≥micas-al-problema-de-las-pruebas-de-bajo-grado"><a class="header" href="#de-restricciones-polin√≥micas-al-problema-de-las-pruebas-de-bajo-grado">De restricciones polin√≥micas al problema de las pruebas de bajo grado</a></h2>
<p>En general, si nuestro c√°lculo implica <code>N</code> pasos, la traza de ejecuci√≥n estar√° representada por polinomios de grado inferior a <code>N</code></p>
<ul>
<li><code>f(X) = c‚ÇÄ + c‚ÇÅX + c‚ÇÇX¬≤ +‚ãØ+ c…¥-‚ÇÅX·¥∫‚Åª¬π</code></li>
</ul>
<p>Los coeficientes <code>c·µ¢</code> est√°n en el campo <code>ùîΩ</code> y el l√≠mite <code>N</code> en el grado es t√≠picamente grande, quiz√° del orden de unos pocos millones. A pesar de ello, estos polinomios se denominan de bajo grado.</p>
<p>Esto se debe a que el punto de comparaci√≥n es el tama√±o del campo. Por interpolaci√≥n, toda funci√≥n sobre <code>ùîΩ</code> puede representarse mediante un polinomio.</p>
<p>La mayor√≠a de ellos tendr√°n un grado igual al tama√±o total del campo, por lo que, comparado con √©ste, <code>N</code> es realmente bajo.</p>
<p>Este tipo de funciones, coherentes con un polinomio de bajo grado, tambi√©n se conocen como c√≥digos <code>Reed-Solomon</code>.</p>
<p>Tras la generaci√≥n de la traza, el prover se compromete con ella. Recordemos que no queremos enviar los polinomios al verificador como un todo, pero necesitamos que el prover se comprometa con ellos.</p>
<p>En todo el sistema, los compromisos se ejecutan construyendo √°rboles de Merkle sobre las series de elementos de campo y enviando las ra√≠ces de Merkle al verificador.</p>
<p>Queremos que un verificador plantee al prover un n√∫mero muy reducido de preguntas y decida si acepta o rechaza la prueba con un alto nivel de precisi√≥n garantizado. Idealmente, al verificador le gustar√≠a pedir al prover que proporcione los valores en unos pocos lugares (aleatorios) en la traza de ejecuci√≥n, y comprobar que las restricciones polin√≥micas se mantienen para estos lugares.</p>
<p>Una traza de ejecuci√≥n correcta pasar√° naturalmente esta prueba.</p>
<p>Sin embargo, no es dif√≠cil construir una traza de ejecuci√≥n completamente err√≥nea (especialmente si sab√≠amos de antemano qu√© puntos se comprobar√≠an), que viole las restricciones s√≥lo en un punto de la traza √∫nico y, al hacerlo, llegar a un resultado completamente alejado y diferente. Identificar este fallo mediante un peque√±o n√∫mero de consultas aleatorias es altamente improbable.</p>
<p>Pero recuerda que los polinomios tienen algunas propiedades √∫tiles aqu√≠:</p>
<ul>
<li>Dos polinomios (diferentes) de grado <code>d</code> evaluados en un dominio considerablemente mayor que <code>d</code> son diferentes en casi todas partes.</li>
</ul>
<p>As√≠ que si tenemos un prover deshonesto, que crea un polinomio de bajo grado representando su traza (que es incorrecta en alg√∫n punto) y lo eval√∫a en un dominio grande, ser√° f√°cil ver que este es diferente al polinomio correcto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pruebas-de-bajo-grado"><a class="header" href="#pruebas-de-bajo-grado">Pruebas de Bajo Grado</a></h1>
<p>Las pruebas de bajo grado son realmente el coraz√≥n del proceso de verificaci√≥n.</p>
<p>El supuesto de comprobaci√≥n de bajo grado establece la existencia de un verificador probabil√≠stico que comprueba si una funci√≥n f es de grado como m√°ximo d ‚â™ |ùîΩ|. El verificador debe distinguir entre los dos casos siguientes:</p>
<ol>
<li><strong>La funci√≥n <code>f</code> es igual a un polinomio de bajo grado:</strong> es decir, existe un polinomio <code>p(x)</code> sobre <code>ùîΩ</code>, de grado menor que <code>d</code>, que coincide con <code>f</code> en todas partes.</li>
<li><strong>La funci√≥n <code>f</code> est√° lejos de TODOS los polinomios de bajo grado:</strong> por ejemplo, necesitamos modificar al menos el <strong>10%</strong> de los valores de <code>f</code> antes de obtener una funci√≥n que concuerde con un polinomio de grado inferior a <code>d</code>.</li>
</ol>
<p>La aritmetizaci√≥n muestra que un prover honesto que trate con una afirmaci√≥n verdadera caer√° en el primer caso, mientras que un prover (posiblemente malicioso) que intente <strong>&quot;probar&quot;</strong> una afirmaci√≥n falsa caer√°, con alta probabilidad, en el segundo caso.</p>
<p>Otra forma de ver esto es que el polinomio de traza correcto combinado con las restricciones ser√° necesariamente de grado bajo, el grado proviene del n√∫mero de pasos en nuestra traza (probablemente unos pocos millones), y la combinaci√≥n de esto con los polinomios de restricci√≥n (probablemente &lt; 10).</p>
<p>En general, cabr√≠a esperar que los polinomios <strong>&quot;correctos&quot;</strong> tuvieran un grado de alrededor de <code>10‚Å∑</code> , mientras que un prover tramposo que eligiera puntos al azar del campo <code>ùîΩ</code> obtendr√≠a, tras la interpolaci√≥n, polinomios de grado comparable al tama√±o del campo, es decir, del orden de <code>2¬≤‚Åµ‚Å∂</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fri"><a class="header" href="#fri">FRI</a></h1>
<p>FRI son las siglas de <a href="https://eccc.weizmann.ac.il/report/2017/134/">Fast Reed-Solomon IOP of Proximity</a>, es un protocolo que establece que un polinomio comprometido tiene un grado limitado.</p>
<p>El <a href="https://book.starknet.io/chapter_10/fri.html"><strong>FRI</strong></a> es complejo y gran parte del procesamiento que lo compone est√° dise√±ado para que las pruebas sean factibles y sucintas. Tambi√©n hay mucho procesamiento involucrado con la protecci√≥n contra diversos tipos de ataques que podr√≠an ser realizados por el prover, y garantizar que todo se lleva a cabo en el conocimiento cero.</p>
<p>Su objetivo es encontrar si un conjunto de puntos se encuentran mayoritariamente en un polinomio de bajo grado y puede alcanzar una complejidad de prueba lineal y una complejidad de verificaci√≥n logar√≠tmica.</p>
<p>En general, hay 2 etapas : commit y query, contenidas en los siguientes pasos repetidos.</p>
<ol>
<li>El verifier env√≠a un n√∫mero aleatorio al prover.</li>
<li>El prover genera un nuevo polinomio.</li>
<li>El verifier genera los conjuntos puntuales de consultas y los env√≠a al prover.</li>
<li>El prover eval√∫a los valores polin√≥micos correspondientes.</li>
<li>El verifier realiza una comprobaci√≥n de validez.</li>
</ol>
<p>Aprendamos como FRI es un protocolo entre un probador y un verificador, que establece que una codeword dada pertenece a un polinomio de grado bajo.</p>
<p>El prover conoce expl√≠citamente este codeword, mientras que el verificador s√≥lo conoce su ra√≠z Merkle y las hojas de su elecci√≥n, suponiendo la validaci√≥n satisfactoria de las rutas de autenticaci√≥n que establecen la pertenencia de las hojas al Merkle Tree.</p>
<p>Una de las grandes ideas para los sistemas de pruebas de los √∫ltimos a√±os ha sido la t√©cnica de dividir y doblar. La idea es reducir una afirmaci√≥n a dos afirmaciones de la mitad de tama√±o. A continuaci√≥n, ambas afirmaciones se fusionan en una sola utilizando pesos aleatorios proporcionados por el verificador.</p>
<p>Despu√©s de muchos pasos, la afirmaci√≥n se ha reducido a una de tama√±o trivial que es verdadera si y s√≥lo si (modulo alguna degradaci√≥n de seguridad insignificante) la afirmaci√≥n original era verdadera.</p>
<p>El verfier inspecciona los Merkle Tree (en concreto: pide al prover que proporcione las hojas indicadas con sus rutas de autenticaci√≥n) de rondas consecutivas para comprobar una relaci√≥n lineal simple.</p>
<p>Para los provers honestos, el grado de los polinomios representados tambi√©n se reduce a la mitad en cada ronda y, por tanto, es mucho menor que la longitud de la codeword. Sin embargo, para los provers maliciosos, este grado es uno menos que la longitud de la codeword. En el √∫ltimo paso, el prover env√≠a una codeword no trivial correspondiente a un polinomio constante.</p>
<p>Despu√©s de explorar los diferentes pasos en la creaci√≥n detr√°s de un STARKs y la importancia de las pruebas de integridad, es evidente que estas pruebas son fundamentales para garantizar la seguridad y confiabilidad de los sistemas del Futuro.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leve-introducci√≥n-cairo"><a class="header" href="#leve-introducci√≥n-cairo">Leve introducci√≥n Cairo</a></h1>
<p>Como √∫ltimo apartado para finalizar este documento, antes de adentrarnos en los pr√≥ximos temas sobre la arquitectura de Starknet y Cairo, haremos una breve introducci√≥n a Cairo y su relaci√≥n con la CVM. En este contexto, es relevante comprender c√≥mo todos los pasos de un c√°lculo pueden ser representados mediante polinomios, utilizando lo que se conoce como la Representaci√≥n Algebraica Intermedia (AIR).</p>
<p>Los bloques de c√°lculo pueden ser representados como AIR y tienen la capacidad de combinarse entre s√≠, lo que se convierte en la base de Cairo. Para ilustrarlo mediante una analog√≠a con el hardware:</p>
<ul>
<li><strong>ASIC (AIR)</strong></li>
<li><strong>CPU (varias AIR)</strong></li>
</ul>
<p>El nombre <strong>Cairo</strong> deriva de una CPU construida a partir de AIRs:</p>
<ul>
<li><strong>(CPU-AIR, Oh genial -&gt; CAIRO)</strong></li>
</ul>
<p>Cairo es un lenguaje funcional de alto nivel, no determinista y Turing completo, que cuenta con un modelo de memoria basado en registros y un compilador, el cual  produce una tabla de pasos computacionales llamada traza.</p>
<blockquote>
<p>En los programas escritos en Cairo, se especifican los resultados que se consideran aceptables, no c√≥mo obtenerlos.</p>
</blockquote>
<p>Vimos como en el proceso de construcci√≥n de pruebas STARK, el prover utiliza esta traza para crear Representaciones Algebraicas Intermedias (AIRs), que luego se combinan y se convierten en pruebas STARK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusi√≥n"><a class="header" href="#conclusi√≥n">Conclusi√≥n</a></h1>
<p>Con esto, concluimos nuestro profundo viaje por el mundo de la criptograf√≠a, explorando la generaci√≥n de claves privadas y p√∫blicas, as√≠ como sus diversas implementaciones. Hemos aprendido c√≥mo Starknet y los esquemas de firmas pueden prevenir ataques criptoanal√≠ticos, y hemos visto c√≥mo las STARKs han sido dise√±adas desde su inicio para brindar seguridad matem√°tica frente a ataques cu√°nticos, siguiendo sus principios fundamentales.</p>
<p>Starknet est√° sentando las bases de la criptograf√≠a moderna y creando un ecosistema escalable, integro y seguro por una de las mayores descentralizada como Ethereum, escalemos juntos.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="otras-arquitecturas"><a class="header" href="#otras-arquitecturas">Otras Arquitecturas</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>
        <script src="js/index.mjs"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
