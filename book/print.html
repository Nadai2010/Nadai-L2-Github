<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>L2 Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="Introducción.html"><strong aria-hidden="true">1.</strong> Introducción</a></li><li class="chapter-item "><a href="Bases_Criptográficas.html"><strong aria-hidden="true">2.</strong> Bases Criptográficas</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Criptografía_Simétrica.html"><strong aria-hidden="true">2.1.</strong> Criptografía Simétrica</a></li><li class="chapter-item "><a href="Criptografía_Asimétrica.html"><strong aria-hidden="true">2.2.</strong> Criptografía Asimétrica</a></li><li class="chapter-item "><a href="Criptografía_Híbridas.html"><strong aria-hidden="true">2.3.</strong> Criptografía Híbridas</a></li><li class="chapter-item "><a href="Firmas_Digitales.html"><strong aria-hidden="true">2.4.</strong> Firmas Digitales</a></li><li class="chapter-item "><a href="Generador_de_Claves.html"><strong aria-hidden="true">2.5.</strong> Generador de Claves</a></li><li class="chapter-item "><a href="Funciones_Hash.html"><strong aria-hidden="true">2.6.</strong> Funciones Hash</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Merkle_Tree_en_Blockchain.html"><strong aria-hidden="true">2.6.1.</strong> Merkle Tree en Blockchain</a></li><li class="chapter-item "><a href="Patricia_Merkle_Trie.html"><strong aria-hidden="true">2.6.2.</strong> Patricia Merkle Trie</a></li><li class="chapter-item "><a href="Sha256.html"><strong aria-hidden="true">2.6.3.</strong> SHA-256</a></li><li class="chapter-item "><a href="Keccak.html"><strong aria-hidden="true">2.6.4.</strong> Keccak - El nuevo SHA-3</a></li></ol></li><li class="chapter-item "><a href="Quantum_Secure.html"><strong aria-hidden="true">2.7.</strong> Quantum Secure</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Grover.html"><strong aria-hidden="true">2.7.1.</strong> Grover</a></li><li class="chapter-item "><a href="Shor.html"><strong aria-hidden="true">2.7.2.</strong> Shor</a></li><li class="chapter-item "><a href="Lattice.html"><strong aria-hidden="true">2.7.3.</strong> Lattice</a></li><li class="chapter-item "><a href="Kyber_Crystal.html"><strong aria-hidden="true">2.7.4.</strong> Kyber Crystal</a></li><li class="chapter-item "><a href="EOA_AA.html"><strong aria-hidden="true">2.7.5.</strong> EOA y AA - Firmantes</a></li></ol></li><li class="chapter-item "><a href="Starknet_AA.html"><strong aria-hidden="true">2.8.</strong> Starknet AA</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Stark_Curve.html"><strong aria-hidden="true">2.8.1.</strong> EC en Cairo - STARK Curve</a></li><li class="chapter-item "><a href="Secp256r1.html"><strong aria-hidden="true">2.8.2.</strong> MyBraavos Secp256r1</a></li><li class="chapter-item "><a href="Stark_Key.html"><strong aria-hidden="true">2.8.3.</strong> Creación de una Stark Key en StarkEx</a></li></ol></li><li class="chapter-item "><a href="Starknet_funciones_hash.html"><strong aria-hidden="true">2.9.</strong> Starknet y Funciones Hash</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Keccak_Starknet.html"><strong aria-hidden="true">2.9.1.</strong> Hash Keccak</a></li><li class="chapter-item "><a href="Pedersen_Starknet.html"><strong aria-hidden="true">2.9.2.</strong> Hash Pedersen</a></li><li class="chapter-item "><a href="Poseidon_Starknet.html"><strong aria-hidden="true">2.9.3.</strong> Hash Poseidon</a></li><li class="chapter-item "><a href="Hashing_Array.html"><strong aria-hidden="true">2.9.4.</strong> Hashing de Array</a></li></ol></li><li class="chapter-item "><a href="Starks.html"><strong aria-hidden="true">2.10.</strong> S-T-ARKs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starks_Propiedades.html"><strong aria-hidden="true">2.10.1.</strong> Propiedades de las STARKs</a></li><li class="chapter-item "><a href="Starks_Eficientes.html"><strong aria-hidden="true">2.10.2.</strong> STARKs eficientes</a></li><li class="chapter-item "><a href="Starks_Iops.html"><strong aria-hidden="true">2.10.3.</strong> IOPs</a></li><li class="chapter-item "><a href="Starks_Polinomios.html"><strong aria-hidden="true">2.10.4.</strong> Polinomios</a></li></ol></li><li class="chapter-item "><a href="Starks_Creacion.html"><strong aria-hidden="true">2.11.</strong> Creación de un STARK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starks_Aritmetizacion.html"><strong aria-hidden="true">2.11.1.</strong> Aritmetización</a></li><li class="chapter-item "><a href="Starks_Traza.html"><strong aria-hidden="true">2.11.2.</strong> Polinomio y Composición para nuestra Traza</a></li><li class="chapter-item "><a href="Starks_Bajo.html"><strong aria-hidden="true">2.11.3.</strong> Pruebas de Bajo Grado</a></li><li class="chapter-item "><a href="Starks_Fri.html"><strong aria-hidden="true">2.11.4.</strong> FRI</a></li></ol></li><li class="chapter-item "><a href="Cairo.html"><strong aria-hidden="true">2.12.</strong> Leve introducción a Cairo (AIR)</a></li><li class="chapter-item "><a href="Conclusión.html"><strong aria-hidden="true">2.13.</strong> Conclusiones</a></li></ol></li><li class="chapter-item "><a href="Arquitectura_Starkware.html"><strong aria-hidden="true">3.</strong> Arquitectura Starkware</a></li><li class="chapter-item "><a href="Otras_Arquitecturas.html"><strong aria-hidden="true">4.</strong> Otras Arquitecturas</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">L2 Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introducción"><a class="header" href="#introducción">Introducción</a></h1>
<p>¡Hola comunidad! 👋</p>
<p>Antes que nada nos gustaría expresar nuestro más sincero agradecimiento a todos aquellos que han contribuido y hecho posible la realización de esta exhaustiva investigación y documento sobre criptografía y como se adaptan en StarkWare. Especial reconocimiento a los expertos @X, @Y, @Z y @A, quienes han brindado sus valiosas correcciones y orientación en numerosos aspectos del trabajo. Su experiencia y conocimientos han sido fundamentales para alcanzar los resultados y conclusiones presentados en este informe.</p>
<p>En esta ocasión, estamos emocionados de presentar una serie de artículos profundos sobre el desarrollo detrás de Starkware. Recomendamos a los lectores que previamente hayan leído otros documentos y tengan conocimientos técnicos para una mejor comprensión, para este documento en concreto recomendamos:</p>
<p><a href="https://starkware.co/resource/stark-endgame/">Stark END-Game</a> | <a href="https://starkware.co/resource/stark-endgame/">Recursive Stark</a> |  <a href="https://starkware.co/resource/account-abstraction-improving-security-and-user-experience-for-mainstream-crypto-adoption/">Account Abstraction</a> | <a href="https://starkware.co/stark-math-a-very-short-primer/">Intro Maths Starks</a></p>
<p>El panorama actual es complejo, pero nos enorgullece contar con las mentes más brillantes trabajando en el ecosistema, una STARK que los une a todos.</p>
<p>¿Eres o serás uno de ellos? Antes de sumergirnos, exploraremos una serie de conceptos para establecer bases e historias sobre criptografía, lo que nos permitirá adentrarnos aún más en el ecosistema STARKs. ¡Comencemos!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bases-criptográficas"><a class="header" href="#bases-criptográficas">Bases Criptográficas</a></h1>
<p>La <a href="https://en.wikipedia.org/wiki/Cryptography"><strong>criptografía</strong></a> es el campo de estudio y desarrollo de técnicas y algoritmos para asegurar la confidencialidad, integridad y autenticidad de la información. Utilizando claves secretas o públicas, <strong>la criptografía transforma los datos en un formato incomprensible para terceros no autorizados</strong>, garantizando que solo los destinatarios legítimos puedan acceder a la información original. La criptografía desempeña un papel vital en la seguridad de las comunicaciones y el almacenamiento de datos, protegiendo la privacidad y la confianza en diversos ámbitos de la vida moderna.</p>
<ul>
<li>
<p><strong>Encryption:</strong> <a href="https://en.wikipedia.org/wiki/Encryption">el cifrado</a> es el proceso de convertir información legible en un formato ilegible llamado texto cifrado, mediante el uso de algoritmos y una clave. El objetivo principal del cifrado es proteger la confidencialidad de los datos, asegurando que solo las personas autorizadas puedan acceder y comprender la información cifrada. Para ello, se aplica una serie de transformaciones matemáticas al texto original, lo que dificulta su interpretación sin la clave correspondiente.</p>
</li>
<li>
<p><strong>Cryptographic protocol:</strong> <a href="https://en.wikipedia.org/wiki/Cryptographic_protocol">un protocolo criptográfico</a> o protocolo de seguridad (también llamado protocolo de cifrado) es un protocolo abstracto o concreto que realiza funciones relacionadas con la seguridad, aplicando métodos criptográficos.​ Un protocolo describe la forma en que un algoritmo debe usarse.</p>
</li>
<li>
<p><strong>Algorithm:</strong> <a href="https://es.wikipedia.org/wiki/Algoritmo">un algoritmo</a> de cifrado es un procedimiento que convierte un mensaje de texto plano en un texto cifrado. Los algoritmos modernos utilizan matemáticas avanzadas y una o varias claves de cifrado. Esto hace que sea relativamente fácil cifrar un mensaje, pero prácticamente imposible descifrarlo sin conocer las claves requeridas.</p>
</li>
</ul>
<h2 id="esquema-de-cifrado"><a class="header" href="#esquema-de-cifrado">Esquema de cifrado</a></h2>
<p>Estos esquemas definen cómo se realiza la transformación de los datos originales en texto cifrado y cómo se realiza la operación inversa para recuperar los datos originales a partir del texto cifrado. Un esquema de cifrado generalmente consta de los siguientes elementos:</p>
<ul>
<li>
<p><strong>Encryption Algorithm:</strong> vimos que es el conjunto de operaciones matemáticas utilizadas para cifrar los datos en texto cifrado.</p>
</li>
<li>
<p><strong>Decryption Algorithm:</strong> es el conjunto de operaciones matemáticas inversas utilizadas para descifrar el texto cifrado y recuperar los datos originales.</p>
</li>
<li>
<p><strong>Key:</strong> conocida como clave, es un valor secreto que se utiliza como entrada para el algoritmo de cifrado. La key determina cómo se realiza la transformación de los datos y es esencial para descifrar el texto cifrado.</p>
</li>
<li>
<p><strong>Protocols:</strong> establecen cómo se utiliza el esquema de cifrado, incluyendo la generación y distribución segura de claves, el manejo de errores y la gestión de la seguridad.</p>
</li>
</ul>
<p>Existen varios tipos de esquemas de cifrado:</p>
<ol>
<li>
<p>El <a href="https://academy.bit2me.com/que-es-criptografia-simetrica/"><strong>cifrado simétrico</strong></a> (donde se utiliza una sola clave tanto para cifrar como para descifrar),</p>
</li>
<li>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_asim%C3%A9trica"><strong>cifrado asimétrico</strong></a> o de clave pública (donde se utilizan pares de claves pública y privada)</p>
</li>
<li>
<p>Otras variantes de esquemas de cifrados como de <a href="https://es.wikipedia.org/wiki/Cifrador_de_flujo">flujo</a> y de <a href="https://es.wikipedia.org/wiki/Cifrado_por_bloques">bloque</a>. Cada esquema tiene sus propias características y se utiliza en diferentes contextos según los requisitos de seguridad y las necesidades específicas de la aplicación, pero nos centraremos en las principales para entender su funcionamiento antes de pasar a la evolución de las STARKs.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptografía-simétrica"><a class="header" href="#criptografía-simétrica">Criptografía Simétrica</a></h2>
<p>La historia de la criptografía simétrica se remonta a tiempos antiguos, pero su uso moderno se consolidó en el siglo XX con el desarrollo de métodos más sofisticados. Un ejemplo icónico es la <a href="https://en.wikipedia.org/wiki/Enigma_machine">máquina Enigma</a>, utilizada por los alemanes durante la Segunda Guerra Mundial para cifrar y descifrar mensajes, esta máquina demostró la eficacia de la criptografía simétrica en entornos militares.</p>
<p>Podemos ver la criptografía simétrica como una antigua y confiable llave maestra en el mundo de la seguridad informática. Es una técnica que ha sido utilizada desde hace mucho tiempo y aún en la actualidad sigue siendo efectiva y segura para proteger información en diversas situaciones.</p>
<p>Imagínate una llave que puede tanto cerrar como abrir una puerta. Los algoritmos criptográficos de clave simétrica funcionan de manera similar, utilizan la misma clave para cifrar el texto original y descifrar el texto cifrado, esta clave compartida es como el secreto que solo tú y los destinatarios autorizados conocen.</p>
<p><img src="./assets/simetrico.gif" alt="graph" /></p>
<div align="center">
<em>Criptografía Simétrica - Única Key</em>
</div>
<p>Sin embargo, a medida que la tecnología avanzaba y las capacidades de cómputo aumentaban, se hizo evidente que era necesario fortalecer los sistemas de cifrado. Surgieron nuevos desafíos y amenazas que requerían niveles más altos de seguridad. Es por eso que se desarrollaron otros métodos criptográficos, como la criptografía asimétrica, que utiliza pares de claves diferentes para el cifrado y el descifrado.</p>
<p>Aunque la criptografía simétrica ha evolucionado con el tiempo, todavía se utiliza ampliamente en muchos sistemas y aplicaciones. Su simplicidad y eficiencia la convierten en una opción popular para proteger datos en redes privadas, sistemas de comunicación y almacenamiento de información sensible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptografía-asimétrica"><a class="header" href="#criptografía-asimétrica">Criptografía Asimétrica</a></h1>
<p>Ahora hablemos como el concepto de algoritmos criptográficos de clave asimétrica, fue un enfoque revolucionario que introdujo un concepto completamente diferente, <strong>el uso de un par de claves complementarias, una pública y una privada</strong>, para asegurar la confidencialidad de los datos. Cada clave del par tenía una función específica:</p>
<ul>
<li><strong>Public key</strong>: esta clave pública se compartía abiertamente y se utilizaba para cifrar la información.</li>
<li><strong>Private key:</strong> esta clave privada se guardaba cuidadosamente y se utilizaba para descifrarla.</li>
</ul>
<p>Con la criptografía de clave pública, los mensajes cifrados podían ser transmitidos a través de redes inseguras sin el temor de que fueran interceptados y descifrados por personas no autorizadas, pero en este caso diferenciándose de la simétrica en que estos mensajes requerían un Private key y una Public key. Era como si se hubiera descubierto una nueva forma de comunicación secreta y segura en el mundo digital, fue un avance revolucionario en el campo de la criptografía.</p>
<p><img src="./assets/asimetrico.gif" alt="graph" /></p>
<div align="center">
<em>Criptografía Asimétrica - Creación de PK y PB</em>
</div>
<p>Algunos de los más destacados y utilizados son los siguiente:</p>
<ul>
<li>
<p><strong>RSA -</strong> <a href="https://es.wikipedia.org/wiki/RSA"><strong>Rivest-Shamir-Adleman:</strong></a> es un sistema criptográfico asimétrico de clave pública desarrollado en 1979. Su seguridad radica en el problema de la factorización de números enteros y se utiliza en diversos ámbitos de la transmisión de datos en Internet debido a su facilidad de uso. Este sistema consta de una clave pública RSA y una clave privada RSA.</p>
</li>
<li>
<p><strong>ECC -</strong> <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_de_curva_el%C3%ADptica"><strong>Elliptic Curve Cryptography:</strong></a> en la década de 1980 se desarrolló este enfoque de curva elíptica criptográfica, una variante de la criptografía asimétrica o de clave pública basada en las matemáticas de las curvas elípticas que proporciona niveles de seguridad similares o superiores a RSA pero con claves más cortas.</p>
</li>
<li>
<p><strong>ECDSA -</strong> <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf"><strong>Elliptic Curve Digital Signature Algorithm:</strong></a> en los Años 1990 nació ECDSA, un algoritmo de firma digital y autenticación en criptografía asimétrica, basado en curvas elípticas. Se utiliza en criptografía para garantizar la autenticidad, integridad de los datos. ECDSA se basa en la dificultad computacional de resolver el problema del logaritmo discreto en curvas elípticas.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptografía-híbrida"><a class="header" href="#criptografía-híbrida">Criptografía Híbrida</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_h%C3%ADbrida"><strong>cifrado híbrido</strong></a> utiliza las propiedades únicas de la criptografía de clave pública para intercambiar información secreta a través de un canal no confiable, combinando la eficacia del cifrado simétrico. Esto proporciona una solución práctica de extremo a extremo para garantizar la privacidad de los datos.</p>
<p>Aunque los algoritmos de clave pública, como RSA-OAEP, son menos eficientes que los algoritmos simétricos, generalmente no se utilizan directamente para cifrar los datos. Sin embargo, desempeñan un papel importante en el ecosistema criptográfico al permitir el intercambio seguro de claves.</p>
<p>Para utilizar el cifrado simétrico, las partes deben compartir una clave. Si ya existe un canal seguro, se puede enviar la clave a través de él. Sin embargo, si no hay un canal seguro disponible, se resuelve el problema del intercambio de claves utilizando la criptografía de clave pública.</p>
<ul>
<li><strong>DH -</strong> <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"><strong>Diffie–Hellman:</strong></a> el intercambio de claves DH es un algoritmo criptográfico de clave pública diseñado específicamente para acordar una clave simétrica en ausencia de un canal seguro.
La combinación de criptografía de clave pública para el intercambio de claves y el cifrado simétrico para el cifrado de datos en masa se conoce como cifrado híbrido.</li>
</ul>
<p>El cifrado híbrido se utiliza ampliamente en los protocolos de transferencia de datos para la web, como en la capa de seguridad de transporte <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">(TLS)</a>. Cuando te conectas a un sitio web que utiliza <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a> (HTTP seguro con TLS), tu navegador negocia los algoritmos criptográficos que aseguran la conexión. Estos algoritmos incluyen métodos para el intercambio de claves, cifrado simétrico y firmas digitales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="firmas-digitales"><a class="header" href="#firmas-digitales">Firmas digitales</a></h1>
<p>Los esquemas de firma digital son un tipo de criptografía de clave pública que garantiza la integridad, autenticidad y no repudio de los datos.</p>
<p>Es importante destacar que el esquema de firma digital puede variar dependiendo del algoritmo utilizado, ECDSA, es un ejemplo común de esquema de firma basado en criptografía de curva elíptica. Aquí EC recordemos que representa la curva elíptica utilizada y <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm"><strong>DSA</strong></a> (una variante de los esquemas de firma <a href="https://en.wikipedia.org/wiki/Schnorr_signature">Schnorr</a> y <a href="https://en.wikipedia.org/wiki/ElGamal_signature_scheme">ElGamal</a>) el algoritmo de firma digital. Cada esquema tiene sus propias características y propiedades de seguridad, y se selecciona según los requisitos y consideraciones específicas de la aplicación.</p>
<p>Cuando se trata de firmas digitales, los pasos generales suelen ser los siguientes:</p>
<ul>
<li>
<p><strong>Key generation:</strong> el Generador de Claves es un protocolo o algoritmo que genera <strong>un Keypar</strong>, un par de claves asimétricas como se explicó anteriormente compuestas por una public key y una private key. En el caso de la criptografía de curva elíptica (como ECDSA), se generan los parámetros necesarios para definir la curva y se elige una clave privada aleatoria. A partir de la clave privada, se calcula la clave pública correspondiente utilizando operaciones matemáticas específicas.</p>
</li>
<li>
<p><strong>Hash del mensaje:</strong> antes de firmar el mensaje, se aplica una función hash criptográfica al contenido del mensaje. Esto reduce el mensaje a un valor de longitud fija llamado resumen o hash. El objetivo es garantizar la integridad y eficiencia del proceso de firma, ya que es más rápido firmar y verificar un resumen más corto que el mensaje completo.</p>
</li>
<li>
<p><strong>Digital Signature:</strong> este proceso tiene el propósito de realizar una serie de operaciones matemáticas utilizando la clave privada y el hash del mensaje para generar la firma digital.</p>
</li>
<li>
<p><strong>Verify Signature:</strong> para verificar la autenticidad de la firma, se necesita la clave pública del firmante. Se aplica nuevamente la función hash al mensaje original y se utiliza la clave pública junto con la firma para realizar operaciones matemáticas específicas. Si el resultado coincide con la firma original, se considera que la firma es válida y se confirma la autenticidad del mensaje y del firmante.</p>
</li>
</ul>
<p>El proceso de firma puede considerarse como el cifrado del archivo mediante la clave privada. Para ello, la persona que firma utiliza su clave privada para producir una firma.</p>
<p>Exploraremos a continuación la relevancia de los diversos esquemas de firmas para garantizar la seguridad de nuestros datos, así como la forma en que Starknet usa AA para abstraer la firma de la validación. En este contexto, se pueden diseñar diferentes esquemas o configuraciones, como el <code>secp256r1</code>, una variante de STARK Curve, la versión amigable de ECDSA optimizada en Starknet. Este esquema de firma se puede utilizar para incorporar firmas en dispositivos modernos de manera biométrica, aislada y abstraída por naturaleza, lo que mejora significativamente la eficiencia, tal como se discutirá en detalle más adelante.</p>
<p>Por lo tanto, resulta crucial abordar el siguiente apartado relacionado con el uso de Key generation que desempeñan un papel fundamental en este contexto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-generator"><a class="header" href="#key-generator">Key generator</a></h1>
<p>Tenemos que entender cómo el generador de claves <a href="https://en.wikipedia.org/wiki/Key_generator"><strong>(Key generator)</strong></a> genera el Keypair, para lograrlo, es necesario trabajar con valores pseudoaleatorios que se utilizan en la generación de la private key. Un Key generator se puede implementar en un sistema con el propósito de generar y autenticar claves.</p>
<p>Key generator puede implementarse en cualquier sistema criptográfico que utilice la curva elíptica, como es el caso de <code>secp256k1</code> (una curva optimizada basada en las propiedades matemáticas de las curvas elípticas para proporcionar un esquema de firma digital seguro y eficiente), como Bitcoin y Ethereum.</p>
<p>Este generador de claves garantiza que, con alta probabilidad, las claves privadas generadas sean únicas y seguras, lo que a su vez respalda la integridad y autenticidad de las transacciones realizadas en la red.</p>
<h2 id="generadores-de-números-pseudoaleatorios"><a class="header" href="#generadores-de-números-pseudoaleatorios">Generadores de números pseudoaleatorios</a></h2>
<p>Para garantizar la seguridad usando la pseudoaleatoriedad estadística de un <strong>PRNG -</strong> <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator"><strong>Pseudorandom number generator</strong></a>, es crucial contar con una semilla inicial. Si la semilla es fácilmente predecible, generará valores predecibles de números y todo el proceso será inseguro.</p>
<p>Para lograr una inicialización segura del generador pseudoaleatorio, es necesario recolectar <a href="https://en.wikipedia.org/wiki/Entropy_(computing)"><strong>Entropía</strong></a>, que representa la aleatoriedad necesaria en el proceso.</p>
<h2 id="entropía"><a class="header" href="#entropía">Entropía</a></h2>
<p>La entropía o aleatoriedad impredecible en computación, generalmente se mide en bits. Tenemos varios ejemplos para entender el concepto y grado de aleatoriedad. Si mueve el mouse de su computadora, generará algunos eventos difíciles de predecir, como la ubicación de inicio y la ubicación final del cursor del mouse.</p>
<blockquote>
<p>Si suponemos que el mouse ha cambiado su posición en el rango de <code>[ 0 ... 255 píxeles ]</code>, la entropía recolectada de este movimiento del mouse debe ser de aproximadamente <strong>8 bits</strong>, porque <code>2⁸ = 255</code></p>
</blockquote>
<blockquote>
<p>Si se le pide al usuario que piense en un número en el rango <code>[ 0 ... 1000 ]</code>, este número tendrá alrededor de <strong>9-10 bits</strong> de entropía porque, <code>2¹⁰ = 1024</code></p>
</blockquote>
<p>Para recolectar 256 bits de entropía, es decir, para generar de forma segura un número entero de 256 bits, deberá tener en cuenta una secuencia de varios eventos similares (como movimientos del mouse e interracidades del teclado del usuario).</p>
<p>Aquí la importancia de dónde y cómo hemos generado nuestras claves privadas y públicas y las posibles vulnerabilidades en algunos malos usos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funciones-hash-y-funciones-hash-criptográficas"><a class="header" href="#funciones-hash-y-funciones-hash-criptográficas">Funciones hash y funciones hash criptográficas</a></h1>
<p>Este apartado es de suma importancia para comprender el funcionamiento de las funciones hash. A diferencia de los esquemas de cifrado o las firmas, las funciones hash no requieren de una clave. Cualquier persona puede calcular el hash de una entrada determinada, y la función hash siempre producirá la misma salida para la misma entrada.</p>
<p>Así que podemos definir una <a href="https://en.wikipedia.org/wiki/Hash_function"><strong>función hash</strong></a> como un algoritmo que toma una entrada, como un mensaje o un archivo, y produce una salida de longitud fija llamada hash o resumen. Esta salida es única para cada entrada específica, lo que permite la verificación de la integridad de los datos y garantiza que cualquier cambio en la entrada resultará en un hash completamente diferente.</p>
<p>Una <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function"><strong>función hash criptográfica</strong></a>, por otro lado, es aquella función hash que se utiliza en el ámbito de la criptografía, para evaluar la seguridad de una función de hash criptográfica, se consideran las siguientes propiedades:</p>
<ul>
<li><strong>Resistencia a la preimagen:</strong> partiendo de un valor <code>hash h</code>, es difícil encontrar un mensaje <code>m</code> que genere ese <code>hash</code>, es decir, <code>h = hash(m)</code>, este concepto está relacionado con el de una función de sentido único. Las funciones que carecen de esta propiedad son vulnerables a ataques de preimagen.</li>
<li><strong>Resistencia a la segunda preimagen:</strong> dado un mensaje <code>m₁</code>, es difícil encontrar otro mensaje <code>m₂</code> distinto a <code>m₁</code> que produzca el mismo valor de hash, es decir, <code>hash(m₁) = hash(m₂)</code>. Esta propiedad también se conoce como resistencia débil a colisiones. Las funciones que no cumplen esta propiedad son vulnerables a ataques de segunda preimagen.</li>
<li><strong>Resistencia a colisiones:</strong> es difícil encontrar dos mensajes diferentes <code>m₁</code> y <code>m₂</code> que produzcan el mismo valor de hash, es decir, <code>hash(m₁) = hash(m₂)</code>. Estas colisiones son conocidas como colisiones criptográficas de hash. Esta propiedad también se conoce como resistencia fuerte a colisiones. Se requiere que el tamaño del hash sea al menos el doble de largo para garantizar la resistencia a la preimagen.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-tree-en-blockchain"><a class="header" href="#merkle-tree-en-blockchain">Merkle Tree en Blockchain</a></h1>
<p>Ahora que hemos comprendido mejor qué es un hash, veamos cómo en criptografía y <a href="https://en.wikipedia.org/wiki/Computer_science">ciencias de la computación</a>, un árbol hash, también conocido cómo <a href="https://en.wikipedia.org/wiki/Merkle_tree"><strong>Merkle Tree o binary Merkle tree</strong></a>, es una <a href="https://en.wikipedia.org/wiki/Data_structure">estructura de datos</a> utilizada para garantizar la integridad de los contenidos almacenados en un sistema, como la tecnología blockchain.</p>
<p>Podemos ver los Merkle Trees como una estructura de árbol en la que cada &quot;hoja&quot; o nodo terminal, está etiquetado con el hash criptográfico de un bloque de datos. A su vez, cada nodo que no es una hoja, también conocido como rama, nodo interior o inodo, está etiquetado con el hash criptográfico de las etiquetas de sus nodos secundarios.</p>
<p>La construcción de un Merkle Tree implica dividir los datos en bloques más pequeños y aplicar una función de hash criptográfico a cada uno de ellos. Luego, los bloques hash se combinan en pares y se vuelven a hashear, repitiendo este proceso hasta obtener un único hash llamado raíz de Merkle o “Merkle root”. Esta raíz se coloca en la cabecera de un bloque o transacción y se utiliza como una firma digital que representa y verifica la integridad de todos los datos incluidos en el bloque.</p>
<p><img src="./assets/merkle.gif" alt="graph" /></p>
<div align="center">
<em>Ejemplo de estructura de un Merkle Tree</em>
</div>
<p>Una de las principales ventajas de los Merkle Trees es su capacidad para proporcionar una verificación eficiente y segura de los contenidos de una gran estructura de datos. Como cada nodo intermedio en el árbol está etiquetado con el hash criptográfico de las etiquetas de sus nodos secundarios, cualquier cambio realizado en los datos se reflejará en cambios en los hashes correspondientes.</p>
<p>En la tecnología blockchain que usan los Merkle Trees, los utilizan para garantizar la integridad de los datos almacenados en cada bloque de la cadena. Cada bloque contiene una lista de transacciones, y el Merkle Tree se construye utilizando los hashes de estas transacciones.</p>
<p>Cuando se agrega un nuevo bloque a la cadena, la raíz de Merkle del bloque anterior se incluye en el nuevo bloque, creando una cadena enlazada de árboles de Merkle. Esto permite verificar rápidamente la integridad de cualquier bloque en la cadena sin necesidad de verificar todos los datos desde el inicio. Además, si algún dato se modifica en un bloque, el hash del bloque cambiará, lo que afectará la raíz de Merkle y señalará la alteración en la cadena.</p>
<p>Algunos casos posibles de uso de los binary Merkle Trees para los diferentes esquemas pueden ser:</p>
<ul>
<li><strong>Los binary Merkle Trees:</strong> son estructuras de datos muy eficientes para autenticar información que se presenta en formato de &quot;lista&quot;, es decir, una secuencia de elementos consecutivos.</li>
<li><strong>Los transaction trees:</strong> también resultan beneficiosos, ya que una vez creado el árbol, no importa cuánto tiempo se tarde en editarlo, ya que permanecerá inmutable.</li>
<li><strong>Los State trees:</strong> sin embargo, cuando se trata de un árbol que almacena estados la situación se vuelve más compleja, el estado en Ethereum, que consiste en un mapa de valores clave donde:
<ul>
<li><strong>Las claves son direcciones</strong></li>
<li><strong>Los valores son las declaraciones de cuenta que incluyen:</strong> saldo, nonce, código y almacenamiento asociados a cada cuenta, r</li>
<li><strong>Requiere la construcción de una prueba de transición de estado de Merkle</strong> <a href="https://medium.com/@chiqing/verify-ethereum-account-balance-with-state-proof-83b51ceb15cf">(Merkle state transition proof)</a></li>
</ul>
</li>
</ul>
<p>Así que, comprender el funcionamiento de los State Trees y su optimización de datos es crucial en el contexto actual donde los datos y los hashes desempeñan un papel fundamental. En el caso de Ethereum, uno de los principales actores en el ámbito de los State Trees, se han incorporado modificaciones interesantes usando Patricia Merkle Trie.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patricia-merkle-trie"><a class="header" href="#patricia-merkle-trie">Patricia Merkle Trie</a></h1>
<p>La especificación de Ethereum define el <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/"><strong>Modified Merkle Patricia Trie</strong></a> (también conocido como MPT) este método se utiliza para guardar estados. Básicamente, el MPT es una combinación del Patricia trie y el Merkle tree, con algunas optimizaciones adicionales adaptadas a las características de Ethereum.</p>
<p>Patricia trie, <a href="https://en.wikipedia.org/wiki/Radix_tree">(Radix tree o Radix trie)</a>, árbol de prefijos compacto <strong>(compact prefix tree)</strong> o árbol de prefijos comprimido <strong>(compressed trie)</strong>, es una sofisticada estructura de datos que ofrece una optimización espacial en la representación de [Tries] (árboles de prefijos). Una de las características clave de este tipo de árbol es la fusión de nodos cuando un nodo es hijo único de su padre, lo que contribuye a una mayor eficiencia y rendimiento.</p>
<p>Esta estructura es un tipo de <strong>árbol de búsqueda k-ary</strong>, siendo un <a href="https://en.wikipedia.org/wiki/M-ary_tree">m-ary tree</a> (también conocido como <code>n-ary tree</code>, <code>k-ary tree</code> o <code>k-way tree</code>) un árbol raíz en el cual cada nodo tiene como máximo m hijos. Ambas estructuras de datos se utilizan para localizar claves específicas dentro de un conjunto.</p>
<p>Estos árboles son completamente deterministas, lo que significa que aquellos con las mismas asociaciones de (clave, valor) están garantizados de ser idénticos, hasta el último byte. Esto asegura que tengan el mismo hash raíz, lo que proporciona la deseada eficiencia de <code>O(log(n))</code> para inserciones, búsquedas y eliminaciones. Además, son más fáciles de entender y programar que alternativas más complejas basadas en comparaciones, como los <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree.</a></p>
<p>El Patricia Merkle Trie combina la estructura de un árbol de búsqueda binario con la estructura de árbol de Merkle, lo cual permite verificar eficientemente la integridad de los datos y proporciona una representación compacta del estado completo de la cadena.</p>
<p>El uso del Patricia Merkle Trie en Ethereum ofrece ventajas significativas en términos de eficiencia y escalabilidad. Permite realizar consultas rápidas sobre el estado de las cuentas y los contratos, evitando la necesidad de recorrer todo el estado completo. En cambio, solo es necesario verificar y acceder a los nodos relevantes en el árbol, lo que ahorra tiempo y recursos.</p>
<p>Además, esta estructura de árbol facilita la implementación de funciones de snapshot y revert en Ethereum. Estas funciones permiten crear instantáneas del estado del sistema en momentos específicos y revertir cambios en caso de errores o ataques, brindando una capa adicional de seguridad y confiabilidad a la red blockchain.</p>
<p><img src="" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>La comprensión de los Merkle Trees y el MPT resulta especialmente relevante al explorar otras estructuras de datos criptográficas, como las Merkle Mountain Ranges (MMRs) en Herodotus para las Storage Proof. Las MMRs pueden considerarse una lista de Árboles de Merkle, donde cada árbol se representa como una montaña y la lista completa forma el rango. La utilización de funciones hash específicas y sus características de seguridad se explorarán para comprender cómo crear estos árboles de manera eficiente y óptima.</p>
<p>Por lo tanto, es crucial comprender a fondo las diferentes funciones hash y sus propiedades para tomar decisiones informadas sobre la selección y optimización de las mismas en la construcción de estructuras de datos criptográficas más eficientes y seguras en los Árboles de Merkle.</p>
<p>Las funciones hash desempeñan un papel fundamental en garantizar la integridad y la seguridad de los datos almacenados en los árboles de Merkle, ya que se utilizan para calcular los hashes de los nodos y verificar su integridad durante la construcción y la verificación del árbol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha-256"><a class="header" href="#sha-256">SHA-256</a></h1>
<p>Es hora de examinar algunos ejemplos de funciones hash criptográficas ampliamente utilizadas, un ejemplo es <code>SHA-256</code> <a href="https://es.wikipedia.org/wiki/SHA-2"><strong>(Secure Hash Algorithm 256-bit)</strong></a>, <strong>que es una función de hash criptográfica perteneciente a la familia de algoritmos SHA-2.</strong> Esta función acepta una entrada de cualquier longitud y genera una salida de 256 bits que se considera única y asociada de forma irreversible a dicha entrada.</p>
<p>Pueden probar la generación de un hash utilizando cualquier <a href="https://miniwebtool.com/es/sha256-hash-generator/">generador en línea</a>. En este caso, <a href="https://bfotool.com/category/encode-decoder">realizamos pruebas</a> utilizando la función hash <code>SHA-256</code> y <code>keccak-256</code>, también pueden explorar y probar <a href="https://bfotool.com/category/encode-decoder">más funciones hash desde aquí.</a></p>
<p>El cambio de un solo bit causa un efecto avalancha, lo que significa que incluso un cambio mínimo como un <code>.</code> en la entrada, produce un cambio significativo en la salida. Puedes revisar el hash de <code>L2 en Español</code> y <code>L2 en Español.</code></p>
<p><img src="./assets/Sha256.png" alt="graph" /></p>
<div align="center">
<em>Salida de datos completamente diferente añadiendo un "."</em>
</div>
<p><code>SHA-256</code> se utiliza ampliamente en criptografía, y cuenta con diversos casos de uso destacados:</p>
<ol>
<li><strong>Verificación de integridad:</strong> <code>SHA-256</code> se utiliza para verificar la integridad de los datos almacenados en un sistema. Al calcular el hash de un archivo o conjunto de datos, se puede comparar con el hash original para detectar cualquier cambio o alteración en los datos.</li>
<li><strong>Firmas digitales:</strong> las firmas digitales se generan mediante algoritmos criptográficos y se basan en la función SHA-256 para asegurar la autenticidad e integridad de los mensajes. El hash <code>SHA-256</code> se utiliza para resumir y proteger la información que se firma digitalmente.</li>
<li><strong>Almacenamiento seguro de contraseñas:</strong> en lugar de almacenar contraseñas en texto plano, los sistemas de seguridad suelen almacenar el hash <code>SHA-256</code> de las contraseñas. Cuando un usuario ingresa su contraseña, se calcula el hash y se compara con el valor almacenado, lo que permite verificar la autenticidad de la contraseña sin almacenarla directamente.</li>
<li><strong>Generación de claves criptográficas:</strong> <code>SHA-256</code> se utiliza en algoritmos de generación de claves criptográficas para producir claves aleatorias y seguras.</li>
</ol>
<p>En resumen, <code>SHA-256</code> es una función hash criptográfica ampliamente utilizada que forma parte de la familia de algoritmos <code>SHA-2</code>, la hace ideal para verificar la integridad de los datos, generar firmas digitales, almacenar contraseñas de forma segura y generar claves criptográficas. <code>SHA-256</code> ha demostrado su robustez y eficacia en numerosos casos de uso en criptografía. Ahora es el turno de explorar otra función hash criptográfica más moderna llamada Keccak.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak---el-nuevo-sha-3"><a class="header" href="#keccak---el-nuevo-sha-3">Keccak - El nuevo SHA-3</a></h1>
<p>Ahora nos centraremos en el <code>SHA-3</code> <a href="https://en.wikipedia.org/wiki/SHA-3"><strong>(Secure Hash Algorithm 3)</strong></a>, es un estándar de función hash criptográfica diseñado por los criptógrafos Joan Daemen y Gilles Van Assche. El algoritmo utilizado en <code>SHA-3</code> se llama <a href="https://keccak.team/index.html"><strong>Keccak</strong></a>, el cual fue <a href="https://www.federalregister.gov/documents/2015/08/05/2015-19181/announcing-approval-of-federal-information-processing-standard-fips-202-sha-3-standard"><strong>seleccionado como el ganador del concurso</strong></a> organizado por el Instituto Nacional de Estándares y Tecnología <a href="https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology">(NIST)</a> para encontrar un nuevo estándar de función hash criptográfica.</p>
<p>A diferencia de <code>SHA-256</code>, <code>Keccak</code> utiliza una estructura y operaciones diferentes. En lugar de rondas, <code>Keccak</code> se basa en una construcción llamada función de esponja <a href="https://en.wikipedia.org/wiki/Sponge_function">(Sponge function)</a>, que se basa en una función pseudoaleatoria amplia o <a href="https://keccak.team/glossary.html#permutation">(permutation)</a> pseudoaleatorio permitiendo ingresar <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<p><code>Keccak-256</code> es una función hash criptográfica utilizada en Ethereum. Pertenece a la familia de algoritmos <code>SHA-3</code> y se emplea ampliamente en la plataforma Ethereum para diversos propósitos.</p>
<p>Algunos casos de uso de <code>Keccak-256</code> incluyen:</p>
<ul>
<li>Ethereum utiliza <code>Keccak-256</code> para garantizar la integridad de los datos y generar identificadores únicos (hash) para verificar la autenticidad de los archivos y mensajes en sistemas criptográficos.</li>
<li>También se utiliza en la firma criptográfica de pequeño tamaño, donde en lugar de firmar la entrada completa, se firma el hash <code>Keccak-256</code> del mensaje o dato.</li>
<li><code>Keccak-256</code> es utilizado para obtener una identificación única y determinista de una colección de datos. Por ejemplo, en Ethereum, las direcciones de Ethereum se derivan de claves públicas o contratos utilizando la función hash unidireccional <code>Keccak-256</code>.</li>
</ul>
<p>Las direcciones Ethereum son números hexadecimales, identificadores derivados de los últimos 20 bytes del hash <code>Keccak-256</code> de la clave pública.</p>
<p>A diferencia de las direcciones de Bitcoin, que están codificadas en la interfaz de usuario de todos los clientes para incluir una suma de verificación incorporada para proteger contra direcciones mal escritas, las direcciones de Ethereum se presentan como hexadecimales sin ninguna suma de verificación.</p>
<p><img src="./assets/Keccak.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El algoritmo <strong>Keccak</strong> utiliza la <a href="https://keccak.team/glossary.html#sponge_construction"><strong>Sponge construction</strong></a> para procesar los datos de entrada de longitud variable para generar una salida de longitud variable. Esta construcción se basa en una función interna llamada <code>&quot;F&quot;</code> que opera en un número fijo de bits, denotado como <code>&quot;width&quot;</code> <a href="https://keccak.team/glossary.html#width">(anchura)</a>.</p>
<p>La anchura total del algoritmo Keccak se determina sumando dos componentes, el valor de <code>&quot;r&quot;</code> <a href="https://keccak.team/glossary.html#rate">(rate)</a> y el valor de <code>&quot;c&quot;</code> <a href="https://keccak.team/glossary.html#capacity">(capacity)</a>, donde <code>b = r + c</code>.</p>
<ul>
<li>El valor de <code>&quot;r&quot;</code> representa la cantidad de bits absorbidos en cada paso de la función esponja, es decir, <strong>la capacidad de absorción de la esponja.</strong> Un valor de <code>&quot;r&quot;</code> más grande permite procesar más información en cada paso, lo que reduce la cantidad de pasos necesarios para procesar una entrada específica.</li>
<li>El valor de <code>&quot;c&quot;</code> representa la capacidad de la esponja, es decir, <strong>la cantidad de bits que se mantienen en el estado interno del algoritmo después de cada paso de absorción</strong>. Estos bits se mezclan con los datos de entrada y el resultado de la función interna <code>&quot;F&quot;</code>. La capacidad afecta la resistencia del algoritmo a ataques criptográficos como colisiones o preimagen.</li>
</ul>
<p>La suma de <code>&quot;r&quot;</code> y <code>&quot;c&quot;</code> da como resultado el número total de bits, <code>&quot;b&quot;</code>, utilizados en la función esponja de Keccak. Este valor determina la longitud del estado interno y, por lo tanto, la longitud de la salida generada por el algoritmo.</p>
<h2 id="funcionamiento-keccak"><a class="header" href="#funcionamiento-keccak">Funcionamiento keccak</a></h2>
<p>El algoritmo funciona de la siguiente manera, inicialmente la cadena de entrada se rellena con bits adicionales para enmascarar el mensaje inicial y se divide en bloques de longitud <code>&quot;r&quot;</code> bits. Luego, los <code>&quot;b&quot;</code> bits de estado se inicializan a <code>0</code>, que da inicio a la <strong>Sponge construction</strong> en dos fases <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<ul>
<li><strong>Fase Absorbing:</strong> a los bloques de entrada de longitud <code>r-bits</code> se les aplica un <a href="https://en.wikipedia.org/wiki/XOR_cipher">XOR</a> (toma dos bits y devuelve un resultado que es 1 si solo uno de los bits es 1, y 0 en caso contrario) a los primeros <code>r</code> bits del estado, alternándose con la función <code>f</code>. Cuando todos los bloques han sido procesados, se pasa a la siguiente fase.</li>
<li><strong>Fase Squeezing:</strong> los primeros <code>r</code> bits del estado son devueltos como bloques de salida, alternándose con ejecuciones de la función <code>f</code>. El número de bloques de salida es seleccionado por el usuario.</li>
</ul>
<p>A continuación os dejamos una tabla que enumeran algunas de las diferencias entre <code>SHA-256</code> y <code>Keccak-256</code>.</p>
<p><img src="./assets/Comparativa_Sha_keccak.png" alt="graph" /></p>
<div align="center">
<em>Algunas diferencias entre SHA-256 y Keccak-256</em>
</div>
<p>Vemos cómo cada tipo de criptografía o función hash tiene características distintas. En el contexto actual de la computación cuántica en constante evolución, es crucial abordar las preocupaciones emergentes sobre seguridad. Algunos algoritmos criptográficos podrían ser vulnerables a los ataques cuánticos en un futuro cercano. Es en este punto donde entra en juego el concepto de criptografía <a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography">Post-Quantum</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantum-secure"><a class="header" href="#quantum-secure">Quantum Secure</a></h1>
<p>Así que es hora de aprovechar lo que hemos aprendido y explorar lo que podría suceder en un escenario teórico apocalíptico. Pero antes comencemos con una breve descripción sobre <a href="https://es.wikipedia.org/wiki/Computaci%C3%B3n_cu%C3%A1ntica">computación cuántica</a> para sumergirnos en el tema. <strong>No es más que un modelo de computación basado en la</strong> <a href="https://es.wikipedia.org/wiki/Mec%C3%A1nica_cu%C3%A1ntica"><strong>física cuántica</strong></a>, que funciona de manera diferente a las computadoras clásicas (el tipo de computadoras que usamos habitualmente) y tiene la capacidad de realizar tareas que estas últimas no pueden, como romper ciertos algoritmos de manera eficiente.</p>
<blockquote>
<p><strong>¡Así que espera un momento!</strong> Antes de que tu imaginación se desborde y te veas rodeado de supercomputadoras cuánticas capaces de solucionar todos nuestros problemas, déjame contarte una pequeña anécdota.</p>
</blockquote>
<blockquote>
<p><em>Ah, las computadoras cuánticas, esas criaturas de la física cuántica que nos hacen soñar con un futuro lleno de posibilidades. Pero, ¿sabías que no son máquinas mágicas capaces de resolver todos nuestros problemas informáticos en un abrir y cerrar de ojos?</em></p>
</blockquote>
<blockquote>
<p><strong>Imagina esto:</strong> las computadoras cuánticas son como esas personas brillantes que son súper eficientes en ciertas tareas, pero bastante débiles en otras. Son como el genio matemático que resuelve complicados problemas de cálculo en segundos, pero se le olvida cómo atarse los zapatos.</p>
</blockquote>
<blockquote>
<p><em>Entonces, sí, las computadoras cuánticas pueden ser increíblemente poderosas cuando se trata de ciertos problemas específicos, como el factorizar números grandes o buscar en enormes bases de datos. Pero cuando se trata de tareas cotidianas, como revisar correos electrónicos o navegar por la web, bueno, digamos que son como un caracol tratando de correr una maratón.</em></p>
</blockquote>
<p>Después de esta pequeña relato, es importante comprender el concepto de criptografía post-cuántica <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>(PQC)</strong></a>, también conocida como <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>Resistente a la Computación Cuántica</strong></a>, se refiere a algoritmos criptográficos especialmente algoritmos de clave pública, que se consideran seguros contra los ataques criptoanalíticos llevados a cabo por computadoras cuánticas.</p>
<p>A medida que avanza la computación cuántica, se espera que algunos algoritmos y técnicas criptográficas tradicionales utilizadas en los sistemas de seguridad actuales sean vulnerables a los ataques cuánticos. Esto se debe a la capacidad de las computadoras cuánticas para realizar cálculos a una escala exponencialmente mayor que las computadoras clásicas, lo que podría comprometer la seguridad de los sistemas criptográficos actuales.</p>
<p>Es bien sabido en informática que las computadoras cuánticas podrán romper algunos algoritmos criptográficos, especialmente los criptosistemas de clave pública como <strong>RSA</strong>, el intercambio de llaves <strong>Diffie–Hellman</strong> y <strong>ECDSA</strong>, que dependen del <a href="https://es.wikipedia.org/wiki/Factorizaci%C3%B3n_de_enteros"><strong>IFP</strong></a> (problema de factorización en números primos), el <a href="https://es.wikipedia.org/wiki/Logaritmo_discreto"><strong>DLP</strong></a> (problema del logaritmo discreto) y el ECDLP (problema del logaritmo discreto de curva elíptica). Todos estos problemas podrían resolverse fácilmente en una computadora cuántica suficientemente poderosa que ejecute el algoritmo de Shor.</p>
<p>Pero los algoritmos cuánticos no significarán el fin de la criptografía, porque:</p>
<ul>
<li>Solo algunos criptosistemas son inseguros frente a la computación cuántica (como RSA, DHKE, ECDSA y ECDH).</li>
<li>Algunos criptosistemas son seguros frente a la computación cuántica y solo se verán ligeramente afectados (como los hash criptográficos, algoritmos <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_de_autenticaci%C3%B3n_de_mensaje">MAC</a> y cifrados de clave simétrica como <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard?wprov=srpw1_0">AES</a>, siempre que se utilicen tamaños de clave suficientemente grandes).</li>
</ul>
<p>A diferencia de la amenaza que representa la computación cuántica para los algoritmos de clave pública actuales, <strong>la mayoría de los algoritmos criptográficos simétricos y las funciones hash actuales se consideran relativamente seguros contra ataques de computadoras cuánticas.</strong> Si bien el algoritmo cuántico de Grover acelera los ataques contra los cifrados simétricos, duplicar el tamaño de la clave puede bloquear eficazmente estos ataques. Por lo tanto, la criptografía simétrica post-cuántica no necesita diferir significativamente de la criptografía simétrica actual.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-grover-y-la-búsqueda-no-estructurada"><a class="header" href="#el-algoritmo-de-grover-y-la-búsqueda-no-estructurada">El algoritmo de Grover y la búsqueda no estructurada</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Algoritmo_de_Grover">algoritmo de Grover</a> es un <a href="https://es.wikipedia.org/wiki/Algoritmo_cu%C3%A1ntico">algortimo cuántico</a> para la búsqueda en una secuencia no ordenada de datos con <code>N</code> componentes en un tiempo <a href="https://es.wikipedia.org/wiki/Cota_superior_asint%C3%B3tica">O</a>(N¹/₂), y con una necesidad adicional de espacio de almacenamiento de <code>O(logN)</code>. Fue inventado por Lov K. Grover en <a href="https://es.wikipedia.org/wiki/1996">1996</a>.</p>
<p>Aunque el algoritmo de Grover es eficiente, su paralelización óptima resulta complicada y no se espera que las computadoras cuánticas actuales tengan suficiente potencia para comprometer la seguridad de esquemas como ECDSA o de funciones de hash como SHA256.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-shor-teórico-y-su-impacto-en-ecdsa"><a class="header" href="#el-algoritmo-de-shor-teórico-y-su-impacto-en-ecdsa">El algoritmo de Shor teórico y su impacto en ECDSA</a></h1>
<p>El <a href="https://en.wikipedia.org/wiki/Shor&#x27;s_algorithm"><strong>algoritmo de Shor</strong></a> es un algoritmo cuántico desarrollado por Peter Shor en 1994. Este algoritmo es conocido por su capacidad para factorizar grandes números enteros de manera mucho más eficiente que los algoritmos clásicos conocidos, lo que tiene implicaciones importantes para la seguridad de algunos sistemas criptográficos basados en la factorización de números enteros.</p>
<p>En el contexto de sistemas centralizados, como los sistemas bancarios, ECDSA se utiliza para garantizar la autenticidad de las transacciones, proteger la confidencialidad de la información y asegurar la integridad de los datos. En el ámbito de Bitcoin y Ethereum, si bien los algoritmos de búsqueda cuántica, como el algoritmo de Shor, podrían eventualmente romper la ECDSA, es importante destacar que estos algoritmos aún están en una etapa teórica.</p>
<p>Cada implementación de algoritmos o protocolos puede ser diversa, ya sea privada o abstracta. Nos hemos centrado en los principios básicos comunes de ECDSA, además se espera que la implementación práctica de algoritmos de búsqueda cuántica sea un desafío técnico debido a los requisitos de recursos y la necesidad de superar errores cuánticos.</p>
<p>Aquí tienes una descripción general de en qué consisten algunos problemas que se consideran complejos de resolver mediante la computación clásica.</p>
<h2 id="ifp"><a class="header" href="#ifp">IFP</a></h2>
<p>El IFP se refiere al desafío de descomponer un número entero grande en sus factores primos. En el caso de números pequeños, esto puede hacerse fácilmente mediante el uso de algoritmos como <a href="https://yosoytuprofe.20minutos.es/2022/11/09/que-es-la-criba-de-eratostenes-y-cual-es-su-importancia-en-las-matematicas/">el cribado de Eratóstenes</a> o <a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm_for_logarithms">el algoritmo de factorización de Pollard</a>.</p>
<p>A modo de ejemplo simplificado, supongamos que queremos factorizar el número compuesto <code>N = 35</code> utilizando el algoritmo de Shor. Después de aplicar el algoritmo, encontraríamos que los factores primos de <code>N</code> son <code>5 y 7</code>.</p>
<p>Sin embargo, a medida que los números crecen en tamaño, el IFP se vuelve cada vez más difícil de resolver. De hecho, la seguridad de muchos sistemas criptográficos se basa en la dificultad de factorizar números grandes en tiempo razonable, como el popular algoritmo RSA.</p>
<h2 id="dlp"><a class="header" href="#dlp">DLP</a></h2>
<p>Por otro lado, el DLP implica encontrar el exponente desconocido de una potencia modular dada. En términos más sencillos, se trata de resolver la ecuación <code>(y = gˣ mod p)</code> para el exponente desconocido <code>(x)</code>, donde <code>(g)</code> y <code>(p)</code> son números conocidos e <code>(y)</code> es el resultado de la operación de potenciación modular. Para valores pequeños de <code>(p)</code>, el DLP puede resolverse mediante la aplicación de métodos exhaustivos como la prueba y error.</p>
<p>A modo de ejemplo simplificado, sería encontrar el logaritmo discreto de <code>base 2</code> para el número <code>5</code> <code>módulo 11</code>. Esto implica encontrar el valor de <code>x</code> en la ecuación <code>2ˣ ≡ 5 (mod 11).</code></p>
<p>Realizando los cálculos paso a paso:</p>
<ul>
<li>2¹ ≡ 2 (mod 11)</li>
<li>2² ≡ 4 (mod 11)</li>
<li>2³ ≡ 8 (mod 11)</li>
<li>2⁴ ≡ 5 (mod 11)</li>
</ul>
<p>Entonces, el valor de <code>x</code> que satisface la ecuación <code>2ˣ ≡ 5 (mod 11)</code> es <code>x = 4</code>.</p>
<h2 id="ecdlp"><a class="header" href="#ecdlp">ECDLP</a></h2>
<p>La seguridad de esquemas criptográficos basados en <strong>ECC</strong>, como <strong>ECDSA</strong>, se basa en la dificultad de resolución del problema del logaritmo discreto de curva elíptica o <strong>ECDLP</strong>. Las curvas elípticas son objetos matemáticos utilizados en criptografía de clave pública, y el <strong>ECDLP</strong> sería el problema de hallar el valor de <code>‘K’</code> en esta ecuación, <code>P =k⋅G</code>, donde <code>P</code> es un punto en la curva, <code>k</code> es el valor que debemos hallar y <code>G</code> es un punto base conocido (el generador).</p>
<p>Al igual que en el caso del <strong>DLP</strong>, el <strong>ECDLP</strong> se vuelve más difícil de resolver a medida que el tamaño de los números involucrados en esas expresiones matemáticas aumentan</p>
<h2 id="ecdsa"><a class="header" href="#ecdsa">ECDSA</a></h2>
<p>Por último llegamos a un algoritmo ampliamente utilizado y conocido como es el <strong>ECDSA</strong>, que se utiliza comúnmente en blockchain. La clave pública se obtiene multiplicando un punto base conocido (llamado generador) en la curva elíptica por un entero, que representa la llave privada. El desafío radica en encontrar ese valor privado a partir del punto público conocido en la curva.</p>
<p>La curva elíptica <strong>secp256k1</strong> está definida por la ecuación: <code>y² = x³ + ax + b</code> sobre <code>𝔽p</code> donde <code>p</code> es un número primo grande.</p>
<p>El algoritmo de Shor, en su versión completa y ejecutado en un computador cuántico lo suficientemente grande y estable, podría factorizar el número primo <code>p</code> en esta ecuación, lo que proporcionaría información sobre el orden del subgrupo cíclico relacionado con la curva.</p>
<p>Si se pudiera determinar el orden del subgrupo cíclico relacionado con la curva <code>secp256k1</code> utilizando el algoritmo de <strong>Shor</strong>, sería posible encontrar el valor privado a partir de la clave pública. Esto comprometería la seguridad de <strong>ECDSA</strong>, ya que la clave privada es fundamental para generar firmas digitales y autenticar transacciones. Es importante destacar que el algoritmo de Shor plantea un desafío para los sistemas criptográficos actuales basados en la factorización de números enteros o en el logaritmo discreto, como <strong>RSA</strong> y <strong>ECDSA</strong>.</p>
<p>No obstante, la implementación práctica de un algoritmo cuántico capaz de realizar estos cálculos, como los mencionados ejemplos, todavía se encuentra en desarrollo y no representa una amenaza inmediata para los sistemas criptográficos utilizados en la actualidad. La investigación y el desarrollo continuo en criptografía pos-cuántica son fundamentales para garantizar la seguridad en un entorno tecnológico en constante evolución.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptografía-basada-en-lattice-previene-shor"><a class="header" href="#criptografía-basada-en-lattice-previene-shor">Criptografía basada en Lattice previene Shor</a></h2>
<p>Ahora deberemos aprender cómo una verificación de esquemas de firmas puede ser lo suficientemente fuerte para prevenirnos contra un posible ataque ejecutado con el algoritmo de Shor, la criptografía basada en retículos <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_basada_en_ret%C3%ADculos"><strong>(Lattice)</strong></a>, es una forma segura de protegerse frente a muchos algoritmos.</p>
<p>Pensemos en un <a href="https://es.wikipedia.org/wiki/Red_(grupo)">retículo</a>, como una estructura matemática que se forma mediante una red de puntos en un espacio n-dimensional. Es similar a una cuadrícula o una rejilla en dos dimensiones, pero se extiende a cualquier número de dimensiones. Cada punto en el retículo está ubicado en una posición determinada y está conectado a los puntos vecinos por líneas rectas de igual longitud.</p>
<p>En el contexto de la criptografía basada en retículos, se utilizan retículos en <a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_n%C3%BAmeros">teoría de números</a> para construir sistemas criptográficos. Estos retículos se definen mediante un conjunto de vectores base, que son combinaciones lineales de vectores de coordenadas con coeficientes enteros. Los retículos tienen propiedades matemáticas interesantes, como la propiedad de ser densos y uniformes en el espacio.</p>
<p>Los problemas computacionales basados en retículos, como el problema de la aproximación más cercana en retículos o el problema del vector corto más cercano, se utilizan en criptografía para establecer la seguridad de los esquemas basados en retículos. Estos problemas son difíciles de resolver y se cree que no existen algoritmos eficientes para resolverlos en el caso general, lo que brinda seguridad a los sistemas criptográficos basados en retículos.</p>
<p>La criptografía basada en retículos es el término genérico para las construcciones de primitivas criptográficas que involucran retículos, ya sea en la construcción misma o en la prueba de seguridad.</p>
<p><strong>Las construcciones basadas en retículos son actualmente candidatas importantes para la criptografía post-cuántica.</strong> A diferencia de los esquemas de clave pública más ampliamente utilizados y conocidos, como RSA, Diffie-Hellman o los criptosistemas de curva elíptica, que teóricamente podrían ser derrotados utilizando el algoritmo de Shor en un computador cuántico, algunas construcciones basadas en retículos parecen ser resistentes a los ataques tanto de computadoras clásicas como cuánticas. Además, muchas construcciones basadas en retículos se consideran seguras bajo la suposición de que ciertos problemas computacionales bien estudiados en retículos no pueden ser resueltos.</p>
<p>Aquí hay una breve explicación de las diferencias entre los esquemas de criptografía basados en retículos en términos de encriptación, funciones hash y intercambio de claves:</p>
<ol>
<li><strong>Encriptación basada en retículos:</strong> los esquemas de encriptación basados en retículos aprovechan las propiedades matemáticas de los retículos para proporcionar seguridad en la comunicación.</li>
<li><strong>Funciones hash basadas en retículos:</strong> las funciones hash basadas en retículos utilizan retículos y operaciones matemáticas relacionadas para calcular los hashes y se utilizan en diversas aplicaciones criptográficas, como la integridad de datos y la firma digital.</li>
<li><strong>Intercambio de claves basado en retículos:</strong> el intercambio de claves basado en retículos como el <a href="https://newhopecrypto.org/">(Intercambio NewHope Protocol)</a> implica el establecimiento de una clave compartida entre dos o más partes que desean comunicarse de manera segura. Los protocolos de intercambio de claves basados en retículos utilizan los retículos y los problemas computacionales relacionados con ellos para garantizar que las partes puedan acordar una clave sin que un tercero pueda determinarla. Estos esquemas se basan en la dificultad de resolver ciertos problemas matemáticos relacionados con los retículos para asegurar la confidencialidad de la clave compartida.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kyber-crystal"><a class="header" href="#kyber-crystal">Kyber Crystal</a></h1>
<p>En el último estudio post-quantum veremos <a href="https://pq-crystals.org/kyber/resources.shtml"><strong>Kyber</strong></a>, antes de entrar dentro del ecosistema de Starkware y aprender cómo se generan los contratos de cuentas, así como las características criptográficas y matemáticas detrás de las STARKs.</p>
<p>Kyber es un método de encapsulación de clave <a href="https://en.wikipedia.org/wiki/Key_encapsulation">(KEM)</a> diseñado para resistir ataques criptoanalíticos realizados por futuras computadoras cuánticas poderosas. Se utiliza para establecer un secreto compartido entre dos partes que se comunican, sin que un atacante <a href="https://en.wikipedia.org/wiki/Ciphertext_indistinguishability">(IND-CCA2)</a> en el sistema de transmisión pueda descifrarlo. Este criptosistema asimétrico utiliza una variante del problema de redes de aprendizaje con errores <a href="https://en.wikipedia.org/wiki/Learning_with_errors">(learning with errors, LWE)</a> como su <a href="https://en.wikipedia.org/wiki/Trapdoor_function">función básica con trampa</a>. Ganó la competencia del NIST para el primer estándar de criptografía PQ.</p>
<p>La generación de claves en Kyber no se basa en la factorización de enteros o en problemas relacionados con las curvas elípticas, sino que utiliza el problema de aprendizaje con errores en retículos como base para la seguridad del algoritmo.</p>
<p>El sistema se basa en el aprendizaje con errores en módulos (M-LWE) del campo del aprendizaje automático, en conjunto con anillos ciclotómicos. Recientemente, también se ha logrado una reducción formal matemática estrecha de la problemática del anillo LWE al MLWE. <strong>En comparación con otros métodos de criptografía post-cuántica, tiene las ventajas típicas de los métodos basados en retículos, como el tiempo de ejecución, el tamaño de los textos cifrados y el material clave.</strong></p>
<p>En cuanto a los parámetros, Kyber proporciona diferentes conjuntos para alcanzar diferentes niveles de seguridad. Por ejemplo, <code>Kyber-512</code> tiene una seguridad aproximada equivalente a <code>AES-128</code>, <code>Kyber-768</code> tiene una seguridad aproximada equivalente a <code>AES-192</code> y <code>Kyber-1024</code> tiene una seguridad aproximada equivalente a <code>AES-256</code>.</p>
<p>En resumen, Kyber utiliza un enfoque matemático diferente a ECDSA en la generación de claves. Se basa en el problema de aprendizaje con errores en retículos y en la selección adecuada de parámetros de seguridad. La seguridad de Kyber radica en la dificultad de resolver problemas criptográficos específicos asociados a ese enfoque matemático.</p>
<p>Con esto hemos concluido las bases criptográficas que nos han brindado los detalles de cómo se generan los distintos tipos de criptografía simétrica o asimétrica, así como las funciones hash y su importancia en la seguridad. Nos adentramos en cómo se integraban en los Merkle Tree o Patricia Trie, para luego explorar el ámbito de la computación cuántica y ver cómo se podían resolver algunos de los problemas planteados por ciertas criptografías. También destacamos la importancia de las firmas y las verificaciones de firmas en los avances de la tecnología de la computación cuántica.</p>
<p>La computación cuántica se mostró resistente a las bases simétricas de una llave maestra o a las funciones hash en sí. Además, presenciamos avances en la prevención de ataques cuánticos y en algoritmos cuánticos como Lattice o encapsulamientos por Kyber. Con estos avances en mente, es hora de pasar a ver las EOA (Externally Owned Accounts) y los firmantes en Ethereum, para luego diferenciarlos de la Account Abstraction nativa en Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eoa-y-aa---firmantes"><a class="header" href="#eoa-y-aa---firmantes">EOA y AA - Firmantes</a></h1>
<p>Las cuentas de EOA <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>(Externally Owned Accounts)</strong></a> en Ethereum, al igual que muchas otras criptomonedas, utilizan el algoritmo ECDSA que aprendimos antes para generar claves y firmar transacciones digitalmente. Esto les permite participar de manera segura en la red y realizar operaciones. Las EOA son cuentas que pertenecen a usuarios externos a la cadena de bloques.</p>
<p>En Ethereum, el estado de una cuenta solo puede ser modificado a través de transacciones, las cuales deben ser iniciadas por una EOA. sin embargo, no cualquier persona puede activar una transacción desde cualquier EOA, aquí es donde entra en juego el concepto de firmante.</p>
<p>Cada cuenta en Ethereum está asociada con un objeto criptográfico llamado keypair, como aprendimos antes.</p>
<p>La clave privada, se utiliza para firmar mensajes digitales, mientras que la clave pública permite que cualquiera pueda verificar que una firma en particular fue generada por la clave privada correspondiente.</p>
<p>La asociación entre una cuenta y un firmante se realiza mediante la dirección de la cuenta. La dirección de un EOA se deriva de la clave pública del firmante, específicamente, <strong>la dirección se obtiene tomando los últimos 20 bytes del hash Keccak-256 de la clave pública.</strong></p>
<p>El propietario de una cuenta puede autorizar una transacción desde su cuenta firmando los parámetros de la transacción con la clave privada correspondiente.</p>
<p>La <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>curva elíptica secp256k1</strong></a>  es una de las curvas elípticas más utilizadas en criptografía, especialmente en el contexto de criptomonedas como Bitcoin o Ethereum. Esto ha permitido establecer esquemas de firmas digitales que garantizan la integridad de las transacciones al asegurar la autenticidad de las claves.</p>
<p>La abstracción de firma y clave privada es una propiedad presente en algunos sistemas criptográficos, como ciertos esquemas de firmas digitales basados en identidad. Sin embargo, en el caso del algoritmo ECDSA utilizado en Ethereum y muchas otras blockchain, la firma está inherentemente vinculada a la clave privada de la cuenta y no es posible separarlas o abstraerlas, como podría ser el caso en otros esquemas diseñados con estos principios.</p>
<p>Ahora que ya hemos adquirido los conceptos básicos y hemos prestado atención para adquirir la formación adecuada y avanzada, podemos sumergirnos en el apasionante ecosistema de StarkWare, Starknet, StarkEx y STARKs. Nuestra mente está mejor preparada para embarcarnos en el viaje que nos espera en el resto del documento y en las futuras series.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starknet-aa"><a class="header" href="#starknet-aa">Starknet AA</a></h2>
<p>Esperamos que haya disfrutado de la primera parte, donde se presentaron conceptos generales de criptografía. Ahora nos adentraremos en un tema aún más interesante, <a href="https://www.starknet.io/en"><strong>Starknet</strong></a> y cómo mejora el ecosistema, exploraremos cómo los contratos de cuentas (CA) y el esquema de firmas abstraídas de Starknet ofrecen beneficios significativos frente al <a href="https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a">ERC-4337</a>.</p>
<p><em>Si deseas aprender más sobre el concepto y las variantes del ERC-4337, te recomendamos leer esta serie de artículos en el blog de <a href="https://www.argent.xyz/argent-x/">Argent</a>. La serie está compuesta por la <a href="https://www.argent.xyz/blog/wtf-is-account-abstraction/">Parte 1</a>, <a href="https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/">Parte 2</a> y <a href="https://www.argent.xyz/blog/part-3-wtf-is-account-abstraction/">Parte 3</a>. Argent y <a href="https://braavos.app/">Braavos</a> son Smart wallets que aprovechan el poder del AA nativo en Starknet. También te recomendamos leer los artículos de Braavos de <a href="https://braavos.app/account-abstraction-ethereum-comprehensive-guide/">Guide 101 AA</a> y <a href="https://braavos.app/account-abstraction-security-pyramid/">Security Pyramid AA</a>, los cuales presentan optimizaciones adicionales y capas de seguridad que exploraremos más adelante. Estos recursos te proporcionarán una mejor comprensión del concepto de <strong>AA</strong> y del <strong>ERC-4337</strong>.</em></p>
<p><strong>¡Así que sin más preámbulos, bienvenidos a Starknet!</strong></p>
<p>En el ecosistema de Starknet, se encuentran diversas metodologías para generar claves y firmas. A diferencia de las cuentas EOA, en Starknet se emplea <strong>Account Abstraction</strong> <a href="https://book.starknet.io/chapter_5/index.html"><strong>(AA)</strong></a> para la implementación de <strong>Contract Accounts</strong> <a href="https://book.starknet.io/chapter_5/index.html#ethereums_current_account_system_a_closer_look">(CA)</a>. Estos contratos son responsables de establecer la lógica en nuestras cuentas dentro de Starknet, incluyendo la validación del esquema de firma abstraído.</p>
<p>En lugar de utilizar ECDSA, Starknet utiliza una variación llamada [<strong>STARK Curve</strong>], un tipo de curva elíptica más amigable y optimizada que es nativa en el ecosistema, esta variante nos ofrece mejoras y características específicas para las necesidades de Starknet.</p>
<p>Lo grandioso de tener esta abstracción nativa es que permite añadir diferentes lógicas en tus esquemas o capas adicionales. Normalmente, se utiliza un sistema asimétrico usando la curva elíptica <code>secp256k1</code>, basado en la pseudoaleatoriedad y diversas operaciones matemáticas utilizando dicha curva, para generar claves privadas y públicas. Sin embargo, también se pueden añadir curvas adicionales de forma nativa al crear un CA, como lo ha hecho Braavos con la <a href="https://github.com/myBraavos/efficient-secp256r1">secp256r1</a>. Esta curva cuenta con un sistema de firmas integrado, mejor optimizado y preparado para dispositivos modernos, donde el signer puede almacenar los datos habilitados por biometricidad en dispositivos aislados y seguros, como el módulo &quot;Enclave&quot; de Apple.</p>
<p>La AA desempeña un papel crucial al abstraer el esquema de firmas o verificación de firmas de la ejecución. Como vimos anteriormente, podemos generar una clave privada y mediante ECDSA generar una clave pública. En este caso el poseedor de esta clave privada y del esquema de firma asociado tiene el poder de realizar transacciones en Starknet, los <a href="https://book.starknet.io/chapter_8/transactions.html">dos tipos de transacciones</a> son <code>DEPLOY</code> o <code>INVOKE</code>.</p>
<p><img src="./assets/Invoke.png" alt="graph" /></p>
<div align="center">
<em>Contrato de Cuenta de usuario</em>
</div>
<p>Con AA podemos modificar estas firmas o curvas. Por ejemplo, la curva <code>Secp256r1</code>, vimos que ofrece una seguridad adicional en Braavos al configurar una firma biométrica en el módulo de seguridad del enclave. De esta manera, esta firma biométrica solo puede ser añadida gracias a AA.</p>
<p>Todo esto es posible gracias al lenguaje de programación utilizado en la implementación, el poderoso <a href="https://starkware.co/cairo/"><strong>Cairo</strong></a>, así que analicemos cómo Cairo incorpora esta abstracción en su programación.</p>
<p>En primer lugar, se necesita validar la firma y comprobar que coincide con la generada mediante ECDSA antes de proceder a la ejecución. Estas dos funciones principales son <code>validate</code> y <code>execute</code>. Además, <code>execute</code> también puede realizar múltiples llamadas utilizando <code>execute_calls</code>.</p>
<p><img src="./assets/invoke_execute.gif" alt="graph" /></p>
<div align="center">
<em>Información de la Lógica separada de las funciones validate, execute</em>
</div>
<p>Ahora analicemos cómo Cairo incorpora esta abstracción en su programación.</p>
<p>Veamos cómo funciona un ciclo de transacción con AA nativa y cómo se representa gráficamente este ciclo completo de firmas para detectar si es correcto y realizar la operación.</p>
<p>También pensemos en cómo se podrían combinar de manera eficiente firmas como ha realizado Braavos con la EC <code>secp256r1</code> o incluso realizar la verificación de firmas, como vimos con Lattice para prevenir ataques cuánticos.</p>
<p><img src="./assets/transaccion.gif" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validación de una trnasacción</em>
</div>
<p>Los conocimientos previos adquiridos nos han enseñado muchas cosas, una de ellas es cómo el algoritmo de Shor puede teóricamente romper ECDSA, pero no podrá romper una prueba STARK. </p>
<p>En la sección de generación de STARKs, aprenderemos como gracias a sus bases de criptografía simétrica y otras variables, si alguien nos roba, hackea o perdemos la cuenta, el esquema <strong>PQS</strong> para la prueba no será de mucha utilidad, ya que no se ha alterado la integridad del estado de los datos, sino que por oun teórico ataque criptoanalítico se habrá obtenido tu PK, lo que permitiría mover los fondos de forma justa.</p>
<p><strong>Pero, ¿qué sucedería si tuviéramos un esquema de verificación de firmas seguro frente a un ataque cuántico?</strong></p>
<p>Aquí es donde entran en juego pequeños cambios, específicamente en la parte de validación y no de ejecución, con las mejoras en Starknet y con la ayuda de AA nativo, está implementando para prepararse para el futuro. Una posibilidad sería el uso de Lattice o Kyber, aunque el futuro no está escrito, así que ha llegado el momento de ver cómo se genera la parte de la EC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-en-cairo---stark-curve"><a class="header" href="#ec-en-cairo---stark-curve">EC en Cairo - STARK Curve</a></h1>
<p>Como hemos visto en el contexto de los sistemas criptográficos, la elección de la curva elíptica adecuada es de suma importancia. En este caso, se utiliza una variante de EC la cual ha sido especialmente diseñada y optimizada para su aplicación en el entorno de Starknet.</p>
<p>La STARK Curve <a href="https://github.com/starkware-libs/cairo-lang/blob/361fe32d5930db340ea78fe05aedfe706f6c9405/src/starkware/cairo/common/ec.cairo"><strong>(EC.cairo)</strong></a> se define mediante la ecuación:</p>
<p><img src="./assets/stark_curve.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Los valores específicos de <code>α</code>, <code>β</code> y <code>p</code> utilizados en esta curva han sido cuidadosamente seleccionados para proporcionar propiedades criptográficas sólidas y un rendimiento eficiente en el contexto de los contratos de cuenta nativos en Starknet.</p>
<p>En particular, los valores de <code>α</code>, <code>β</code> (notese que es <code>π</code> “PI” sin decimales usando 67 digitos) y <code>p</code> son los siguientes:</p>
<p><img src="./assets/stark_curve1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Estos valores aseguran que la curva elíptica Stark-friendly cumple con los requisitos de seguridad necesarios para su aplicación en sistemas criptográficos.</p>
<p>Además se utiliza un punto generador <a href="https://docs.starkware.co/starkex/crypto/stark-curve.html">(G)</a> específico asociado a esta curva. El punto generador <code>G</code> se define como:</p>
<p><img src="./assets/stark_curve_g.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Este punto generador desempeña un papel fundamental en el esquema de firmas digitales ECDSA, permitiendo la generación de claves públicas, como aprendimos al momento de hablar del Generador de Claves.</p>
<p>La elección de la curva elíptica Stark-friendly y el punto generador <code>G</code> asociado a ella proporcionan una base sólida y optimizada para la implementación de esquemas criptográficos en el entorno de Starknet. Estos elementos garantizan la seguridad y eficiencia necesarias para la creación de contratos de cuenta nativos y la verificación de firmas digitales en el sistema.</p>
<p>Si desea probar y adentrarse en el despliegue de cuentas en Starknet, o si está interesado en aprender cómo se generan y calculan off-chain, y luego financiar esas cuentas para que los contratos de cuenta se autodesplieguen, le animamos a seguir los ejercicios oficiales de <a href="https://github.com/starknet-edu/starknet-accounts/blob/answers/ES%20README.md"><strong>Starknet-Edu Account</strong></a> o las <a href="https://github.com/Nadai2010/Nadai-StarknetEs-Guia-Cairo1#configuraci%C3%B3n-de-una-cuenta"><strong>Guías Completas Cairo 1</strong></a> proporcionadas por <a href="https://twitter.com/StarkNetEs">Starknet-Es</a> para realizar pruebas reales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-braavos---secp256r1"><a class="header" href="#my-braavos---secp256r1">My Braavos - Secp256r1</a></h1>
<p>Empecemos con un dato que no habíamos comentando antes, la <code>k</code> en <code>sepc256k1</code> significa <a href="https://es.wikipedia.org/wiki/Neal_Koblitz"><strong>Koblitz</strong></a> y el <code>r</code> en <code>sepc256r1</code> significa random.</p>
<p>Braavos ha incorporado la firma y validación de transacciones utilizando <code>secp256r1</code>, lo que brinda una excelente experiencia al usuario final al permitir transacciones con firma biométrica en el dispositivo del usuario. Esto añade un nivel adicional de seguridad. Braavos ha presentado en su blog una <a href="https://braavos.app/account-abstraction-security-pyramid/">Pirámide de Seguridad AA</a>.</p>
<p><img src="./assets/Mybraavos.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Podemos ver en la cúspide de la pirámide al Multi-Signer (3FA). El Multi-Signer combina la protección de la frase de recuperación (seed phrase) en la extensión del navegador y el Hardware Signer o Protected Signer utilizando el dispositivo móvil.</p>
<p>Ahora se requieren dos firmas de dos claves diferentes para ejecutar la transacción en la cadena, obteniendo una autenticación de 3FA:</p>
<ul>
<li><strong>Algo que sabemos:</strong> la clave derivada de tu frase de recuperación en la extensión del navegador.</li>
<li><strong>Algo que tenemos:</strong> tu dispositivo móvil.</li>
<li><strong>Algo que somos:</strong> tu huella dactilar o identificación biométrica facial.</li>
</ul>
<p>Cabe destacar que aunque se ha agregado otro firmante, no se ha añadido otra seed phrase, esto también tiene el beneficio adicional de alejarse de las seed phrase a una mejor seguridad en los dispositivos móviles/computadoras portátiles modernas, y seguridad superior cuando el dispositivo del usuario admite un chip de seguridad dedicado, como el <a href="https://cloud.google.com/blog/products/identity-security/titan-in-depth-security-in-plaintext">elemento seguro Titan de Android</a> o <a href="https://support.apple.com/es-us/guide/security/sec59b0b31ff/web">Enclave Secure de Apple</a>, etc.</p>
<p>Este chip Secure Enclave/Titan es un subsistema dedicado y aislado, totalmente separado del procesador de aplicaciones que puede generar claves privadas y mensajes de signo. Genera las teclas utilizando un generador interno de números aleatorios verdaderos <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator"><strong>(TRNG)</strong></a> y firma mensajes a través de la curva elíptica <code>secp256r1</code> a través de su acelerador interno de claves públicas <a href="https://www.rambus.com/security/crypto-accelerator-cores/pka-ip-28/"><strong>(PKA)</strong></a>. Las claves privadas nunca abandonan el sistema seguro y son desconocidas / inaccesibles para cualquier persona, ni siquiera para el usuario o para la aplicación en sí.</p>
<p>Esto significa que incluso si el núcleo del procesador de la aplicación del dispositivo se ve comprometido, <strong>¡Nuestras claves se mantendrán seguras!</strong></p>
<p><img src="./assets/Enclave.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Vemos que esta implementación de la firma ECDSA <code>secp256r1</code> en Cairo no es nativa, lo que significa que no tiene un Builtin dedicado nativo, esto puede llevar a un alto costo de gas al validar la firma. Sin embargo, Braavos es uno de los que han adoptado esta maravillosa novedad y está trabajando en mejorar la eficiencia de este proceso.</p>
<p>Además, aprovechando la funcionalidad de Multi-Call incorporada, los usuarios pueden agrupar múltiples transacciones en una única transacción atómica. Esto no solo acelera y reduce los costos de las transacciones, sino que también permite a los usuarios aprobar la cantidad exacta que desean depositar, lo cual mejora la seguridad al eliminar la necesidad de <a href="https://hackernoon.com/erc20-infinite-approval-a-battle-between-convenience-and-security-lk60350r">aprobación infinita</a></p>
<p>En cuanto a la <strong>gestión de firmantes</strong>, cuando se añade un firmante adicional, como un Hardware Signer o Protected Signer, el firmante original basado en semillas ya no puede firmar transacciones, a menos que se solicite la eliminación del firmante adicional y se regrese al firmante basado en semillas. <strong>Esta solicitud tiene un retraso de tiempo (actualmente de 4 días)</strong> para su procesamiento.</p>
<p>Por otro lado, la función de multifirma permite configurar la cuenta en modo de multifirma (actualmente admite 2 de 2), lo que significa que ninguna transacción se ejecutará hasta que los 2 firmantes definidos en la cuenta firmen la transacción. La seed phrase puede solicitar la desactivación de la multifirma, pero esto <strong>también tiene un retraso de tiempo (actualmente 4 días)</strong> antes de que se haga efectiva.</p>
<p>Vemos la importancia de las firmas y como vimos en el contexto del PQS, entendemos la relevancia de poder modificar nuestros esquemas de verificación de firmas, como la utilización de Lattice o Kyber, por ejemplo. Ahora, centrémonos en aprender cómo creamos una Stark Key para StarkEx, el motor de escalabilidad de Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creación-de-una-stark-key-en-starkex"><a class="header" href="#creación-de-una-stark-key-en-starkex">Creación de una Stark Key en StarkEx</a></h1>
<p>Es importante comprender cómo <a href="https://mirror.xyz/dashboard/edit/KJVQJ6X6wvbf6ps1oy96zpE3TztWyhSIDZd2IHu5NuI">StarkEx</a> se comunica con otras billeteras en términos de firmas, y cómo mantiene todo el motor de transacciones y pruebas STARKs en su interior.</p>
<p>StarkEx ofrece soluciones altamente especializadas para diferentes aplicaciones que deseen construir sobre su servicio, y esto es parte de lo que StarkWare, como compañía, proporciona a grandes empresas o cualquier otra entidad que desee aprovechar su conjunto de profesionales y servicios adaptables.</p>
<p>Aplicaciones populares como Sorare, Rhino y Apex Pro, por ejemplo, aprovechan las soluciones ofrecidas por StarkWare. Estas aplicaciones específicas se construyen sobre el marco de Starknet. Si bien no profundizaremos en los detalles específicos de estas aplicaciones aquí, se recomienda visitar la <a href="https://layer2es.notion.site/39d63a8af9ca4524a7237b1f2456e745">Biblioteca de Layer 2 en Español</a> para obtener información más detallada sobre cada una de ellas y comprender mejor cómo se integran en las soluciones de escalado de capa 2 de Ethereum.</p>
<p>Para utilizar StarkEx y asociar tu cuenta de MetaMask u otra billetera a Starknet, es necesario crear una Stark Key. StarkEx admite diferentes tipos de billeteras y métodos para crear esta clave, dependiendo de cómo se utilizará posteriormente. A continuación, se detallan las opciones disponibles:</p>
<h2 id="billeteras-compatibles-con-bip32"><a class="header" href="#billeteras-compatibles-con-bip32">Billeteras compatibles con BIP32</a></h2>
<p>Si estás utilizando una billetera compatible con <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki"><strong>BIP32</strong></a>, como Ledger, se recomienda seguir el EIP-2645. Este estándar describe una ruta denominada <code>starkPath</code> y un algoritmo de derivación de clave que utiliza esta ruta para obtener la <code>starkPrivateKey</code>.</p>
<p>La <code>starkPath</code> está compuesta por cuatro parámetros pasados y dos parámetros internos, y sigue la siguiente estructura:</p>
<p><code>m/purpose'/layer'/application'/ethAddress1'/ethAddress2'/index</code></p>
<p>Los parámetros externos pasados son los siguientes:</p>
<ul>
<li><strong>Purpose:</strong> el número de EIP correspondiente (en este caso, 2645).</li>
<li><strong>Layer:</strong> se utiliza para diferenciar entre tecnologías y se calcula como <code>sha256(layer) &amp; ((1 &lt;&lt; 31) - 1))</code>. En el contexto de StarkEx, el valor es <code>579218131</code> según lo descrito en el EIP-2645.</li>
<li><strong>Application:</strong> sirve para diferenciar entre aplicaciones y se calcula como: <code>sha256(application_name) &amp; ((1 &lt;&lt; 31) - 1))</code>.</li>
<li><strong>Index:</strong> permite tener múltiples claves por dirección de Ethereum.</li>
</ul>
<p>Los parámetros internos usados son los siguientes:</p>
<ul>
<li><strong>ethAddress1:</strong> Los 31 LSB de la dirección Ethereum del usuario, es decir, <code>(ethAddress &amp; 1 &lt;&lt; 31) - 1</code></li>
<li><strong>ethAddress2:</strong> Los 31 LSB siguientes de la dirección Ethereum del usuario, es decir, <code>(ethAddress &gt;&gt; 31) &amp; 1 &lt;&lt; 31) - </code>.</li>
</ul>
<p>Además, es importante que las billeteras compatibles con BIP32 mantengan un estado persistente en relación con su propia dirección de Ethereum.</p>
<h2 id="billeteras-no-compatibles-con-bip32"><a class="header" href="#billeteras-no-compatibles-con-bip32">Billeteras NO compatibles con BIP32</a></h2>
<p>Si estás utilizando una billetera que no es compatible con BIP32, como MetaMask, se recomienda seguir el siguiente proceso:</p>
<ol>
<li>El usuario firma un mensaje utilizando su clave privada de Ethereum a través de MetaMask u otra billetera similar. Se recomienda utilizar el estándar  IP-712 para brindar transparencia al usuario durante el proceso de firma. Es importante que el mensaje incluya una advertencia, indicando al usuario que so1lo debe firmarlo si proviene de un dominio específico.</li>
<li>La firma <code>(r, s, v)</code> se utiliza como entrada para el algoritmo de derivación de clave, que generará la <code>starkPrivateKey</code>. Para realizar este cálculo, puedes utilizar la biblioteca <a href="https://www.npmjs.com/package/@starkware-industries/starkware-crypto-utils">StarkEx Crypto SDK</a>. Primero, llama a la función <code>getPrivateKeyFromEthSignature</code> para obtener la clave privada a partir de la firma, y luego utiliza la función <code>privateToStarkKey</code> para calcular la <code>StarkKey</code>.</li>
</ol>
<p>Al seguir estos pasos, podrás crear una Stark Key asociada a tu cuenta de MetaMask u otra billetera compatible. Esta clave te permitirá interactuar con StarkEx y otras aplicaciones dentro del ecosistema de Starknet, realizar transacciones seguras y aprovechar las funcionalidades ofrecidas por esta plataforma.</p>
<p><img src="./assets/Stark_Key.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-y-funciones-hash"><a class="header" href="#starknet-y-funciones-hash">Starknet y Funciones Hash</a></h1>
<p>Hemos visto la importancia de las firmas, el poder de AA y la asociación de los hash dentro del ecosistema de Starknet y StarkEx. Ahora, profundicemos en cómo se utilizan y los diferentes tipos de hash que podemos encontrar.</p>
<h2 id="dominio-y-rango"><a class="header" href="#dominio-y-rango">Dominio y rango</a></h2>
<p>Todas las salidas de las funciones de hash se mapean eventualmente a elementos en <code>𝔽ₚ</code> con <code>p = 2²⁵¹ + 17 ⋅ 2¹⁹² + 1</code> como vimos en la Stark Curve.</p>
<p>Las funciones hash son componentes clave en las especificaciones de Starknet, y se utilizan para mapear las salidas de los cálculos a elementos en el campo finito <code>𝔽ₚ</code>. A continuación, explicaremos las tres funciones hash utilizadas en Starknet de manera más clara:</p>
<p><img src="./assets/Stark_func_hash.png" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validación de una trnasacción</em>
</div>
<ol>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#starknet_keccak"><strong>sn_keccak:</strong></a> Esta función hash se basa en el algoritmo KECCAK, que es una familia de funciones hash criptográficas como vimos antes. Su dominio es el conjunto de cadenas de bits compuestas por ceros y unos <code>{0,1}*</code> y su rango es el campo finito <code>𝔽ₚ</code> La función toma una cadena de bits como entrada y produce una salida en el campo finito <code>𝔽ₚ</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash"><strong>Pedersen:</strong></a> La función hash Pedersen es una función hash computacionalmente segura que se utiliza en la construcción de criptografía de compromiso cero y otras primitivas criptográficas. Su dominio es el conjunto de pares de elementos del campo finito <code>𝔽²p</code>, donde <code>p</code> es un número primo, y su rango es el campo finito <code>𝔽p</code>. La función toma un par de elementos del campo finito <code>𝔽²p</code> como entrada y produce una salida en el campo finito <code>𝔽p</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#poseidon_hash"><strong>Poseidon:</strong></a> La función hash Poseidon es una función hash criptográfica. Su dominio es un conjunto de elementos del campo finito <code>𝔽p</code>, que incluye el cero y los elementos inversos multiplicativos, y su rango también es el campo finito <code>𝔽p</code>. La función toma un conjunto de elementos del campo finito <code>𝔽p</code> como entrada y produce una salida en el campo finito <code>𝔽p</code>.</li>
</ol>
<p>Las funciones de hash mencionadas son añadidas como <a href="https://mirror.xyz/0x7D1c14939AcEE5ca141c8beDF3474AFBf3884041/RTgQnMxeVGRCczih1pGXKy2KGFcU_xmf2NMx52wDgH0"><strong>Builtin</strong></a> (AIR integradas específicas de aplicaciones), que se utilizan como herramientas adicionales en el protocolo para garantizar la seguridad y la integridad de las transacciones y los datos.</p>
<p>Estas funciones hash desempeñan un papel fundamental en las operaciones de Starknet al garantizar la integridad y seguridad de los cálculos realizados en el sistema.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak-starknet"><a class="header" href="#keccak-starknet">Keccak Starknet</a></h1>
<p>Keccak en Starknet es una implementación específica de la función hash <code>Keccak256</code> adaptada para su uso en la red Starknet. Proporciona un método confiable y eficiente para calcular hashes dentro del entorno de Starknet.</p>
<p>Generalmente denotado por <code>sn_keccak</code>, se define como los primeros <strong>250 bits del hash Keccak256</strong> (esto es simplemente <code>Keccak256</code> ampliado para ajustarse a un field element “elemento de campo”).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen-hash-starknet"><a class="header" href="#pedersen-hash-starknet">Pedersen Hash Starknet</a></h1>
<p>El <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash">Pedersen hash</a> es una función hash criptográfica utilizada en criptografía propuesta por Torben Pedersen en 1991.</p>
<p>Uno de los aspectos interesantes del <a href="https://en.wikipedia.org/wiki/Commitment_scheme">esquema de compromiso de Pedersen</a> es su propiedad homomórfica, que permite realizar la adición entre dos compromisos. En otras palabras, dados dos mensajes <code>m₁</code> y <code>m₂</code>, y sus respectivas aleatoriedades <code>r₁</code> y <code>r₂</code>, el Pedersen hash permite combinarlos de manera segura.</p>
<p>La función Pedersen Hash utilizada en Starknet es resistente a colisiones para entradas de longitud fija, siempre y cuando la función de codificación subyacente sea inyectiva. Una función inyectiva asigna elementos distintos de su dominio a elementos distintos de su codominio, esto hace que el Pedersen hash sea resistente a ciertos tipos de ataques, como colisiones y preimágenes.</p>
<p>Sin embargo, es importante destacar que la implementación y el contexto en el que se utilice esta función pueden influir en su resistencia. Para obtener más información se recomienda realizar una lectura sobre <a href="https://research.nccgroup.com/2023/03/22/breaking-pedersen-hashes-in-practice/">Pedersen hashes in Practice</a>.</p>
<p>En Starknet, se utiliza la EC amigable STARK curve sobre el campo finito <code>𝔽ₚ</code> para calcular el Pedersen hash de manera eficiente y segura.</p>
<p><img src="./assets/Pedersen_Starknet.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<ul>
<li>α = 1</li>
<li>β = 31415926535897932384626433832795028841971693993751058209749 44592307816406665</li>
</ul>
<p>Los parámetros <code>α</code> y <code>β</code> de la curva son importantes en términos de seguridad y eficiencia en los algoritmos utilizados en la construcción del Pedersen hash y los protocolos de ZKP o basados en STARK.</p>
<p>Dada una entrada <code>(a, b) ∈ 𝔽²p</code>, se divide en <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, donde la parte <code>low</code> consiste en los <strong>248 bits menos significativos del elemento</strong> y la parte <code>high</code> consiste en los <strong>4 bits más significativos del elemento.</strong> El cálculo del Pedersen hash se define de la siguiente manera:</p>
<p><img src="./assets/Pedersen_Starknet1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En esta fórmula, <code>[P]x</code> denota la coordenada <code>x</code> del punto <code>P</code>. Para calcular el hash, se realiza una combinación lineal de los puntos <code>P0, P1, P2 y P3</code>, ponderados por los valores <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, respectivamente. Luego, se suma el punto <code>shift_point</code> y se extrae la coordenada <code>x</code> del resultado.</p>
<p>Los valores de las constantes <code>shift_point</code>, <code>P0</code>, <code>P1</code>, <code>P2</code> y <code>P3</code> se encuentran en el archivo <a href="https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/crypto/signature/fast_pedersen_hash.py">fast_pedersen_hash.py</a>. Este archivo contiene la implementación específica del algoritmo necesario para calcular el Pedersen hash.</p>
<p>No se trata de puntos en la EC en sí misma, sino de valores específicos que se han elegido para el cálculo del hash y tampoco están relacionadas con la EC ni con el punto generador <code>G</code>, revise minuciosamente la información oficial en caso de querer hacer pruebas sobre Stark Curve o Hash en Starknet. Estas constantes se eligen de forma independiente para el cálculo del hash y se utilizan en combinación con los valores de entrada para obtener el hash resultante.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon-hash-starknet"><a class="header" href="#poseidon-hash-starknet">Poseidon hash Starknet</a></h1>
<p>La función <strong>Poseidon hash</strong> es un <a href="https://www.poseidon-hash.info/">ZK-friendly Hashing</a>, pertenece a una familia de funciones hash diseñadas para ser muy eficientes en circuitos algebraicos. Como tal, pueden ser muy útiles en sistemas ZK proof como STARKs y otros.</p>
<p>Poseidon es una construcción de esponja basada en la permutación Hades, la estrategia de diseño Hades se basa en dividir el proceso en diferentes rondas para garantizar la seguridad y eficiencia del algoritmo:</p>
<ul>
<li>En las primeras rondas, denominadas <code>Rf</code>, se aplican las <code>S-boxes</code> al estado completo. Las <code>S-boxes</code> son funciones no lineales que mezclan y transforman los datos. En esta etapa inicial, se busca lograr una alta dispersión de los bits en el estado.</li>
<li>Después de estas rondas iniciales, se llevan a cabo las rondas intermedias, denominadas <code>RP</code>. En cada ronda intermedia, se aplica únicamente una <code>S-box</code>, mientras que el resto del estado permanece sin cambios, es decir, se utiliza una función identidad en lugar de las <code>S-boxes</code> faltantes. Esta simplificación reduce el costo computacional y la complejidad del algoritmo.</li>
<li>Finalmente, en las últimas rondas, nuevamente se utilizan las <code>S-boxes</code> para el estado completo. Estas rondas finales, al igual que las rondas iniciales, permiten obtener una mezcla y transformación adicional de los datos.</li>
</ul>
<p>Para una revisión más profunda sobre su integridad en sistema de Proof pueden revisar <a href="https://eprint.iacr.org/2019/458.pdf">POSEIDON: A New Hash Function for Zero-Knowledge Proof Systems (Updated Version)</a>.</p>
<p>La versión de <strong>Poseidon</strong> utilizada en Starknet se basa en una permutación de estado de tres elementos.</p>
<p>El campo <strong>𝔽</strong>, sobre el que se definen las declaraciones aritméticas que utilizan Poseidon. A menudo es determinado por el sistema de prueba ZK. Lo más probable es que sea un subgrupo de primer orden del grupo de puntos de una curva elíptica. Poseidon mapea secuencias de elementos <strong>𝔽</strong> a una secuencia de longitud fija de elementos <strong>𝔽</strong>.</p>
<p>A continuación, se define el <strong>Poseidon hash</strong> de hasta 2 elementos, y también se menciona una versión que admite un número arbitrario de entradas.</p>
<p><img src="./assets/Poseidon_Starknet.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-de-array-matrices"><a class="header" href="#hashing-de-array-matrices">Hashing de Array (matrices)</a></h1>
<p>Estas definiciones explican cómo se realizan los hashing de matrices utilizando las funciones Pedersen y Poseidon en el contexto de Starknet. Estas operaciones son fundamentales para asegurar la integridad y la seguridad de los cálculos realizados en el sistema.</p>
<p>El hashing de un array implica aplicar la función de hash correspondiente a cada elemento del array, de manera secuencial o iterativa. Esto permite resumir y representar de manera compacta la información contenida en el array, independientemente de su longitud o contenido específico.</p>
<p>El hashing de un array es útil en muchas aplicaciones, como la verificación de integridad de datos, la indexación eficiente de información y la identificación única de elementos.</p>
<h2 id="pedersen"><a class="header" href="#pedersen">Pedersen</a></h2>
<p>La función hash Pedersen, denotada como <code>h</code>, se utiliza para calcular el hash de un array de elementos de campo. Consideremos un arreglo <code>a₁</code>, <code>a₂</code>, ..., <code>aₙ</code> que contiene <code>n</code> elementos. La definición de <code>h(a₁ a₂, ..., aₙ)</code> es la siguiente:</p>
<ol>
<li>Comenzamos con un valor inicial de 0.</li>
<li>Aplicamos la función de hash h al primer elemento a₁ junto con el valor inicial. El resultado se convierte en el nuevo valor inicial.</li>
<li>Continuamos aplicando la función de hash h al siguiente elemento a₂ junto con el valor anteriormente obtenido. Nuevamente, el resultado se convierte en el nuevo valor inicial.</li>
<li>Repetimos este proceso hasta llegar al último elemento aₙ, aplicando la función de hash en cada paso.</li>
<li>Finalmente, aplicamos la función de hash h al último elemento an junto con el valor obtenido en el paso anterior.</li>
</ol>
<p>De esta manera, obtenemos el resultado final que representa el hash del array completo.</p>
<p><img src="./assets/Hash_Array.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Esta construcción en capas nos permite combinar de manera secuencial los elementos del array a medida que calculamos el hash. Cada iteración agrega un nivel adicional de seguridad y complejidad al resultado final.</p>
<h2 id="poseidon"><a class="header" href="#poseidon">Poseidon</a></h2>
<p>La función de hash Poseidon utiliza la permutación Hades, representada por hades: <code>𝔽³ₚ→𝔽ₚ</code>, con los parámetros de Starknet. Dado un array <code>a₁</code>, <code>a₂</code>, ..., <code>aₙ</code> que contiene <code>n</code> field elements, definimos <code>poseidon(a₁, a₂, ..., aₙ)</code> como la primera coordenada de <code>H(a₁, a₂, ..., aₙ; 0, 0, 0)</code>,</p>
<ul>
<li><code>H(a₁, a₂, ..., aₙ; s₁, s₂, s₃)</code> se define de la siguiente manera:</li>
</ul>
<p><img src="./assets/Hash_Poseidon.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<ul>
<li><strong>Si n ≥ 2:</strong> entonces <code>H(a₁,a₂,...,aₙ;s₁,s₂,s₃) = H(a₃, a₄, ..., aₙ;hades(s₁ + a₁, s₂ + a₂, s₃))</code>.</li>
<li><strong>Si n = 1:</strong> entonces <code>H(a₁; s₁, s₂, s₃) = hades(s₁ + a₁, s₂ + 1, s₃)</code>.</li>
<li><strong>Si n = 0:</strong> entonces <code>H(); s₁, s₂, s₃) = hades(s₁ + 1, s₂, s₃)</code>.</li>
</ul>
<p>En resumen, la <code>función poseidon(a₁,a₂,...,aₙ)</code> toma el array de field elements y aplica la permutación Hades en capas. Cada iteración de la permutación combina los elementos del array en función de los valores de  <code>s₁</code>, <code>s₂</code> y <code>s₃</code>, generando así una salida única. La primera coordenada de la salida final se considera el resultado de la función de hash Poseidon.</p>
<p>Esta construcción en capas y la utilización de la permutación Hades permiten obtener un hash seguro y resistente a ciertos ataques criptográficos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="s-t-arks"><a class="header" href="#s-t-arks">S-T-ARKs</a></h1>
<p>Ahora, adentrémonos en una de las partes más fascinantes del ecosistema, los <strong>STARKs</strong> <a href="https://starkware.co/stark/">(Scalable Transparent Argument of Knowledge)</a> se basan en los principios de la criptografía simétrica combinados con matemáticas modernas, la existencia de funciones hash criptográficas seguras y resistentes a las colisiones. Muchas de estas primitivas existen hoy en día como instrucciones de hardware, y la criptografía magra conduce a dos beneficios más:</p>
<ol>
<li>
<p><strong>Seguridad poscuántica:</strong> los <strong>STARK</strong> son plausiblemente seguros frente a ordenadores cuánticos eficientes.</p>
</li>
<li>
<p><strong>Eficiencia concreta:</strong> el prover <strong>STARK</strong> es al menos <strong>10 veces más rápido</strong> que el prover SNARK y el prover <a href="https://eprint.iacr.org/2017/1066.pdf">Bulletproofs</a>.</p>
<p>El verificador <strong>STARK</strong> es al menos <strong>2 veces más rápido</strong> que el verificador <strong>SNARK</strong> y más de <strong>10 veces más rápido</strong> que el verificador <strong>Bulletproof</strong>.</p>
<p>A medida que StarkWare continúe optimizando <strong>STARKs</strong> estos ratios probablemente mejorarán. Sin embargo, la longitud de una prueba <strong>STARK es ~100x mayor</strong> que la correspondiente <strong>SNARK</strong> y <strong>~20x mayor que BulletProofs</strong>.</p>
</li>
</ol>
<p>Puede encontrar una imagen animada en una comparativa con los datos expuestos sobre el Proving Time y Verification Time, Tamaño de la Proof, Configuración inicial y PQS entre STARKs y SNARKs, veremos como cada una cumple con propiedades que puede ser recomendada para darle mejor uso.</p>
<p><img src="./assets//Stark_Prover.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Ahora que tenemos conceptos más profundos sobre algunos aspectos de la criptografía, funciones hash y las operaciones detrás de cada una, veamos la importancia de la Integridad Computacional (CI), una propiedad fundamental para el día a día. Esta propiedad se refiere a la confianza en que la salida de un cálculo es correcta, permitiéndonos confiar en el saldo de una cuenta o en el monto de una factura en una tienda.</p>
<blockquote>
<p><strong>Pero, ¿cómo podemos garantizar esta integridad en un entorno digital donde no siempre podemos confiar en todas las partes involucradas?</strong></p>
</blockquote>
<p>Aquí es donde entra en juego la tecnología STARK, que se basa en estas Validity Proofy para garantizar que la computación se realice correctamente, <strong>incluso si nadie está observando <code>“INTEGRO”</code></strong>. STARKs utiliza matemáticas para lograr este objetivo y está diseñado para monitorear y garantizar la integridad de un gran cálculo realizado por un grupo de supercomputadoras poco confiables.</p>
<p>Las Validity Proofs son una herramienta crucial para garantizar la integridad y validez de los cambios realizados fuera de la cadena principal. Los sistemas de ZKP, en los que el prover posee información secreta que no es conocida por el verifier, son clave para las Validity Proofs. En el caso de Starknet, se trata de un Validity Rollup que utiliza STARKs.</p>
<p>Es importante tener en cuenta que ZK en Starknet, es una propiedad adicional que se utiliza para afirmar al probador que no tiene que revelar ninguna información incluida en el cálculo. Sin embargo, en el caso de Starknet como una capa 2 pública, los datos de transacción son públicos, lo que significa que no se ofrece privacidad como tal en transacciones, ocultar saldos u otras operaciones opacas, aunque los zk-STRAKs están listas para eso.</p>
<p>En Starknet, el enfoque principal es el Validity Rollup, que se utiliza para probar la validez del cálculo computacional, a diferencia de otros protocolos que utilizan mal nombrado ZK Rollup. La propiedad ZK se utiliza en Starknet para escalar el rendimiento, no para garantizar privacidad, por lo tanto, los STARKs en Starknet son Validity Proofs en lugar de ZK Proofs.</p>
<p>Los STARKs utilizan funciones de criptografía simétrica y hash criptográficos como componentes fundamentales en su construcción, las vulnerabilidades cuánticas conocidas en criptografía, como el algoritmo de Shor que puede factorizar números enteros grandes y romper sistemas de criptografía asimétrica basados en factorización, no afectan a las STARKs.</p>
<p><img src="./assets//Stark_1.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En la imagen superior, se puede observar que las pruebas pueden basarse en principios de criptografía simétrica o asimétrica, como aprendimos al principio del documento. Además, se pueden apreciar las diferentes propiedades de cada una en cuanto a escalabilidad, transparencia, seguridad en el futuro post-cuántico o tamaño de la prueba.</p>
<p>Como conclusión final antes de pasar a sus propiedades podemos ver para pruebas cortas como se recomienda utilizar <strong>Groth16</strong> o <strong>SNARKs</strong>, mientras que para todo lo demás se sugiere <strong>STARK</strong>. Es importante destacar que este campo se encuentra en constante desarrollo y cada uno sigue optimizando sus propias soluciones. Tanto las <strong>STARKs</strong> como Starknet también experimentarán optimizaciones para mejorar <strong>STARK</strong> y/o admitir diferentes tipos de pruebas. Un ejemplo de esto es como <a href="https://github.com/keep-starknet-strange">Keep-Starknet-Strange</a> el equipo detrás de <a href="https://github.com/keep-starknet-strange/garaga"><strong>Garaga</strong></a>, que está trabajando en diversas librerías criptográficas como <a href="https://eprint.iacr.org/2019/953.pdf">Plonk</a>, <a href="https://eprint.iacr.org/2016/260.pdf">Groth16</a>, <strong>SNARK</strong>, entre otras.</p>
<p>Si desea obtener más información sobre como los STARKs están en diversas arquitectura y sus diversos casos de uso para asentar las bases dela criptografía moderna, recomendamos leer el articulo que sacamos para L2 Español <a href="https://mirror.xyz/layer2es.eth/8TUEfpZPgl1u3-HyyGaUA0YMrFm8XSHfYtY6tfqFX7s">Profundizando en el Ecosistema STARKs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="propiedas-de-las-starks"><a class="header" href="#propiedas-de-las-starks">Propiedas de las STARKs</a></h2>
<p>Hemos visto cómo diferenciar los tipos de pruebas según su criptografía, así como la comparativa entre varias de ellas. Ahora veamos cuáles son las dos propiedades esenciales en las pruebas y cómo se pueden lograr, antes de pasar a la definición de STARK</p>
<ol>
<li><strong>Succintness (Sucintez):</strong> exigimos que nuestras pruebas y, en particular, el tiempo de verificación sean sucintos, es decir, que sean órdenes de magnitud más pequeños que el tiempo necesario para calcular nuestro programa. De lo contrario, no habría ninguna ventaja para el verificador en utilizar la prueba en lugar del cálculo original.</li>
<li><strong>Heurística Fiat-Shamir:</strong> este es un proceso mediante el cual podemos convertir una prueba interactiva en una no interactiva. Funciona proporcionando compromisos a los mensajes que formarían la interacción y las funciones hash se utilizan como fuente de aleatoriedad.</li>
</ol>
<p>Uno de los protocolos que se utiliza en sistemas criptográficos, como los STARKs, para abordar el desafío de verificar eficientemente la corrección de grandes cálculos polinomiales es FRI (Fast Reed-Solomon Interactive Oracle Proofs of Proximity).</p>
<p>FRI utiliza códigos de corrección de errores Reed-Solomon para permitir pruebas interactivas eficientes. Esto significa que el probador puede proporcionar una prueba corta de la corrección del cálculo, mientras que el verificador puede verificar de manera eficiente la validez de la prueba. Este proceso interactivo permite realizar pruebas de proximidad, donde el verificador puede verificar de manera eficiente si el cálculo reclamado se acerca al resultado correcto sin tener que evaluar por completo todo el polinomio.</p>
<blockquote>
<p>El conjunto de operaciones matemáticas, bases criptográficas, FRI y otras propiedades, como Fiat-Shamir, permite que las STARKs logren seguridad cuántica y escalabilidad, al tiempo que proporcionan una verificación transparente y eficiente de cálculos complejos.</p>
</blockquote>
<p>Podemos decir entonces que los STARKs demuestran la correcta operación de una máquina virtual al demostrar que la traza de ejecución asociada es válida con respecto al AIR dado. En términos generales, las trazas de ejecución se organizan como tablas de números, y el protocolo STARK demuestra que estos números resuelven conjuntamente un sistema de polinomios.</p>
<p>Así vemos cómo algunas de estas propiedades, como la succintez, pueden venir de forma natural en las STARKs, y cómo el principio de Fiat-Shamir permite realizar pruebas interactivas. Además, contar con FRI como corrección de errores amplía las capacidades y visión de las STARKs, así que ahora vayamos a su definición</p>
<h2 id="s--scalable"><a class="header" href="#s--scalable">S = Scalable</a></h2>
<p>Una de las principales ventajas de STARKs es que al trasladar un cálculo fuera de la cadena, se reducen de manera exponencial los costos de verificación en la cadena de bloques. El proceso de creación de una prueba fuera de la cadena tiene un costo similar al de solicitar a un único nodo de la cadena de bloques que realice el cálculo.</p>
<p>La producción de pruebas no resulta considerablemente más costosa que la ejecución del cálculo original, y la validación de las pruebas es <strong>exponencialmente más rápida</strong> que la ejecución del cálculo original. Además, las pruebas son <strong>considerablemente más cortas</strong> en tamaño que el cálculo original.</p>
<p>Otra ventaja importante es que a medida que se incrementa la cantidad de cómputo, su crecimiento es casi lineal. Esto la convierte en una opción ideal para procesar transacciones a gran escala.</p>
<p><img src="./assets//Stark_2.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Además, se puede aprovechar la capacidad de paralelización de pruebas por el prover y recursividad de los STRAKs eficentes para mejorar significativamente la escalabilidad.</p>
<p><img src="./assets//Stark_3.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<h2 id="t--transparent"><a class="header" href="#t--transparent">T = Transparent</a></h2>
<p>La seguridad de las STARKs no depende de ceremonias de configuración elaboradas que puedan generar residuos tóxicos criptográficos, como ocurre en otras tecnologías de pruebas.</p>
<p>El uso de STARKs para iniciar la prueba basándose en criptografía simétrica, pseudoaleatoriedad y las matemáticas proporciona un inicio de ceremonia transparente y elimina la necesidad de una configuración de confianza inicial (trusted setup), lo que asegura la ausencia de residuos tóxicos y mejora la seguridad y confiabilidad general del sistema criptográfico.</p>
<p>Una característica importante de las STARKs es su construcción basada en el trabajo de <a href="https://es.wikipedia.org/wiki/Silvio_Micali">Micali</a>. En esta construcción, la única criptografía necesaria para producir o validar una prueba corta <code>𝛑</code> es una <strong>función hash criptográfica</strong> <code>H</code>, como <code>SHA-256</code> o <code>Keccak</code>. La elección de <code>H</code> se convierte en el único <strong>&quot;parámetro global&quot;</strong> que todos los usuarios del sistema de prueba deben conocer, y <strong>esta elección puede hacerse de manera pública, garantizando la transparencia de las pruebas criptográficas obtenidas a través de las STARKs.</strong></p>
<p>Sin embargo siempre comparamos STARKs con SNARKs o pruebas derivadas de criptografía asimétrica como las <a href="https://eprint.iacr.org/2013/279.pdf">Pinocchio</a> de ECC, pero cada una tiene sus varientes y esquemas diversos,  aunque para una explicación más clara cogeremos el ejemplo de <a href="https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6">VB en un artículo sobre zk-SNARKs</a>.</p>
<p><img src="./assets//Stark_4.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Imaginemos que tenemos un par de puntos <code>P</code> y <code>Q</code>, donde <code>P * k = Q</code>, y tienes un punto <code>C</code>, entonces no es posible obtener <code>C * k</code> a menos que <code>C</code> esté <strong>&quot;derivado&quot;</strong> de alguna manera que conozcas a partir de <code>P</code>. Esto puede parecer intuitivamente obvio, pero esta suposición en realidad no puede derivarse de ninguna otra suposición (por ejemplo, la dificultad del logaritmo discreto) que usualmente utilizamos al probar la seguridad de los protocolos basados en EC. Por lo tanto, los SNARKs se basan en una base un tanto más frágil que la ECC en general.</p>
<p>Supongamos que cae del cielo un par de puntos <code>(P, Q)</code>, donde <code>P * k = Q</code>, pero nadie conoce el valor de <code>k</code>. Ahora, supongamos que yo presento un par de puntos <code>(R, S)</code> donde <code>R * k = S</code>. Entonces, la suposición de conocimiento del extremo de la curva (KoE, por sus siglas en inglés) implica que la única forma en que podría haber creado ese par de puntos es tomando <code>P</code> y <code>Q</code>, y multiplicándolos por un factor <code>r</code> que <strong>solo yo conozco</strong>. También hay que tener en cuenta que, gracias a la magia de las parejas de curvas elípticas, verificar que <code>R = k * S</code> no requiere conocer <code>k</code>; en su lugar, simplemente puedes comprobar si <code>e(R, Q) = e(P, S)</code>, donde e es una función de emparejamiento de curvas elípticas.</p>
<p>Hagamos algo más interesante. Supongamos que caen del cielo diez pares de puntos: <code>(P_1, Q_1), (P_2, Q_2) ... (P_10, Q_10)</code>. En todos los casos, se cumple que <code>P_i * k = Q_i</code>, ahora, supongamos que te proporciono un par de puntos <code>(R, S)</code> donde <code>R * k = S</code>.</p>
<p><strong>¿Qué sabemos ahora?</strong> Que <code>R</code> es una combinación lineal de la forma <code>P_1 * i_1 + P_2 * i_2 + ... + P_10 * i_10</code>, donde yo conozco los coeficientes <code>i_1, i_2 ... i_10</code>, es decir, la única forma de obtener un par de puntos <code>(R, S)</code> de esta manera es tomando algunos múltiplos de <code>P_1, P_2 ... P_10</code> y sumándolos, y hacer el mismo cálculo con <code>Q_1, Q_2 ... Q_10.</code></p>
<p>Enrtonces tenemos que tener en cuenta que dado cualquier conjunto específico de puntos <code>P_1…P_10</code> para los que puedas querer verificar combinaciones lineales, en realidad no puedes crear los puntos correspondientes <code>Q_1…Q_10</code> sin conocer el valor de <code>k</code>, y si conoces el valor de <code>k</code>, entonces puedes crear un par <code>(R, S)</code> donde <code>R * k = S</code> para cualquier <code>R</code> que desees, sin necesidad de crear una combinación lineal.</p>
<p><strong>Por lo tanto, para que esto funcione, es absolutamente imperativo que quien cree esos puntos sea confiable y realmente elimine <code>k</code> una vez que haya creado los diez puntos.</strong></p>
<p>Se debe destacar la importancia de las ceremonias de ajuste inicial en ciertos casos, como en implementaciones de sistemas de votación. En estos casos, es crucial tener en cuenta quién ha sido el creador de los puntos y si existe alguna posibilidad de manipulación o si se ha eliminado correctamente el valor de k. Esto es necesario para lograr transparencia y evitar depender de estas verificaciones. En este sentido, los STARKs se presentan como una solución prometedora y <strong>EFICIENTE</strong>, ya que proporcionan una base sólida que elimina la necesidad de confiar en dichas ceremonias de ajuste inicial.</p>
<h2 id="ark--argument-of-knowledge"><a class="header" href="#ark--argument-of-knowledge">ARK = Argument of Knowledge</a></h2>
<p>Los argumentos de conocimiento “ARK” son llevados a cabo por el prover que opera fuera de la cadena principal. Este probador se encarga de ejecutar el cálculo requerido para la prueba, utilizando las entradas auxiliares necesarias, la realización de la prueba fuera de la cadena principal es clave, ya que debe garantizar la integridad y la confiabilidad del proceso.</p>
<p>La principal ventaja de esta metodología es que permite una verificación auténtica y matemáticamente sólida. Después de que el probador haya realizado el cálculo, puede proporcionar la prueba generada a cualquier computadora o entidad interesada para su verificación, haciendo uso de ARK sto significa que cualquier sistema informático puede confirmar la validez de la prueba de manera independiente.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starks-eficientes"><a class="header" href="#starks-eficientes">STARKS eficientes</a></h2>
<p>Está llegando el momento de comprender como los STARKs son una versión más eficiente de las <a href="https://en.wikipedia.org/wiki/Probabilistically_checkable_proof"><strong>(PCP)</strong></a>, un protocolo que permite establecer la exactitud de las declaraciones de <strong>CI</strong>, mediante una verificación aleatoria local en una prueba larga, este protocolo se realiza entre un prover <strong>PCP</strong> y un verifier <strong>PCP</strong>.</p>
<p>El prover <strong>PCP</strong> produce una cadena de prueba <code>𝚿</code> que codifica el seguimiento de cálculo de la declaración de <code>CI</code>, a pesar de que <code>𝚿</code> es más larga que la traza de cálculo de pasos <code>T</code>. Sin embargo, la cadena de prueba <code>𝚿</code> tiene la propiedad especial de que puede ser validada a través de una prueba probabilística que lee solo una pequeña parte de <code>𝚿</code>.</p>
<p>El verifier <strong>PCP</strong>, al recibir la misma declaración de <strong>CI</strong> <code>(A, x, y, T)</code>, puede validar la cadena de prueba <code>𝚿</code> leyendo aleatoriamente unas pocas ubicaciones de <code>𝚿</code> y luego realizar una <strong>&quot;verificación local&quot;</strong> económica en los valores leídos. El número de ubicaciones de lectura puede ser una pequeña constante, como 3, independientemente de la longitud de la traza de cálculo <code>T</code>.</p>
<p>Si la declaración de CI es verdadera, el verifier siempre aceptará. Sin embargo, si la declaración de CI es falsa, el verificador la rechazará con alta probabilidad, sin importar cómo se haya elegido la cadena de prueba <code>𝚿</code>.</p>
<p><img src="./assets/Stark_Sudoku.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En la imagen animada podemos ver un ejemplo de <strong>PCP</strong> con un conjunto de resticciones un sudoku y ahora veremos como los STARKs eficiente pueden mejorar la eficiencia de las <strong>PCP</strong> y <strong>MPCP</strong> con <strong>IOPs</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iops---interactive-oracle-proof"><a class="header" href="#iops---interactive-oracle-proof">IOPs - Interactive Oracle Proof</a></h1>
<p>Las Interactive Orcale Proof <a href="https://eprint.iacr.org/2016/116"><strong>(IOP)</strong></a> son un nuevo tipo de sistema de prueba que combina las propiedades clave de <strong>pruebas interactivas</strong> y <strong>PCP</strong>, las <strong>IOP</strong> permiten que un verifier esté convencido de la exactitud de una declaración al interactuar con un prover no confiable mientras lee solo algunos bits de los mensajes enviados por el prover. Las <strong>IOP</strong> se han vuelto muy prominentes en el diseño de sistemas de prueba eficientes en los últimos años.</p>
<blockquote>
<p><strong>Las construcciones STARK eficientes se obtienen combinando IOP eficientes y funciones hash criptográficas. El IOP le confiere al STARK su escalabilidad, mientras que la función hash le confiere al STARK su transparencia.</strong></p>
</blockquote>
<p>Las STARKs eficientes se basan en IOP, de manera informal, un prover y un verifier participan en un protocolo interactivo en el que, en cada ronda, el verifier envía algo de aleatoriedad <code>𝛔ᵢ</code> al prover, y el prover responde con una proof larga <code>𝚿ᵢ</code>. Al final de la interacción, el verificador realiza una verificación local aleatoria de todas las proof largas <code>(𝚿₁,𝚿₂,…)</code> enviadas por el prover a lo largo de la interacción.</p>
<p>Ahora, antes de sumergirnos en el mundo de los pasos de creación de un STARKs y su eficiencia, es importante comprender qué es un polinomio, ya que desempeñan un papel crucial en la construcción y verificación de STARKs. Son utilizados para representar y manipular datos de manera eficiente, lo que permite lograr un alto nivel de compresión y optimización en el proceso de verificación.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="polinomios"><a class="header" href="#polinomios">Polinomios</a></h2>
<p>Los polinomios son una poderosa herramienta algebraica que se utiliza en diversas ramas de las matemáticas y la física. Estas expresiones algebraicas están formadas por términos que contienen variables y coeficientes. Los términos son la suma o resta de monomios, que son productos de constantes y variables elevadas a exponentes enteros no negativos.</p>
<p>Un polinomio puede tener una o varias variables, y su grado está determinado por el exponente más alto presente en los términos del polinomio. Por ejemplo, el polinomio <code>3x² - 2x + 1</code>  es un polinomio de grado 2, ya que el término de mayor grado tiene un exponente de 2.</p>
<p>Los polinomios se pueden sumar, restar, multiplicar y dividir, y se emplean en ecuaciones algebraicas, cálculo, geometría y muchas otras ramas de las ciencias exactas.</p>
<p><strong>¿Por qué no evalúa el verifier los propios polinomios?</strong></p>
<ul>
<li>Prque, en realidad, el prover no envía todos los polinomios al verificador, si lo hiciera perderíamos sucintez, contienen más información que nuestra declaración original, por lo que el prover sólo proporciona un compromiso con los polinomios.</li>
</ul>
<p><strong>¿Qué propiedades de los polinomios son importantes en este caso?</strong></p>
<ul>
<li>Los polinomios son buenos códigos de corrección de errores.</li>
</ul>
<p>Si tenemos polinomios de grado <code>d</code> sobre un dominio de codificación <code>D</code>, y dos mensajes <code>m₁</code> y <code>m₂</code>, entonces  <code>m₁</code> y <code>m₂</code> diferirán en <code>|D|-d</code> puntos. Esto es importante porque queremos que la diferencia entre una declaración correcta y una incorrecta sea grande, de modo que sea fácil de encontrar.</p>
<p>Esto conduce a un buen muestreo, lo que ayuda a la sucintez, sólo necesitamos muestrear unos pocos valores para estar seguros de que la probabilidad de error es lo suficientemente baja como para ser insignificante.</p>
<ul>
<li>Disponer de pruebas eficaces de lote cero mantiene la sucintez.</li>
</ul>
<p>Tener la capacidad de realizar pruebas de lote cero eficaces es fundamental. Esto nos permite demostrar de manera conjunta que un conjunto de elementos cumple con una determinada propiedad, en lugar de tener que probar cada elemento de forma individual, esta técnica de prueba en lote nos permite lograr una mayor concisión y eficiencia en la verificación.</p>
<p>Imaginemos que queremos demostrar que un polinomio de grado grande <code>P(x) (grado ~ 10 millones)</code> evalúa a <code>0</code> en los puntos <code>1...1 millón</code>, pero queremos hacerlo con una sola consulta.</p>
<p>Imaginemos que nuestra afirmación es que <code>P</code> desaparece en estos puntos. Si el verifier sólo utiliza el muestreo, el prover podría hacer trampas fácilmente proporcionando un punto que se evalúe como <code>0</code>, pero los otros <code>999.999</code> podrían ser distintos de <code>0</code>.</p>
<h2 id="resolviendo-el-problema"><a class="header" href="#resolviendo-el-problema">Resolviendo el problema</a></h2>
<p>Consideremos un conjunto <code>S = 1...10⁶</code></p>
<p>Definir <code>V</code> como el polinomio que se anula en estos puntos, es decir: <code>(x - 1)(x - 2)(x - 3)...</code> el grado de <code>V = tamaño de S</code> y esto es beneficioso porque:</p>
<ol>
<li><code>P(x) = P'(x) • V(x)</code></li>
<li><code>Grado de P = Grado de P' - Tamaño de S.</code></li>
</ol>
<p>La introducción de <code>V(x)</code> nos permite verificar en todo el dominio.</p>
<ul>
<li>Estos polinomios tienen una propiedad <strong>&quot;multiplicadora&quot;</strong>. Podemos <strong>&quot;envolver&quot;</strong> una restricción alrededor de un polinomio.</li>
</ul>
<p>Por ejemplo, si tenemos la restricción <strong>C</strong>, que indica que nuestra evaluación siempre será 0 o 1, podríamos expresarla como <code>C(x) = x • (x - 1)</code>. Esto se podría interpretar como restringir una salida para que sea un booleano, lo cual es útil en términos de integridad computacional.</p>
<p>En lugar de tener <code>x</code> como un simple punto, podríamos considerar la evaluación de un  de un polinomio <code>P₁(x)</code> en un punto específico, es decir, <code>C(P₁(x)) = P₁(x)•(P₁(x)-1)</code></p>
<p>Los grados de los polinomios resultantes de la multiplicación son aditivos, por lo que el grado de <code>C(x) = 2 • grado de P₁(x)</code></p>
<p>Podemos afirmar que si <code>P₁(x)</code> cumple con esta restricción para nuestro conjunto <code>S</code>, entonces, como mencionamos anteriormente, existe un polinomio <code>P'(x)</code> tal que:</p>
<ul>
<li><code>C(P₁(x)) = P'(x) • V(x)</code></li>
</ul>
<p>Si <code>P₁(x)</code> no cumpliera con la restricción (por ejemplo, si para un valor de <code>x, P₁(x) = 93</code>), entonces no podríamos encontrar esos polinomios, la igualdad no se cumpliría y habría un residuo en la ecuación anterior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creando-un-stark"><a class="header" href="#creando-un-stark">Creando un STARK</a></h1>
<p>En esta parte final del documento y después de haber explicado algunas propiedades  importantes de los polinomios y que resuelven, exploraremos la creación de una STARK desde los fundamentos matemáticos más profundos. Para obtener una comprensión completa de los procesos involucrados y cómo se puede combinar un PCP con criptografía ligera para obtener un STARK, te recomendamos revisar la serie lanzada por Starkware,que proporciona una profundización inicial más detallada.</p>
<p>Además, encontrarás a continuación los enlaces a cinco artículos fundamentales  traducidos al español que complementarán tu aprendizaje:</p>
<ol>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Comienza%20el%20viaje.md">Comienza el Viaje</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20I.md">Aritmetización I</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20II.md">Aritmetización II</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Prueba%20de%20bajo%20grado.md">Pruebas de Bajo Grado</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Un%20marco%20para%20STARKs%20eficientes.md">Un Frameword para STARKs Eficientes</a></li>
</ol>
<p>Estos recursos adicionales te brindarán una visión más completa y práctica del proceso de creación de una STARK. También te recomendamos revisar los repositorios relacionados y los videos de creación de una STARK en Pioneros Clases 3, un Basecamp descentralizado en Español creado por Starknet, o el den inglés impartido por Eli Ben Saason</p>
<p>Nos interesa la Integridad Computacional (CI), por ejemplo, saber que el programa de Cairo que escribiste se calculó correctamente.</p>
<ul>
<li>Tenemos que pasar por una serie de transformaciones desde el trazado de nuestro programa, hasta la prueba.</li>
<li>La primera parte de esto se llama aritmetización, y consiste en tomar nuestra traza y convertirla en un conjunto de polinomios.</li>
<li>Nuestro problema se convierte entonces en uno en el que el prover intenta convencer a un verificador de que el polinomio es de grado bajo.</li>
<li>El verificador está convencido de que el polinomio es de grado bajo si y sólo si el cálculo original es correcto (salvo una probabilidad infinitesimalmente pequeña).</li>
</ul>
<p><img src="./assets/Stark_5.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El uso de la aletoriedad es muy importante para el prover y el verifier, mientras que el prover utiliza la aleatoriedad para alcanzar el conocimiento cero, el verificador utiliza la aleatoriedad al generar consultas al prover, para detectar trampas por parte del prover.</p>
<p>Gran parte del trabajo que se realiza al crear una prueba consiste en garantizar que sea sucinta y que pueda elaborarse y verificarse en un tiempo razonable. Por tanto, nuestro plan consistirá en:</p>
<ul>
<li>Reformular la traza de ejecución como un polinomio,</li>
<li>Extenderlo a un gran dominio,</li>
<li>Transformarlo, utilizando las restricciones polinómicas, en otro polinomio que se garantiza que es de grado bajo si y sólo si la traza de ejecución es válida.</li>
<li>Queremos lograr una verificación sucinta, en la que el verificador de la declaración CI requiera exponencialmente menos recursos que los necesarios para la repetición ingenua.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aritmetización"><a class="header" href="#aritmetización">Aritmetización</a></h1>
<p>Tenemos dos pasos principales en este proceso:</p>
<ol>
<li>Generación de una traza de ejecución y restricciones polinómicas.</li>
<li>Transformar estos dos objetos en un único polinomio de bajo grado.</li>
</ol>
<p>En términos de interacción prover-verifier, realmente lo que ocurre es que entre ambos acuerdan de antemano cuáles son las restricciones polinómicas.</p>
<p>A continuación, el prover genera una traza de ejecución y, en la interacción posterior, intenta convencer al verificador de que las restricciones polinómicas se cumplen en esta traza de ejecución, sin que el verificador lo vea.</p>
<p>La traza de ejecución es una tabla que representa los pasos del cálculo subyacente, donde cada fila representa un único paso y el tipo de traza de ejecución que buscamos generar debe tener la característica especial de ser sucintamente comprobable:</p>
<ul>
<li>Cada fila puede ser verificada basándose sólo en las filas que están cerca de ella en la traza, y el mismo procedimiento de verificación se aplica a cada par de filas.</li>
</ul>
<p>Por ejemplo, imaginemos que nuestra traza representa un total en ejecución, con cada paso de la siguiente manera.</p>
<pre><code class="language-bash">                    ╔════════╦═══════════╦═══════╗
                    ║  PASO  ║  IMPORTE  ║ TOTAL ║
                    ╠════════╬═══════════╬═══════╣
                    ║   0    ║     0     ║   0   ║
                    ╠════════╬═══════════╬═══════╣
                    ║   1    ║     5     ║   5   ║
                    ╠════════╬═══════════╬═══════╣
                    ║   2    ║     2     ║   7   ║
                    ╠════════╬═══════════╬═══════╣
                    ║   3    ║     2     ║   9   ║
                    ╠════════╬═══════════╬═══════╣
                    ║   4    ║     3     ║   12  ║
                    ╠════════╬═══════════╬═══════╣
                    ║   5    ║     6     ║   18  ║
                    ╚════════╩═══════════╩═══════╝
</code></pre>
<p>Si representamos la fila como <code>i</code> , y la columna como <code>j</code> , y los valores como <code>Aᵢ,ⱼ</code> , podríamos escribir algunas restricciones sobre esto de la siguiente manera:</p>
<ul>
<li><code>A₀,₂=0</code></li>
<li><code>∀1 &gt;= i &lt;= 5 : Aᵢ,₂ − Aᵢ,₁ − Aᵢ-₁,₂ = 0</code></li>
<li><code>A₅,₂ = 18</code></li>
</ul>
<p>Se trata de restricciones polinómicas lineales en <code>Aᵢ,ⱼ</code></p>
<p>Nótese que aquí estamos consiguiendo cierta concisión porque podríamos representar un número mucho mayor de filas con sólo estas 3 restricciones.</p>
<p>El sistema de restricciones aritméticas define al menos dos tipos de restricciones sobre la traza de ejecución algebraica:</p>
<ol>
<li><strong>Restricciones de contorno:</strong> al principio o al final del cálculo, un registro indicado tiene un valor determinado.</li>
<li><strong>Restricciones de transición:</strong> dos tuplas de estado consecutivas cualesquiera evolucionan de acuerdo con la función de transición de estado. En conjunto, estas restricciones se conocen como representación algebraica intermedia o AIR.</li>
</ol>
<p>Las STARKs avanzadas pueden definir más tipos de restricciones para tratar con la memoria o con la consistencia de los registros dentro de un ciclo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polinomio-para-nuestra-traza"><a class="header" href="#polinomio-para-nuestra-traza">Polinomio para nuestra traza</a></h1>
<p>También en este caso definimos un polinomio <code>f(x)</code> tal que los elementos de la traza de ejecución son evaluaciones de <code>f</code> en potencias de algún generador <code>g</code>.</p>
<p>Recordemos que nuestro campo finito tendrá generadores, que utilizaremos para indexar los pasos de nuestra traza. Tomando una secuencia de Fibonacci podemos crear restricciones como:</p>
<ul>
<li><code>∀ x ∈ {1,g²,g³...g⁵⁰⁹}: f(g²x) ₋ f(gx) ₋ f(x) = 0</code></li>
</ul>
<p>Esto restringe los valores entre las filas subsiguientes. También significa que los valores g son raíces de este polinomio.</p>
<p>Por lo tanto, podemos utilizar el enfoque que vimos anteriormente para proporcionar el polinomio de fuga utilizando el término <code>(x - gⁱ)</code> y a partir de él creamos el polinomio de composición.</p>
<p>El hecho básico sobre polinomios y sus raíces es que si <code>p(x)</code> es un polinomio, entonces <code>p(a)=0</code> para algún valor específico a, si y sólo si existe un polinomio <code>q(x)</code> tal que <code>(x-a)q(x)=p(x)</code>, y <code>deg(p)=deg(q)+1.</code></p>
<p>Esta expresión coincide con el polinomio de grado 2 como máximo si nuestra traza de ejecución ha sido correcta, es decir, ha obedecido a la restricción de paso que hemos definido.</p>
<p>Si la traza difiere de eso, entonces es poco probable que esta expresión produzca un polinomio de bajo grado.</p>
<h1 id="composición-polinomial"><a class="header" href="#composición-polinomial">Composición Polinomial</a></h1>
<p>El Polinomio de Composición en su traducción también conocido como Composición Polinomial (CP), se realiza para demostrar eficazmente la validez del rastro de ejecución, nos esforzamos por alcanzar los dos objetivos siguientes:</p>
<ol>
<li>Componer las restricciones sobre los polinomios de la traza para hacerlas cumplir en la traza.</li>
<li>Combinar las restricciones en un único polinomio (más grande), denominado Composición Polinomial, de modo que se pueda utilizar una única prueba de grado bajo para atestiguar su grado bajo.</li>
</ol>
<h1 id="ampliando-el-polinomio"><a class="header" href="#ampliando-el-polinomio">Ampliando el polinomio</a></h1>
<p>Como hemos visto antes, los polinomios pueden utilizarse para construir buenos códigos de corrección de errores, ya que dos polinomios de grado d, evaluados en un dominio considerablemente mayor que d, son diferentes en casi todas partes.</p>
<p>Observando esto, podemos extender la traza de ejecución pensando en ella como una evaluación de un polinomio en algún dominio, y evaluando este mismo polinomio en un dominio mucho mayor. Extendiendo de manera similar una traza de ejecución incorrecta, se obtiene una cadena muy diferente, lo que a su vez hace posible que el verificador distinga entre estos casos utilizando un pequeño número de consultas.</p>
<h2 id="de-restricciones-polinómicas-al-problema-de-las-pruebas-de-bajo-grado"><a class="header" href="#de-restricciones-polinómicas-al-problema-de-las-pruebas-de-bajo-grado">De restricciones polinómicas al problema de las pruebas de bajo grado</a></h2>
<p>En general, si nuestro cálculo implica <code>N</code> pasos, la traza de ejecución estará representada por polinomios de grado inferior a <code>N</code></p>
<ul>
<li><code>f(X) = c₀ + c₁X + c₂X² +⋯+ cɴ-₁Xᴺ⁻¹</code></li>
</ul>
<p>Los coeficientes <code>cᵢ</code> están en el campo <code>𝔽</code> y el límite <code>N</code> en el grado es típicamente grande, quizá del orden de unos pocos millones. A pesar de ello, estos polinomios se denominan de bajo grado.</p>
<p>Esto se debe a que el punto de comparación es el tamaño del campo. Por interpolación, toda función sobre <code>𝔽</code> puede representarse mediante un polinomio.</p>
<p>La mayoría de ellos tendrán un grado igual al tamaño total del campo, por lo que, comparado con éste, <code>N</code> es realmente bajo.</p>
<p>Este tipo de funciones, coherentes con un polinomio de bajo grado, también se conocen como códigos <code>Reed-Solomon</code>.</p>
<p>Tras la generación de la traza, el prover se compromete con ella. Recordemos que no queremos enviar los polinomios al verificador como un todo, pero necesitamos que el prover se comprometa con ellos.</p>
<p>En todo el sistema, los compromisos se ejecutan construyendo árboles de Merkle sobre las series de elementos de campo y enviando las raíces de Merkle al verificador.</p>
<p>Queremos que un verificador plantee al prover un número muy reducido de preguntas y decida si acepta o rechaza la prueba con un alto nivel de precisión garantizado. Idealmente, al verificador le gustaría pedir al prover que proporcione los valores en unos pocos lugares (aleatorios) en la traza de ejecución, y comprobar que las restricciones polinómicas se mantienen para estos lugares.</p>
<p>Una traza de ejecución correcta pasará naturalmente esta prueba.</p>
<p>Sin embargo, no es difícil construir una traza de ejecución completamente errónea (especialmente si sabíamos de antemano qué puntos se comprobarían), que viole las restricciones sólo en un punto de la traza único y, al hacerlo, llegar a un resultado completamente alejado y diferente. Identificar este fallo mediante un pequeño número de consultas aleatorias es altamente improbable.</p>
<p>Pero recuerda que los polinomios tienen algunas propiedades útiles aquí:</p>
<ul>
<li>Dos polinomios (diferentes) de grado <code>d</code> evaluados en un dominio considerablemente mayor que <code>d</code> son diferentes en casi todas partes.</li>
</ul>
<p>Así que si tenemos un prover deshonesto, que crea un polinomio de bajo grado representando su traza (que es incorrecta en algún punto) y lo evalúa en un dominio grande, será fácil ver que este es diferente al polinomio correcto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pruebas-de-bajo-grado"><a class="header" href="#pruebas-de-bajo-grado">Pruebas de Bajo Grado</a></h1>
<p>Las pruebas de bajo grado son realmente el corazón del proceso de verificación.</p>
<p>El supuesto de comprobación de bajo grado establece la existencia de un verificador probabilístico que comprueba si una función f es de grado como máximo d ≪ |𝔽|. El verificador debe distinguir entre los dos casos siguientes:</p>
<ol>
<li><strong>La función <code>f</code> es igual a un polinomio de bajo grado:</strong> es decir, existe un polinomio <code>p(x)</code> sobre <code>𝔽</code>, de grado menor que <code>d</code>, que coincide con <code>f</code> en todas partes.</li>
<li><strong>La función <code>f</code> está lejos de TODOS los polinomios de bajo grado:</strong> por ejemplo, necesitamos modificar al menos el <strong>10%</strong> de los valores de <code>f</code> antes de obtener una función que concuerde con un polinomio de grado inferior a <code>d</code>.</li>
</ol>
<p>La aritmetización muestra que un prover honesto que trate con una afirmación verdadera caerá en el primer caso, mientras que un prover (posiblemente malicioso) que intente <strong>&quot;probar&quot;</strong> una afirmación falsa caerá, con alta probabilidad, en el segundo caso.</p>
<p>Otra forma de ver esto es que el polinomio de traza correcto combinado con las restricciones será necesariamente de grado bajo, el grado proviene del número de pasos en nuestra traza (probablemente unos pocos millones), y la combinación de esto con los polinomios de restricción (probablemente &lt; 10).</p>
<p>En general, cabría esperar que los polinomios <strong>&quot;correctos&quot;</strong> tuvieran un grado de alrededor de <code>10⁷</code> , mientras que un prover tramposo que eligiera puntos al azar del campo <code>𝔽</code> obtendría, tras la interpolación, polinomios de grado comparable al tamaño del campo, es decir, del orden de <code>2²⁵⁶</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fri"><a class="header" href="#fri">FRI</a></h1>
<p>FRI son las siglas de <a href="https://eccc.weizmann.ac.il/report/2017/134/">Fast Reed-Solomon IOP of Proximity</a>, es un protocolo que establece que un polinomio comprometido tiene un grado limitado.</p>
<p>El <a href="https://book.starknet.io/chapter_10/fri.html"><strong>FRI</strong></a> es complejo y gran parte del procesamiento que lo compone está diseñado para que las pruebas sean factibles y sucintas. También hay mucho procesamiento involucrado con la protección contra diversos tipos de ataques que podrían ser realizados por el prover, y garantizar que todo se lleva a cabo en el conocimiento cero.</p>
<p>Su objetivo es encontrar si un conjunto de puntos se encuentran mayoritariamente en un polinomio de bajo grado y puede alcanzar una complejidad de prueba lineal y una complejidad de verificación logarítmica.</p>
<p>En general, hay 2 etapas : commit y query, contenidas en los siguientes pasos repetidos.</p>
<ol>
<li>El verifier envía un número aleatorio al prover.</li>
<li>El prover genera un nuevo polinomio.</li>
<li>El verifier genera los conjuntos puntuales de consultas y los envía al prover.</li>
<li>El prover evalúa los valores polinómicos correspondientes.</li>
<li>El verifier realiza una comprobación de validez.</li>
</ol>
<p>Aprendamos como FRI es un protocolo entre un probador y un verificador, que establece que una codeword dada pertenece a un polinomio de grado bajo.</p>
<p>El prover conoce explícitamente este codeword, mientras que el verificador sólo conoce su raíz Merkle y las hojas de su elección, suponiendo la validación satisfactoria de las rutas de autenticación que establecen la pertenencia de las hojas al Merkle Tree.</p>
<p>Una de las grandes ideas para los sistemas de pruebas de los últimos años ha sido la técnica de dividir y doblar. La idea es reducir una afirmación a dos afirmaciones de la mitad de tamaño. A continuación, ambas afirmaciones se fusionan en una sola utilizando pesos aleatorios proporcionados por el verificador.</p>
<p>Después de muchos pasos, la afirmación se ha reducido a una de tamaño trivial que es verdadera si y sólo si (modulo alguna degradación de seguridad insignificante) la afirmación original era verdadera.</p>
<p>El verfier inspecciona los Merkle Tree (en concreto: pide al prover que proporcione las hojas indicadas con sus rutas de autenticación) de rondas consecutivas para comprobar una relación lineal simple.</p>
<p>Para los provers honestos, el grado de los polinomios representados también se reduce a la mitad en cada ronda y, por tanto, es mucho menor que la longitud de la codeword. Sin embargo, para los provers maliciosos, este grado es uno menos que la longitud de la codeword. En el último paso, el prover envía una codeword no trivial correspondiente a un polinomio constante.</p>
<p>Después de explorar los diferentes pasos en la creación detrás de un STARKs y la importancia de las pruebas de integridad, es evidente que estas pruebas son fundamentales para garantizar la seguridad y confiabilidad de los sistemas del Futuro.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leve-introducción-cairo"><a class="header" href="#leve-introducción-cairo">Leve introducción Cairo</a></h1>
<p>Como último apartado para finalizar este documento, antes de adentrarnos en los próximos temas sobre la arquitectura de Starknet y Cairo, haremos una breve introducción a Cairo y su relación con la CVM. En este contexto, es relevante comprender cómo todos los pasos de un cálculo pueden ser representados mediante polinomios, utilizando lo que se conoce como la Representación Algebraica Intermedia (AIR).</p>
<p>Los bloques de cálculo pueden ser representados como AIR y tienen la capacidad de combinarse entre sí, lo que se convierte en la base de Cairo. Para ilustrarlo mediante una analogía con el hardware:</p>
<ul>
<li><strong>ASIC (AIR)</strong></li>
<li><strong>CPU (varias AIR)</strong></li>
</ul>
<p>El nombre <strong>Cairo</strong> deriva de una CPU construida a partir de AIRs:</p>
<ul>
<li><strong>(CPU-AIR, Oh genial -&gt; CAIRO)</strong></li>
</ul>
<p>Cairo es un lenguaje funcional de alto nivel, no determinista y Turing completo, que cuenta con un modelo de memoria basado en registros y un compilador, el cual  produce una tabla de pasos computacionales llamada traza.</p>
<blockquote>
<p>En los programas escritos en Cairo, se especifican los resultados que se consideran aceptables, no cómo obtenerlos.</p>
</blockquote>
<p>Vimos como en el proceso de construcción de pruebas STARK, el prover utiliza esta traza para crear Representaciones Algebraicas Intermedias (AIRs), que luego se combinan y se convierten en pruebas STARK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusión"><a class="header" href="#conclusión">Conclusión</a></h1>
<p>Con esto, concluimos nuestro profundo viaje por el mundo de la criptografía, explorando la generación de claves privadas y públicas, así como sus diversas implementaciones. Hemos aprendido cómo Starknet y los esquemas de firmas pueden prevenir ataques criptoanalíticos, y hemos visto cómo las STARKs han sido diseñadas desde su inicio para brindar seguridad matemática frente a ataques cuánticos, siguiendo sus principios fundamentales.</p>
<p>Starknet está sentando las bases de la criptografía moderna y creando un ecosistema escalable, integro y seguro por una de las mayores descentralizada como Ethereum, escalemos juntos.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="otras-arquitecturas"><a class="header" href="#otras-arquitecturas">Otras Arquitecturas</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
