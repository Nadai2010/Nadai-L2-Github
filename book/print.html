<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>L2 Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Introducci√≥n.html"><strong aria-hidden="true">1.</strong> Introducci√≥n</a></li><li class="chapter-item expanded "><a href="Bases_Criptogr√°ficas.html"><strong aria-hidden="true">2.</strong> Bases Criptogr√°ficas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Criptograf√≠a_Sim√©trica.html"><strong aria-hidden="true">2.1.</strong> Criptograf√≠a Sim√©trica</a></li><li class="chapter-item expanded "><a href="Criptograf√≠a_Asim√©trica.html"><strong aria-hidden="true">2.2.</strong> Criptograf√≠a Asim√©trica</a></li><li class="chapter-item expanded "><a href="Criptograf√≠a_H√≠bridas.html"><strong aria-hidden="true">2.3.</strong> Criptograf√≠a H√≠bridas</a></li><li class="chapter-item expanded "><a href="Firmas_Digitales.html"><strong aria-hidden="true">2.4.</strong> Firmas Digitales</a></li><li class="chapter-item expanded "><a href="Generador_de_Claves.html"><strong aria-hidden="true">2.5.</strong> Generador de Claves</a></li><li class="chapter-item expanded "><a href="Funciones_Hash.html"><strong aria-hidden="true">2.6.</strong> Funciones Hash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Merkle_Tree_en_Blockchain.html"><strong aria-hidden="true">2.6.1.</strong> Merkle Tree en Blockchain</a></li><li class="chapter-item expanded "><a href="Patricia_Merkle_Trie.html"><strong aria-hidden="true">2.6.2.</strong> Patricia Merkle Trie</a></li><li class="chapter-item expanded "><a href="Sha256.html"><strong aria-hidden="true">2.6.3.</strong> SHA-256</a></li><li class="chapter-item expanded "><a href="Keccak.html"><strong aria-hidden="true">2.6.4.</strong> Keccak - El nuevo SHA-3</a></li></ol></li><li class="chapter-item expanded "><a href="Quantum_Secure.html"><strong aria-hidden="true">2.7.</strong> Quantum Secure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Grover.html"><strong aria-hidden="true">2.7.1.</strong> Grover</a></li><li class="chapter-item expanded "><a href="Shor.html"><strong aria-hidden="true">2.7.2.</strong> Shor</a></li><li class="chapter-item expanded "><a href="Lattice.html"><strong aria-hidden="true">2.7.3.</strong> Lattice</a></li><li class="chapter-item expanded "><a href="Kyber_Crystal.html"><strong aria-hidden="true">2.7.4.</strong> Kyber Crystal</a></li><li class="chapter-item expanded "><a href="EOA_AA.html"><strong aria-hidden="true">2.7.5.</strong> EOA y AA - Firmantes</a></li></ol></li><li class="chapter-item expanded "><a href="Starknet_AA.html"><strong aria-hidden="true">2.8.</strong> Starknet AA</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Stark_Curve.html"><strong aria-hidden="true">2.8.1.</strong> EC en Cairo - STARK Curve</a></li><li class="chapter-item expanded "><a href="Secp256r1.html"><strong aria-hidden="true">2.8.2.</strong> MyBraavos Secp256r1</a></li><li class="chapter-item expanded "><a href="Stark_Key.html"><strong aria-hidden="true">2.8.3.</strong> Creaci√≥n de una Stark Key en StarkEx</a></li></ol></li><li class="chapter-item expanded "><a href="Starknet_funciones_hash.html"><strong aria-hidden="true">2.9.</strong> Starknet y Funciones Hash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Keccak_Starknet.html"><strong aria-hidden="true">2.9.1.</strong> Hash Keccak</a></li><li class="chapter-item expanded "><a href="Pedersen_Starknet.html"><strong aria-hidden="true">2.9.2.</strong> Hash Pedersen</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">L2 Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introducci√≥n"><a class="header" href="#introducci√≥n">Introducci√≥n</a></h1>
<p>¬°Hola comunidad! üëã</p>
<p>Antes que nada nos gustar√≠a expresar nuestro m√°s sincero agradecimiento a todos aquellos que han contribuido y hecho posible la realizaci√≥n de esta exhaustiva investigaci√≥n y documento sobre criptograf√≠a y como se adaptan en StarkWare. Especial reconocimiento a los expertos @X, @Y, @Z y @A, quienes han brindado sus valiosas correcciones y orientaci√≥n en numerosos aspectos del trabajo. Su experiencia y conocimientos han sido fundamentales para alcanzar los resultados y conclusiones presentados en este informe.</p>
<p>En esta ocasi√≥n, estamos emocionados de presentar una serie de art√≠culos profundos sobre el desarrollo detr√°s de Starkware. Recomendamos a los lectores que previamente hayan le√≠do otros documentos y tengan conocimientos t√©cnicos para una mejor comprensi√≥n, para este documento en concreto recomendamos:</p>
<p><a href="https://starkware.co/resource/stark-endgame/">Stark END-Game</a> | <a href="https://starkware.co/resource/stark-endgame/">Recursive Stark</a> |  <a href="https://starkware.co/resource/account-abstraction-improving-security-and-user-experience-for-mainstream-crypto-adoption/">Account Abstraction</a> | <a href="https://starkware.co/stark-math-a-very-short-primer/">Intro Maths Starks</a></p>
<p>El panorama actual es complejo, pero nos enorgullece contar con las mentes m√°s brillantes trabajando en el ecosistema, una STARK que los une a todos.</p>
<p>¬øEres o ser√°s uno de ellos? Antes de sumergirnos, exploraremos una serie de conceptos para establecer bases e historias sobre criptograf√≠a, lo que nos permitir√° adentrarnos a√∫n m√°s en el ecosistema STARKs. ¬°Comencemos!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bases-criptogr√°ficas"><a class="header" href="#bases-criptogr√°ficas">Bases Criptogr√°ficas</a></h1>
<p>La <a href="https://en.wikipedia.org/wiki/Cryptography"><strong>criptograf√≠a</strong></a> es el campo de estudio y desarrollo de t√©cnicas y algoritmos para asegurar la confidencialidad, integridad y autenticidad de la informaci√≥n. Utilizando claves secretas o p√∫blicas, <strong>la criptograf√≠a transforma los datos en un formato incomprensible para terceros no autorizados</strong>, garantizando que solo los destinatarios leg√≠timos puedan acceder a la informaci√≥n original. La criptograf√≠a desempe√±a un papel vital en la seguridad de las comunicaciones y el almacenamiento de datos, protegiendo la privacidad y la confianza en diversos √°mbitos de la vida moderna.</p>
<ul>
<li>
<p><strong>Encryption:</strong> <a href="https://en.wikipedia.org/wiki/Encryption">el cifrado</a> es el proceso de convertir informaci√≥n legible en un formato ilegible llamado texto cifrado, mediante el uso de algoritmos y una clave. El objetivo principal del cifrado es proteger la confidencialidad de los datos, asegurando que solo las personas autorizadas puedan acceder y comprender la informaci√≥n cifrada. Para ello, se aplica una serie de transformaciones matem√°ticas al texto original, lo que dificulta su interpretaci√≥n sin la clave correspondiente.</p>
</li>
<li>
<p><strong>Cryptographic protocol:</strong> <a href="https://en.wikipedia.org/wiki/Cryptographic_protocol">un protocolo criptogr√°fico</a> o protocolo de seguridad (tambi√©n llamado protocolo de cifrado) es un protocolo abstracto o concreto que realiza funciones relacionadas con la seguridad, aplicando m√©todos criptogr√°ficos.‚Äã Un protocolo describe la forma en que un algoritmo debe usarse.</p>
</li>
<li>
<p><strong>Algorithm:</strong> <a href="https://es.wikipedia.org/wiki/Algoritmo">un algoritmo</a> de cifrado es un procedimiento que convierte un mensaje de texto plano en un texto cifrado. Los algoritmos modernos utilizan matem√°ticas avanzadas y una o varias claves de cifrado. Esto hace que sea relativamente f√°cil cifrar un mensaje, pero pr√°cticamente imposible descifrarlo sin conocer las claves requeridas.</p>
</li>
</ul>
<h2 id="esquema-de-cifrado"><a class="header" href="#esquema-de-cifrado">Esquema de cifrado</a></h2>
<p>Estos esquemas definen c√≥mo se realiza la transformaci√≥n de los datos originales en texto cifrado y c√≥mo se realiza la operaci√≥n inversa para recuperar los datos originales a partir del texto cifrado. Un esquema de cifrado generalmente consta de los siguientes elementos:</p>
<ul>
<li>
<p><strong>Encryption Algorithm:</strong> vimos que es el conjunto de operaciones matem√°ticas utilizadas para cifrar los datos en texto cifrado.</p>
</li>
<li>
<p><strong>Decryption Algorithm:</strong> es el conjunto de operaciones matem√°ticas inversas utilizadas para descifrar el texto cifrado y recuperar los datos originales.</p>
</li>
<li>
<p><strong>Key:</strong> conocida como clave, es un valor secreto que se utiliza como entrada para el algoritmo de cifrado. La key determina c√≥mo se realiza la transformaci√≥n de los datos y es esencial para descifrar el texto cifrado.</p>
</li>
<li>
<p><strong>Protocols:</strong> establecen c√≥mo se utiliza el esquema de cifrado, incluyendo la generaci√≥n y distribuci√≥n segura de claves, el manejo de errores y la gesti√≥n de la seguridad.</p>
</li>
</ul>
<p>Existen varios tipos de esquemas de cifrado:</p>
<ol>
<li>
<p>El <a href="https://academy.bit2me.com/que-es-criptografia-simetrica/"><strong>cifrado sim√©trico</strong></a> (donde se utiliza una sola clave tanto para cifrar como para descifrar),</p>
</li>
<li>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_asim%C3%A9trica"><strong>cifrado asim√©trico</strong></a> o de clave p√∫blica (donde se utilizan pares de claves p√∫blica y privada)</p>
</li>
<li>
<p>Otras variantes de esquemas de cifrados como de <a href="https://es.wikipedia.org/wiki/Cifrador_de_flujo">flujo</a> y de <a href="https://es.wikipedia.org/wiki/Cifrado_por_bloques">bloque</a>. Cada esquema tiene sus propias caracter√≠sticas y se utiliza en diferentes contextos seg√∫n los requisitos de seguridad y las necesidades espec√≠ficas de la aplicaci√≥n, pero nos centraremos en las principales para entender su funcionamiento antes de pasar a la evoluci√≥n de las STARKs.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptograf√≠a-sim√©trica"><a class="header" href="#criptograf√≠a-sim√©trica">Criptograf√≠a Sim√©trica</a></h2>
<p>La historia de la criptograf√≠a sim√©trica se remonta a tiempos antiguos, pero su uso moderno se consolid√≥ en el siglo XX con el desarrollo de m√©todos m√°s sofisticados. Un ejemplo ic√≥nico es la <a href="https://en.wikipedia.org/wiki/Enigma_machine">m√°quina Enigma</a>, utilizada por los alemanes durante la Segunda Guerra Mundial para cifrar y descifrar mensajes, esta m√°quina demostr√≥ la eficacia de la criptograf√≠a sim√©trica en entornos militares.</p>
<p>Podemos ver la criptograf√≠a sim√©trica como una antigua y confiable llave maestra en el mundo de la seguridad inform√°tica. Es una t√©cnica que ha sido utilizada desde hace mucho tiempo y a√∫n en la actualidad sigue siendo efectiva y segura para proteger informaci√≥n en diversas situaciones.</p>
<p>Imag√≠nate una llave que puede tanto cerrar como abrir una puerta. Los algoritmos criptogr√°ficos de clave sim√©trica funcionan de manera similar, utilizan la misma clave para cifrar el texto original y descifrar el texto cifrado, esta clave compartida es como el secreto que solo t√∫ y los destinatarios autorizados conocen.</p>
<p><img src="./assets/simetrico.gif" alt="graph" /></p>
<div align="center">
<em>Criptograf√≠a Sim√©trica - √önica Key</em>
</div>
<p>Sin embargo, a medida que la tecnolog√≠a avanzaba y las capacidades de c√≥mputo aumentaban, se hizo evidente que era necesario fortalecer los sistemas de cifrado. Surgieron nuevos desaf√≠os y amenazas que requer√≠an niveles m√°s altos de seguridad. Es por eso que se desarrollaron otros m√©todos criptogr√°ficos, como la criptograf√≠a asim√©trica, que utiliza pares de claves diferentes para el cifrado y el descifrado.</p>
<p>Aunque la criptograf√≠a sim√©trica ha evolucionado con el tiempo, todav√≠a se utiliza ampliamente en muchos sistemas y aplicaciones. Su simplicidad y eficiencia la convierten en una opci√≥n popular para proteger datos en redes privadas, sistemas de comunicaci√≥n y almacenamiento de informaci√≥n sensible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptograf√≠a-asim√©trica"><a class="header" href="#criptograf√≠a-asim√©trica">Criptograf√≠a Asim√©trica</a></h1>
<p>Ahora hablemos como el concepto de algoritmos criptogr√°ficos de clave asim√©trica, fue un enfoque revolucionario que introdujo un concepto completamente diferente, <strong>el uso de un par de claves complementarias, una p√∫blica y una privada</strong>, para asegurar la confidencialidad de los datos. Cada clave del par ten√≠a una funci√≥n espec√≠fica:</p>
<ul>
<li><strong>Public key</strong>: esta clave p√∫blica se compart√≠a abiertamente y se utilizaba para cifrar la informaci√≥n.</li>
<li><strong>Private key:</strong> esta clave privada se guardaba cuidadosamente y se utilizaba para descifrarla.</li>
</ul>
<p>Con la criptograf√≠a de clave p√∫blica, los mensajes cifrados pod√≠an ser transmitidos a trav√©s de redes inseguras sin el temor de que fueran interceptados y descifrados por personas no autorizadas, pero en este caso diferenci√°ndose de la sim√©trica en que estos mensajes requer√≠an un Private key y una Public key. Era como si se hubiera descubierto una nueva forma de comunicaci√≥n secreta y segura en el mundo digital, fue un avance revolucionario en el campo de la criptograf√≠a.</p>
<p><img src="./assets/asimetrico.gif" alt="graph" /></p>
<div align="center">
<em>Criptograf√≠a Asim√©trica - Creaci√≥n de PK y PB</em>
</div>
<p>Algunos de los m√°s destacados y utilizados son los siguiente:</p>
<ul>
<li>
<p><strong>RSA -</strong> <a href="https://es.wikipedia.org/wiki/RSA"><strong>Rivest-Shamir-Adleman:</strong></a> es un sistema criptogr√°fico asim√©trico de clave p√∫blica desarrollado en 1979. Su seguridad radica en el problema de la factorizaci√≥n de n√∫meros enteros y se utiliza en diversos √°mbitos de la transmisi√≥n de datos en Internet debido a su facilidad de uso. Este sistema consta de una clave p√∫blica RSA y una clave privada RSA.</p>
</li>
<li>
<p><strong>ECC -</strong> <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_de_curva_el%C3%ADptica"><strong>Elliptic Curve Cryptography:</strong></a> en la d√©cada de 1980 se desarroll√≥ este enfoque de curva el√≠ptica criptogr√°fica, una variante de la criptograf√≠a asim√©trica o de clave p√∫blica basada en las matem√°ticas de las curvas el√≠pticas que proporciona niveles de seguridad similares o superiores a RSA pero con claves m√°s cortas.</p>
</li>
<li>
<p><strong>ECDSA -</strong> <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf"><strong>Elliptic Curve Digital Signature Algorithm:</strong></a> en los A√±os 1990 naci√≥ ECDSA, un algoritmo de firma digital y autenticaci√≥n en criptograf√≠a asim√©trica, basado en curvas el√≠pticas. Se utiliza en criptograf√≠a para garantizar la autenticidad, integridad de los datos. ECDSA se basa en la dificultad computacional de resolver el problema del logaritmo discreto en curvas el√≠pticas.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptograf√≠a-h√≠brida"><a class="header" href="#criptograf√≠a-h√≠brida">Criptograf√≠a H√≠brida</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_h%C3%ADbrida"><strong>cifrado h√≠brido</strong></a> utiliza las propiedades √∫nicas de la criptograf√≠a de clave p√∫blica para intercambiar informaci√≥n secreta a trav√©s de un canal no confiable, combinando la eficacia del cifrado sim√©trico. Esto proporciona una soluci√≥n pr√°ctica de extremo a extremo para garantizar la privacidad de los datos.</p>
<p>Aunque los algoritmos de clave p√∫blica, como RSA-OAEP, son menos eficientes que los algoritmos sim√©tricos, generalmente no se utilizan directamente para cifrar los datos. Sin embargo, desempe√±an un papel importante en el ecosistema criptogr√°fico al permitir el intercambio seguro de claves.</p>
<p>Para utilizar el cifrado sim√©trico, las partes deben compartir una clave. Si ya existe un canal seguro, se puede enviar la clave a trav√©s de √©l. Sin embargo, si no hay un canal seguro disponible, se resuelve el problema del intercambio de claves utilizando la criptograf√≠a de clave p√∫blica.</p>
<ul>
<li><strong>DH -</strong> <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"><strong>Diffie‚ÄìHellman:</strong></a> el intercambio de claves DH es un algoritmo criptogr√°fico de clave p√∫blica dise√±ado espec√≠ficamente para acordar una clave sim√©trica en ausencia de un canal seguro.
La combinaci√≥n de criptograf√≠a de clave p√∫blica para el intercambio de claves y el cifrado sim√©trico para el cifrado de datos en masa se conoce como cifrado h√≠brido.</li>
</ul>
<p>El cifrado h√≠brido se utiliza ampliamente en los protocolos de transferencia de datos para la web, como en la capa de seguridad de transporte <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">(TLS)</a>. Cuando te conectas a un sitio web que utiliza <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a> (HTTP seguro con TLS), tu navegador negocia los algoritmos criptogr√°ficos que aseguran la conexi√≥n. Estos algoritmos incluyen m√©todos para el intercambio de claves, cifrado sim√©trico y firmas digitales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="firmas-digitales"><a class="header" href="#firmas-digitales">Firmas digitales</a></h1>
<p>Los esquemas de firma digital son un tipo de criptograf√≠a de clave p√∫blica que garantiza la integridad, autenticidad y no repudio de los datos.</p>
<p>Es importante destacar que el esquema de firma digital puede variar dependiendo del algoritmo utilizado, ECDSA, es un ejemplo com√∫n de esquema de firma basado en criptograf√≠a de curva el√≠ptica. Aqu√≠ EC recordemos que representa la curva el√≠ptica utilizada y <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm"><strong>DSA</strong></a> (una variante de los esquemas de firma <a href="https://en.wikipedia.org/wiki/Schnorr_signature">Schnorr</a> y <a href="https://en.wikipedia.org/wiki/ElGamal_signature_scheme">ElGamal</a>) el algoritmo de firma digital. Cada esquema tiene sus propias caracter√≠sticas y propiedades de seguridad, y se selecciona seg√∫n los requisitos y consideraciones espec√≠ficas de la aplicaci√≥n.</p>
<p>Cuando se trata de firmas digitales, los pasos generales suelen ser los siguientes:</p>
<ul>
<li>
<p><strong>Key generation:</strong> el Generador de Claves es un protocolo o algoritmo que genera <strong>un Keypar</strong>, un par de claves asim√©tricas como se explic√≥ anteriormente compuestas por una public key y una private key. En el caso de la criptograf√≠a de curva el√≠ptica (como ECDSA), se generan los par√°metros necesarios para definir la curva y se elige una clave privada aleatoria. A partir de la clave privada, se calcula la clave p√∫blica correspondiente utilizando operaciones matem√°ticas espec√≠ficas.</p>
</li>
<li>
<p><strong>Hash del mensaje:</strong> antes de firmar el mensaje, se aplica una funci√≥n hash criptogr√°fica al contenido del mensaje. Esto reduce el mensaje a un valor de longitud fija llamado resumen o hash. El objetivo es garantizar la integridad y eficiencia del proceso de firma, ya que es m√°s r√°pido firmar y verificar un resumen m√°s corto que el mensaje completo.</p>
</li>
<li>
<p><strong>Digital Signature:</strong> este proceso tiene el prop√≥sito de realizar una serie de operaciones matem√°ticas utilizando la clave privada y el hash del mensaje para generar la firma digital.</p>
</li>
<li>
<p><strong>Verify Signature:</strong> para verificar la autenticidad de la firma, se necesita la clave p√∫blica del firmante. Se aplica nuevamente la funci√≥n hash al mensaje original y se utiliza la clave p√∫blica junto con la firma para realizar operaciones matem√°ticas espec√≠ficas. Si el resultado coincide con la firma original, se considera que la firma es v√°lida y se confirma la autenticidad del mensaje y del firmante.</p>
</li>
</ul>
<p>El proceso de firma puede considerarse como el cifrado del archivo mediante la clave privada. Para ello, la persona que firma utiliza su clave privada para producir una firma.</p>
<p>Exploraremos a continuaci√≥n la relevancia de los diversos esquemas de firmas para garantizar la seguridad de nuestros datos, as√≠ como la forma en que Starknet usa AA para abstraer la firma de la validaci√≥n. En este contexto, se pueden dise√±ar diferentes esquemas o configuraciones, como el <code>secp256r1</code>, una variante de STARK Curve, la versi√≥n amigable de ECDSA optimizada en Starknet. Este esquema de firma se puede utilizar para incorporar firmas en dispositivos modernos de manera biom√©trica, aislada y abstra√≠da por naturaleza, lo que mejora significativamente la eficiencia, tal como se discutir√° en detalle m√°s adelante.</p>
<p>Por lo tanto, resulta crucial abordar el siguiente apartado relacionado con el uso de Key generation que desempe√±an un papel fundamental en este contexto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-generator"><a class="header" href="#key-generator">Key generator</a></h1>
<p>Tenemos que entender c√≥mo el generador de claves <a href="https://en.wikipedia.org/wiki/Key_generator"><strong>(Key generator)</strong></a> genera el Keypair, para lograrlo, es necesario trabajar con valores pseudoaleatorios que se utilizan en la generaci√≥n de la private key. Un Key generator se puede implementar en un sistema con el prop√≥sito de generar y autenticar claves.</p>
<p>Key generator puede implementarse en cualquier sistema criptogr√°fico que utilice la curva el√≠ptica, como es el caso de <code>secp256k1</code> (una curva optimizada basada en las propiedades matem√°ticas de las curvas el√≠pticas para proporcionar un esquema de firma digital seguro y eficiente), como Bitcoin y Ethereum.</p>
<p>Este generador de claves garantiza que, con alta probabilidad, las claves privadas generadas sean √∫nicas y seguras, lo que a su vez respalda la integridad y autenticidad de las transacciones realizadas en la red.</p>
<h2 id="generadores-de-n√∫meros-pseudoaleatorios"><a class="header" href="#generadores-de-n√∫meros-pseudoaleatorios">Generadores de n√∫meros pseudoaleatorios</a></h2>
<p>Para garantizar la seguridad usando la pseudoaleatoriedad estad√≠stica de un <strong>PRNG -</strong> <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator"><strong>Pseudorandom number generator</strong></a>, es crucial contar con una semilla inicial. Si la semilla es f√°cilmente predecible, generar√° valores predecibles de n√∫meros y todo el proceso ser√° inseguro.</p>
<p>Para lograr una inicializaci√≥n segura del generador pseudoaleatorio, es necesario recolectar <a href="https://en.wikipedia.org/wiki/Entropy_(computing)"><strong>Entrop√≠a</strong></a>, que representa la aleatoriedad necesaria en el proceso.</p>
<h2 id="entrop√≠a"><a class="header" href="#entrop√≠a">Entrop√≠a</a></h2>
<p>La entrop√≠a o aleatoriedad impredecible en computaci√≥n, generalmente se mide en bits. Tenemos varios ejemplos para entender el concepto y grado de aleatoriedad. Si mueve el mouse de su computadora, generar√° algunos eventos dif√≠ciles de predecir, como la ubicaci√≥n de inicio y la ubicaci√≥n final del cursor del mouse.</p>
<blockquote>
<p>Si suponemos que el mouse ha cambiado su posici√≥n en el rango de <code>[ 0 ... 255 p√≠xeles ]</code>, la entrop√≠a recolectada de este movimiento del mouse debe ser de aproximadamente <strong>8 bits</strong>, porque <code>2‚Å∏ = 255</code></p>
</blockquote>
<blockquote>
<p>Si se le pide al usuario que piense en un n√∫mero en el rango <code>[ 0 ... 1000 ]</code>, este n√∫mero tendr√° alrededor de <strong>9-10 bits</strong> de entrop√≠a porque, <code>2¬π‚Å∞ = 1024</code></p>
</blockquote>
<p>Para recolectar 256 bits de entrop√≠a, es decir, para generar de forma segura un n√∫mero entero de 256 bits, deber√° tener en cuenta una secuencia de varios eventos similares (como movimientos del mouse e interracidades del teclado del usuario).</p>
<p>Aqu√≠ la importancia de d√≥nde y c√≥mo hemos generado nuestras claves privadas y p√∫blicas y las posibles vulnerabilidades en algunos malos usos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funciones-hash-y-funciones-hash-criptogr√°ficas"><a class="header" href="#funciones-hash-y-funciones-hash-criptogr√°ficas">Funciones hash y funciones hash criptogr√°ficas</a></h1>
<p>Este apartado es de suma importancia para comprender el funcionamiento de las funciones hash. A diferencia de los esquemas de cifrado o las firmas, las funciones hash no requieren de una clave. Cualquier persona puede calcular el hash de una entrada determinada, y la funci√≥n hash siempre producir√° la misma salida para la misma entrada.</p>
<p>As√≠ que podemos definir una <a href="https://en.wikipedia.org/wiki/Hash_function"><strong>funci√≥n hash</strong></a> como un algoritmo que toma una entrada, como un mensaje o un archivo, y produce una salida de longitud fija llamada hash o resumen. Esta salida es √∫nica para cada entrada espec√≠fica, lo que permite la verificaci√≥n de la integridad de los datos y garantiza que cualquier cambio en la entrada resultar√° en un hash completamente diferente.</p>
<p>Una <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function"><strong>funci√≥n hash criptogr√°fica</strong></a>, por otro lado, es aquella funci√≥n hash que se utiliza en el √°mbito de la criptograf√≠a, para evaluar la seguridad de una funci√≥n de hash criptogr√°fica, se consideran las siguientes propiedades:</p>
<ul>
<li><strong>Resistencia a la preimagen:</strong> partiendo de un valor <code>hash h</code>, es dif√≠cil encontrar un mensaje <code>m</code> que genere ese <code>hash</code>, es decir, <code>h = hash(m)</code>, este concepto est√° relacionado con el de una funci√≥n de sentido √∫nico. Las funciones que carecen de esta propiedad son vulnerables a ataques de preimagen.</li>
<li><strong>Resistencia a la segunda preimagen:</strong> dado un mensaje <code>m‚ÇÅ</code>, es dif√≠cil encontrar otro mensaje <code>m‚ÇÇ</code> distinto a <code>m‚ÇÅ</code> que produzca el mismo valor de hash, es decir, <code>hash(m‚ÇÅ) = hash(m‚ÇÇ)</code>. Esta propiedad tambi√©n se conoce como resistencia d√©bil a colisiones. Las funciones que no cumplen esta propiedad son vulnerables a ataques de segunda preimagen.</li>
<li><strong>Resistencia a colisiones:</strong> es dif√≠cil encontrar dos mensajes diferentes <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code> que produzcan el mismo valor de hash, es decir, <code>hash(m‚ÇÅ) = hash(m‚ÇÇ)</code>. Estas colisiones son conocidas como colisiones criptogr√°ficas de hash. Esta propiedad tambi√©n se conoce como resistencia fuerte a colisiones. Se requiere que el tama√±o del hash sea al menos el doble de largo para garantizar la resistencia a la preimagen.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-tree-en-blockchain"><a class="header" href="#merkle-tree-en-blockchain">Merkle Tree en Blockchain</a></h1>
<p>Ahora que hemos comprendido mejor qu√© es un hash, veamos c√≥mo en criptograf√≠a y <a href="https://en.wikipedia.org/wiki/Computer_science">ciencias de la computaci√≥n</a>, un √°rbol hash, tambi√©n conocido c√≥mo <a href="https://en.wikipedia.org/wiki/Merkle_tree"><strong>Merkle Tree o binary Merkle tree</strong></a>, es una <a href="https://en.wikipedia.org/wiki/Data_structure">estructura de datos</a> utilizada para garantizar la integridad de los contenidos almacenados en un sistema, como la tecnolog√≠a blockchain.</p>
<p>Podemos ver los Merkle Trees como una estructura de √°rbol en la que cada &quot;hoja&quot; o nodo terminal, est√° etiquetado con el hash criptogr√°fico de un bloque de datos. A su vez, cada nodo que no es una hoja, tambi√©n conocido como rama, nodo interior o inodo, est√° etiquetado con el hash criptogr√°fico de las etiquetas de sus nodos secundarios.</p>
<p>La construcci√≥n de un Merkle Tree implica dividir los datos en bloques m√°s peque√±os y aplicar una funci√≥n de hash criptogr√°fico a cada uno de ellos. Luego, los bloques hash se combinan en pares y se vuelven a hashear, repitiendo este proceso hasta obtener un √∫nico hash llamado ra√≠z de Merkle o ‚ÄúMerkle root‚Äù. Esta ra√≠z se coloca en la cabecera de un bloque o transacci√≥n y se utiliza como una firma digital que representa y verifica la integridad de todos los datos incluidos en el bloque.</p>
<p><img src="./assets/merkle.gif" alt="graph" /></p>
<div align="center">
<em>Ejemplo de estructura de un Merkle Tree</em>
</div>
<p>Una de las principales ventajas de los Merkle Trees es su capacidad para proporcionar una verificaci√≥n eficiente y segura de los contenidos de una gran estructura de datos. Como cada nodo intermedio en el √°rbol est√° etiquetado con el hash criptogr√°fico de las etiquetas de sus nodos secundarios, cualquier cambio realizado en los datos se reflejar√° en cambios en los hashes correspondientes.</p>
<p>En la tecnolog√≠a blockchain que usan los Merkle Trees, los utilizan para garantizar la integridad de los datos almacenados en cada bloque de la cadena. Cada bloque contiene una lista de transacciones, y el Merkle Tree se construye utilizando los hashes de estas transacciones.</p>
<p>Cuando se agrega un nuevo bloque a la cadena, la ra√≠z de Merkle del bloque anterior se incluye en el nuevo bloque, creando una cadena enlazada de √°rboles de Merkle. Esto permite verificar r√°pidamente la integridad de cualquier bloque en la cadena sin necesidad de verificar todos los datos desde el inicio. Adem√°s, si alg√∫n dato se modifica en un bloque, el hash del bloque cambiar√°, lo que afectar√° la ra√≠z de Merkle y se√±alar√° la alteraci√≥n en la cadena.</p>
<p>Algunos casos posibles de uso de los binary Merkle Trees para los diferentes esquemas pueden ser:</p>
<ul>
<li><strong>Los binary Merkle Trees:</strong> son estructuras de datos muy eficientes para autenticar informaci√≥n que se presenta en formato de &quot;lista&quot;, es decir, una secuencia de elementos consecutivos.</li>
<li><strong>Los transaction trees:</strong> tambi√©n resultan beneficiosos, ya que una vez creado el √°rbol, no importa cu√°nto tiempo se tarde en editarlo, ya que permanecer√° inmutable.</li>
<li><strong>Los State trees:</strong> sin embargo, cuando se trata de un √°rbol que almacena estados la situaci√≥n se vuelve m√°s compleja, el estado en Ethereum, que consiste en un mapa de valores clave donde:
<ul>
<li><strong>Las claves son direcciones</strong></li>
<li><strong>Los valores son las declaraciones de cuenta que incluyen:</strong> saldo, nonce, c√≥digo y almacenamiento asociados a cada cuenta, r</li>
<li><strong>Requiere la construcci√≥n de una prueba de transici√≥n de estado de Merkle</strong> <a href="https://medium.com/@chiqing/verify-ethereum-account-balance-with-state-proof-83b51ceb15cf">(Merkle state transition proof)</a></li>
</ul>
</li>
</ul>
<p>As√≠ que, comprender el funcionamiento de los State Trees y su optimizaci√≥n de datos es crucial en el contexto actual donde los datos y los hashes desempe√±an un papel fundamental. En el caso de Ethereum, uno de los principales actores en el √°mbito de los State Trees, se han incorporado modificaciones interesantes usando Patricia Merkle Trie.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patricia-merkle-trie"><a class="header" href="#patricia-merkle-trie">Patricia Merkle Trie</a></h1>
<p>La especificaci√≥n de Ethereum define el <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/"><strong>Modified Merkle Patricia Trie</strong></a> (tambi√©n conocido como MPT) este m√©todo se utiliza para guardar estados. B√°sicamente, el MPT es una combinaci√≥n del Patricia trie y el Merkle tree, con algunas optimizaciones adicionales adaptadas a las caracter√≠sticas de Ethereum.</p>
<p>Patricia trie, <a href="https://en.wikipedia.org/wiki/Radix_tree">(Radix tree o Radix trie)</a>, √°rbol de prefijos compacto <strong>(compact prefix tree)</strong> o √°rbol de prefijos comprimido <strong>(compressed trie)</strong>, es una sofisticada estructura de datos que ofrece una optimizaci√≥n espacial en la representaci√≥n de [Tries] (√°rboles de prefijos). Una de las caracter√≠sticas clave de este tipo de √°rbol es la fusi√≥n de nodos cuando un nodo es hijo √∫nico de su padre, lo que contribuye a una mayor eficiencia y rendimiento.</p>
<p>Esta estructura es un tipo de <strong>√°rbol de b√∫squeda k-ary</strong>, siendo un <a href="https://en.wikipedia.org/wiki/M-ary_tree">m-ary tree</a> (tambi√©n conocido como <code>n-ary tree</code>, <code>k-ary tree</code> o <code>k-way tree</code>) un √°rbol ra√≠z en el cual cada nodo tiene como m√°ximo m hijos. Ambas estructuras de datos se utilizan para localizar claves espec√≠ficas dentro de un conjunto.</p>
<p>Estos √°rboles son completamente deterministas, lo que significa que aquellos con las mismas asociaciones de (clave, valor) est√°n garantizados de ser id√©nticos, hasta el √∫ltimo byte. Esto asegura que tengan el mismo hash ra√≠z, lo que proporciona la deseada eficiencia de <code>O(log(n))</code> para inserciones, b√∫squedas y eliminaciones. Adem√°s, son m√°s f√°ciles de entender y programar que alternativas m√°s complejas basadas en comparaciones, como los <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree.</a></p>
<p>El Patricia Merkle Trie combina la estructura de un √°rbol de b√∫squeda binario con la estructura de √°rbol de Merkle, lo cual permite verificar eficientemente la integridad de los datos y proporciona una representaci√≥n compacta del estado completo de la cadena.</p>
<p>El uso del Patricia Merkle Trie en Ethereum ofrece ventajas significativas en t√©rminos de eficiencia y escalabilidad. Permite realizar consultas r√°pidas sobre el estado de las cuentas y los contratos, evitando la necesidad de recorrer todo el estado completo. En cambio, solo es necesario verificar y acceder a los nodos relevantes en el √°rbol, lo que ahorra tiempo y recursos.</p>
<p>Adem√°s, esta estructura de √°rbol facilita la implementaci√≥n de funciones de snapshot y revert en Ethereum. Estas funciones permiten crear instant√°neas del estado del sistema en momentos espec√≠ficos y revertir cambios en caso de errores o ataques, brindando una capa adicional de seguridad y confiabilidad a la red blockchain.</p>
<p><img src="" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>La comprensi√≥n de los Merkle Trees y el MPT resulta especialmente relevante al explorar otras estructuras de datos criptogr√°ficas, como las Merkle Mountain Ranges (MMRs) en Herodotus para las Storage Proof. Las MMRs pueden considerarse una lista de √Årboles de Merkle, donde cada √°rbol se representa como una monta√±a y la lista completa forma el rango. La utilizaci√≥n de funciones hash espec√≠ficas y sus caracter√≠sticas de seguridad se explorar√°n para comprender c√≥mo crear estos √°rboles de manera eficiente y √≥ptima.</p>
<p>Por lo tanto, es crucial comprender a fondo las diferentes funciones hash y sus propiedades para tomar decisiones informadas sobre la selecci√≥n y optimizaci√≥n de las mismas en la construcci√≥n de estructuras de datos criptogr√°ficas m√°s eficientes y seguras en los √Årboles de Merkle.</p>
<p>Las funciones hash desempe√±an un papel fundamental en garantizar la integridad y la seguridad de los datos almacenados en los √°rboles de Merkle, ya que se utilizan para calcular los hashes de los nodos y verificar su integridad durante la construcci√≥n y la verificaci√≥n del √°rbol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha-256"><a class="header" href="#sha-256">SHA-256</a></h1>
<p>Es hora de examinar algunos ejemplos de funciones hash criptogr√°ficas ampliamente utilizadas, un ejemplo es <code>SHA-256</code> <a href="https://es.wikipedia.org/wiki/SHA-2"><strong>(Secure Hash Algorithm 256-bit)</strong></a>, <strong>que es una funci√≥n de hash criptogr√°fica perteneciente a la familia de algoritmos SHA-2.</strong> Esta funci√≥n acepta una entrada de cualquier longitud y genera una salida de 256 bits que se considera √∫nica y asociada de forma irreversible a dicha entrada.</p>
<p>Pueden probar la generaci√≥n de un hash utilizando cualquier <a href="https://miniwebtool.com/es/sha256-hash-generator/">generador en l√≠nea</a>. En este caso, <a href="https://bfotool.com/category/encode-decoder">realizamos pruebas</a> utilizando la funci√≥n hash <code>SHA-256</code> y <code>keccak-256</code>, tambi√©n pueden explorar y probar <a href="https://bfotool.com/category/encode-decoder">m√°s funciones hash desde aqu√≠.</a></p>
<p>El cambio de un solo bit causa un efecto avalancha, lo que significa que incluso un cambio m√≠nimo como un <code>.</code> en la entrada, produce un cambio significativo en la salida. Puedes revisar el hash de <code>L2 en Espa√±ol</code> y <code>L2 en Espa√±ol.</code></p>
<p><img src="./assets/Sha256.png" alt="graph" /></p>
<div align="center">
<em>Salida de datos completamente diferente a√±adiendo un "."</em>
</div>
<p><code>SHA-256</code> se utiliza ampliamente en criptograf√≠a, y cuenta con diversos casos de uso destacados:</p>
<ol>
<li><strong>Verificaci√≥n de integridad:</strong> <code>SHA-256</code> se utiliza para verificar la integridad de los datos almacenados en un sistema. Al calcular el hash de un archivo o conjunto de datos, se puede comparar con el hash original para detectar cualquier cambio o alteraci√≥n en los datos.</li>
<li><strong>Firmas digitales:</strong> las firmas digitales se generan mediante algoritmos criptogr√°ficos y se basan en la funci√≥n SHA-256 para asegurar la autenticidad e integridad de los mensajes. El hash <code>SHA-256</code> se utiliza para resumir y proteger la informaci√≥n que se firma digitalmente.</li>
<li><strong>Almacenamiento seguro de contrase√±as:</strong> en lugar de almacenar contrase√±as en texto plano, los sistemas de seguridad suelen almacenar el hash <code>SHA-256</code> de las contrase√±as. Cuando un usuario ingresa su contrase√±a, se calcula el hash y se compara con el valor almacenado, lo que permite verificar la autenticidad de la contrase√±a sin almacenarla directamente.</li>
<li><strong>Generaci√≥n de claves criptogr√°ficas:</strong> <code>SHA-256</code> se utiliza en algoritmos de generaci√≥n de claves criptogr√°ficas para producir claves aleatorias y seguras.</li>
</ol>
<p>En resumen, <code>SHA-256</code> es una funci√≥n hash criptogr√°fica ampliamente utilizada que forma parte de la familia de algoritmos <code>SHA-2</code>, la hace ideal para verificar la integridad de los datos, generar firmas digitales, almacenar contrase√±as de forma segura y generar claves criptogr√°ficas. <code>SHA-256</code> ha demostrado su robustez y eficacia en numerosos casos de uso en criptograf√≠a. Ahora es el turno de explorar otra funci√≥n hash criptogr√°fica m√°s moderna llamada Keccak.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak---el-nuevo-sha-3"><a class="header" href="#keccak---el-nuevo-sha-3">Keccak - El nuevo SHA-3</a></h1>
<p>Ahora nos centraremos en el <code>SHA-3</code> <a href="https://en.wikipedia.org/wiki/SHA-3"><strong>(Secure Hash Algorithm 3)</strong></a>, es un est√°ndar de funci√≥n hash criptogr√°fica dise√±ado por los cript√≥grafos Joan Daemen y Gilles Van Assche. El algoritmo utilizado en <code>SHA-3</code> se llama <a href="https://keccak.team/index.html"><strong>Keccak</strong></a>, el cual fue <a href="https://www.federalregister.gov/documents/2015/08/05/2015-19181/announcing-approval-of-federal-information-processing-standard-fips-202-sha-3-standard"><strong>seleccionado como el ganador del concurso</strong></a> organizado por el Instituto Nacional de Est√°ndares y Tecnolog√≠a <a href="https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology">(NIST)</a> para encontrar un nuevo est√°ndar de funci√≥n hash criptogr√°fica.</p>
<p>A diferencia de <code>SHA-256</code>, <code>Keccak</code> utiliza una estructura y operaciones diferentes. En lugar de rondas, <code>Keccak</code> se basa en una construcci√≥n llamada funci√≥n de esponja <a href="https://en.wikipedia.org/wiki/Sponge_function">(Sponge function)</a>, que se basa en una funci√≥n pseudoaleatoria amplia o <a href="https://keccak.team/glossary.html#permutation">(permutation)</a> pseudoaleatorio permitiendo ingresar <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<p><code>Keccak-256</code> es una funci√≥n hash criptogr√°fica utilizada en Ethereum. Pertenece a la familia de algoritmos <code>SHA-3</code> y se emplea ampliamente en la plataforma Ethereum para diversos prop√≥sitos.</p>
<p>Algunos casos de uso de <code>Keccak-256</code> incluyen:</p>
<ul>
<li>Ethereum utiliza <code>Keccak-256</code> para garantizar la integridad de los datos y generar identificadores √∫nicos (hash) para verificar la autenticidad de los archivos y mensajes en sistemas criptogr√°ficos.</li>
<li>Tambi√©n se utiliza en la firma criptogr√°fica de peque√±o tama√±o, donde en lugar de firmar la entrada completa, se firma el hash <code>Keccak-256</code> del mensaje o dato.</li>
<li><code>Keccak-256</code> es utilizado para obtener una identificaci√≥n √∫nica y determinista de una colecci√≥n de datos. Por ejemplo, en Ethereum, las direcciones de Ethereum se derivan de claves p√∫blicas o contratos utilizando la funci√≥n hash unidireccional <code>Keccak-256</code>.</li>
</ul>
<p>Las direcciones Ethereum son n√∫meros hexadecimales, identificadores derivados de los √∫ltimos 20 bytes del hash <code>Keccak-256</code> de la clave p√∫blica.</p>
<p>A diferencia de las direcciones de Bitcoin, que est√°n codificadas en la interfaz de usuario de todos los clientes para incluir una suma de verificaci√≥n incorporada para proteger contra direcciones mal escritas, las direcciones de Ethereum se presentan como hexadecimales sin ninguna suma de verificaci√≥n.</p>
<p><img src="./assets/Keccak.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El algoritmo <strong>Keccak</strong> utiliza la <a href="https://keccak.team/glossary.html#sponge_construction"><strong>Sponge construction</strong></a> para procesar los datos de entrada de longitud variable para generar una salida de longitud variable. Esta construcci√≥n se basa en una funci√≥n interna llamada <code>&quot;F&quot;</code> que opera en un n√∫mero fijo de bits, denotado como <code>&quot;width&quot;</code> <a href="https://keccak.team/glossary.html#width">(anchura)</a>.</p>
<p>La anchura total del algoritmo Keccak se determina sumando dos componentes, el valor de <code>&quot;r&quot;</code> <a href="https://keccak.team/glossary.html#rate">(rate)</a> y el valor de <code>&quot;c&quot;</code> <a href="https://keccak.team/glossary.html#capacity">(capacity)</a>, donde <code>b = r + c</code>.</p>
<ul>
<li>El valor de <code>&quot;r&quot;</code> representa la cantidad de bits absorbidos en cada paso de la funci√≥n esponja, es decir, <strong>la capacidad de absorci√≥n de la esponja.</strong> Un valor de <code>&quot;r&quot;</code> m√°s grande permite procesar m√°s informaci√≥n en cada paso, lo que reduce la cantidad de pasos necesarios para procesar una entrada espec√≠fica.</li>
<li>El valor de <code>&quot;c&quot;</code> representa la capacidad de la esponja, es decir, <strong>la cantidad de bits que se mantienen en el estado interno del algoritmo despu√©s de cada paso de absorci√≥n</strong>. Estos bits se mezclan con los datos de entrada y el resultado de la funci√≥n interna <code>&quot;F&quot;</code>. La capacidad afecta la resistencia del algoritmo a ataques criptogr√°ficos como colisiones o preimagen.</li>
</ul>
<p>La suma de <code>&quot;r&quot;</code> y <code>&quot;c&quot;</code> da como resultado el n√∫mero total de bits, <code>&quot;b&quot;</code>, utilizados en la funci√≥n esponja de Keccak. Este valor determina la longitud del estado interno y, por lo tanto, la longitud de la salida generada por el algoritmo.</p>
<h2 id="funcionamiento-keccak"><a class="header" href="#funcionamiento-keccak">Funcionamiento keccak</a></h2>
<p>El algoritmo funciona de la siguiente manera, inicialmente la cadena de entrada se rellena con bits adicionales para enmascarar el mensaje inicial y se divide en bloques de longitud <code>&quot;r&quot;</code> bits. Luego, los <code>&quot;b&quot;</code> bits de estado se inicializan a <code>0</code>, que da inicio a la <strong>Sponge construction</strong> en dos fases <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<ul>
<li><strong>Fase Absorbing:</strong> a los bloques de entrada de longitud <code>r-bits</code> se les aplica un <a href="https://en.wikipedia.org/wiki/XOR_cipher">XOR</a> (toma dos bits y devuelve un resultado que es 1 si solo uno de los bits es 1, y 0 en caso contrario) a los primeros <code>r</code> bits del estado, altern√°ndose con la funci√≥n <code>f</code>. Cuando todos los bloques han sido procesados, se pasa a la siguiente fase.</li>
<li><strong>Fase Squeezing:</strong> los primeros <code>r</code> bits del estado son devueltos como bloques de salida, altern√°ndose con ejecuciones de la funci√≥n <code>f</code>. El n√∫mero de bloques de salida es seleccionado por el usuario.</li>
</ul>
<p>A continuaci√≥n os dejamos una tabla que enumeran algunas de las diferencias entre <code>SHA-256</code> y <code>Keccak-256</code>.</p>
<p><img src="./assets/Comparativa_Sha_keccak.png" alt="graph" /></p>
<div align="center">
<em>Algunas diferencias entre SHA-256 y Keccak-256</em>
</div>
<p>Vemos c√≥mo cada tipo de criptograf√≠a o funci√≥n hash tiene caracter√≠sticas distintas. En el contexto actual de la computaci√≥n cu√°ntica en constante evoluci√≥n, es crucial abordar las preocupaciones emergentes sobre seguridad. Algunos algoritmos criptogr√°ficos podr√≠an ser vulnerables a los ataques cu√°nticos en un futuro cercano. Es en este punto donde entra en juego el concepto de criptograf√≠a <a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography">Post-Quantum</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantum-secure"><a class="header" href="#quantum-secure">Quantum Secure</a></h1>
<p>As√≠ que es hora de aprovechar lo que hemos aprendido y explorar lo que podr√≠a suceder en un escenario te√≥rico apocal√≠ptico. Pero antes comencemos con una breve descripci√≥n sobre <a href="https://es.wikipedia.org/wiki/Computaci%C3%B3n_cu%C3%A1ntica">computaci√≥n cu√°ntica</a> para sumergirnos en el tema. <strong>No es m√°s que un modelo de computaci√≥n basado en la</strong> <a href="https://es.wikipedia.org/wiki/Mec%C3%A1nica_cu%C3%A1ntica"><strong>f√≠sica cu√°ntica</strong></a>, que funciona de manera diferente a las computadoras cl√°sicas (el tipo de computadoras que usamos habitualmente) y tiene la capacidad de realizar tareas que estas √∫ltimas no pueden, como romper ciertos algoritmos de manera eficiente.</p>
<blockquote>
<p><strong>¬°As√≠ que espera un momento!</strong> Antes de que tu imaginaci√≥n se desborde y te veas rodeado de supercomputadoras cu√°nticas capaces de solucionar todos nuestros problemas, d√©jame contarte una peque√±a an√©cdota.</p>
</blockquote>
<blockquote>
<p><em>Ah, las computadoras cu√°nticas, esas criaturas de la f√≠sica cu√°ntica que nos hacen so√±ar con un futuro lleno de posibilidades. Pero, ¬øsab√≠as que no son m√°quinas m√°gicas capaces de resolver todos nuestros problemas inform√°ticos en un abrir y cerrar de ojos?</em></p>
</blockquote>
<blockquote>
<p><strong>Imagina esto:</strong> las computadoras cu√°nticas son como esas personas brillantes que son s√∫per eficientes en ciertas tareas, pero bastante d√©biles en otras. Son como el genio matem√°tico que resuelve complicados problemas de c√°lculo en segundos, pero se le olvida c√≥mo atarse los zapatos.</p>
</blockquote>
<blockquote>
<p><em>Entonces, s√≠, las computadoras cu√°nticas pueden ser incre√≠blemente poderosas cuando se trata de ciertos problemas espec√≠ficos, como el factorizar n√∫meros grandes o buscar en enormes bases de datos. Pero cuando se trata de tareas cotidianas, como revisar correos electr√≥nicos o navegar por la web, bueno, digamos que son como un caracol tratando de correr una marat√≥n.</em></p>
</blockquote>
<p>Despu√©s de esta peque√±a relato, es importante comprender el concepto de criptograf√≠a post-cu√°ntica <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>(PQC)</strong></a>, tambi√©n conocida como <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>Resistente a la Computaci√≥n Cu√°ntica</strong></a>, se refiere a algoritmos criptogr√°ficos especialmente algoritmos de clave p√∫blica, que se consideran seguros contra los ataques criptoanal√≠ticos llevados a cabo por computadoras cu√°nticas.</p>
<p>A medida que avanza la computaci√≥n cu√°ntica, se espera que algunos algoritmos y t√©cnicas criptogr√°ficas tradicionales utilizadas en los sistemas de seguridad actuales sean vulnerables a los ataques cu√°nticos. Esto se debe a la capacidad de las computadoras cu√°nticas para realizar c√°lculos a una escala exponencialmente mayor que las computadoras cl√°sicas, lo que podr√≠a comprometer la seguridad de los sistemas criptogr√°ficos actuales.</p>
<p>Es bien sabido en inform√°tica que las computadoras cu√°nticas podr√°n romper algunos algoritmos criptogr√°ficos, especialmente los criptosistemas de clave p√∫blica como <strong>RSA</strong>, el intercambio de llaves <strong>Diffie‚ÄìHellman</strong> y <strong>ECDSA</strong>, que dependen del <a href="https://es.wikipedia.org/wiki/Factorizaci%C3%B3n_de_enteros"><strong>IFP</strong></a> (problema de factorizaci√≥n en n√∫meros primos), el <a href="https://es.wikipedia.org/wiki/Logaritmo_discreto"><strong>DLP</strong></a> (problema del logaritmo discreto) y el ECDLP (problema del logaritmo discreto de curva el√≠ptica). Todos estos problemas podr√≠an resolverse f√°cilmente en una computadora cu√°ntica suficientemente poderosa que ejecute el algoritmo de Shor.</p>
<p>Pero los algoritmos cu√°nticos no significar√°n el fin de la criptograf√≠a, porque:</p>
<ul>
<li>Solo algunos criptosistemas son inseguros frente a la computaci√≥n cu√°ntica (como RSA, DHKE, ECDSA y ECDH).</li>
<li>Algunos criptosistemas son seguros frente a la computaci√≥n cu√°ntica y solo se ver√°n ligeramente afectados (como los hash criptogr√°ficos, algoritmos <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_de_autenticaci%C3%B3n_de_mensaje">MAC</a> y cifrados de clave sim√©trica como <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard?wprov=srpw1_0">AES</a>, siempre que se utilicen tama√±os de clave suficientemente grandes).</li>
</ul>
<p>A diferencia de la amenaza que representa la computaci√≥n cu√°ntica para los algoritmos de clave p√∫blica actuales, <strong>la mayor√≠a de los algoritmos criptogr√°ficos sim√©tricos y las funciones hash actuales se consideran relativamente seguros contra ataques de computadoras cu√°nticas.</strong> Si bien el algoritmo cu√°ntico de Grover acelera los ataques contra los cifrados sim√©tricos, duplicar el tama√±o de la clave puede bloquear eficazmente estos ataques. Por lo tanto, la criptograf√≠a sim√©trica post-cu√°ntica no necesita diferir significativamente de la criptograf√≠a sim√©trica actual.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-grover-y-la-b√∫squeda-no-estructurada"><a class="header" href="#el-algoritmo-de-grover-y-la-b√∫squeda-no-estructurada">El algoritmo de Grover y la b√∫squeda no estructurada</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Algoritmo_de_Grover">algoritmo de Grover</a> es un <a href="https://es.wikipedia.org/wiki/Algoritmo_cu%C3%A1ntico">algortimo cu√°ntico</a> para la b√∫squeda en una secuencia no ordenada de datos con <code>N</code> componentes en un tiempo <a href="https://es.wikipedia.org/wiki/Cota_superior_asint%C3%B3tica">O</a>(N¬π/‚ÇÇ), y con una necesidad adicional de espacio de almacenamiento de <code>O(logN)</code>. Fue inventado por Lov K. Grover en <a href="https://es.wikipedia.org/wiki/1996">1996</a>.</p>
<p>Aunque el algoritmo de Grover es eficiente, su paralelizaci√≥n √≥ptima resulta complicada y no se espera que las computadoras cu√°nticas actuales tengan suficiente potencia para comprometer la seguridad de esquemas como ECDSA o de funciones de hash como SHA256.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-shor-te√≥rico-y-su-impacto-en-ecdsa"><a class="header" href="#el-algoritmo-de-shor-te√≥rico-y-su-impacto-en-ecdsa">El algoritmo de Shor te√≥rico y su impacto en ECDSA</a></h1>
<p>El <a href="https://en.wikipedia.org/wiki/Shor&#x27;s_algorithm"><strong>algoritmo de Shor</strong></a> es un algoritmo cu√°ntico desarrollado por Peter Shor en 1994. Este algoritmo es conocido por su capacidad para factorizar grandes n√∫meros enteros de manera mucho m√°s eficiente que los algoritmos cl√°sicos conocidos, lo que tiene implicaciones importantes para la seguridad de algunos sistemas criptogr√°ficos basados en la factorizaci√≥n de n√∫meros enteros.</p>
<p>En el contexto de sistemas centralizados, como los sistemas bancarios, ECDSA se utiliza para garantizar la autenticidad de las transacciones, proteger la confidencialidad de la informaci√≥n y asegurar la integridad de los datos. En el √°mbito de Bitcoin y Ethereum, si bien los algoritmos de b√∫squeda cu√°ntica, como el algoritmo de Shor, podr√≠an eventualmente romper la ECDSA, es importante destacar que estos algoritmos a√∫n est√°n en una etapa te√≥rica.</p>
<p>Cada implementaci√≥n de algoritmos o protocolos puede ser diversa, ya sea privada o abstracta. Nos hemos centrado en los principios b√°sicos comunes de ECDSA, adem√°s se espera que la implementaci√≥n pr√°ctica de algoritmos de b√∫squeda cu√°ntica sea un desaf√≠o t√©cnico debido a los requisitos de recursos y la necesidad de superar errores cu√°nticos.</p>
<p>Aqu√≠ tienes una descripci√≥n general de en qu√© consisten algunos problemas que se consideran complejos de resolver mediante la computaci√≥n cl√°sica.</p>
<h2 id="ifp"><a class="header" href="#ifp">IFP</a></h2>
<p>El IFP se refiere al desaf√≠o de descomponer un n√∫mero entero grande en sus factores primos. En el caso de n√∫meros peque√±os, esto puede hacerse f√°cilmente mediante el uso de algoritmos como <a href="https://yosoytuprofe.20minutos.es/2022/11/09/que-es-la-criba-de-eratostenes-y-cual-es-su-importancia-en-las-matematicas/">el cribado de Erat√≥stenes</a> o <a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm_for_logarithms">el algoritmo de factorizaci√≥n de Pollard</a>.</p>
<p>A modo de ejemplo simplificado, supongamos que queremos factorizar el n√∫mero compuesto <code>N = 35</code> utilizando el algoritmo de Shor. Despu√©s de aplicar el algoritmo, encontrar√≠amos que los factores primos de <code>N</code> son <code>5 y 7</code>.</p>
<p>Sin embargo, a medida que los n√∫meros crecen en tama√±o, el IFP se vuelve cada vez m√°s dif√≠cil de resolver. De hecho, la seguridad de muchos sistemas criptogr√°ficos se basa en la dificultad de factorizar n√∫meros grandes en tiempo razonable, como el popular algoritmo RSA.</p>
<h2 id="dlp"><a class="header" href="#dlp">DLP</a></h2>
<p>Por otro lado, el DLP implica encontrar el exponente desconocido de una potencia modular dada. En t√©rminos m√°s sencillos, se trata de resolver la ecuaci√≥n <code>(y = gÀ£ mod p)</code> para el exponente desconocido <code>(x)</code>, donde <code>(g)</code> y <code>(p)</code> son n√∫meros conocidos e <code>(y)</code> es el resultado de la operaci√≥n de potenciaci√≥n modular. Para valores peque√±os de <code>(p)</code>, el DLP puede resolverse mediante la aplicaci√≥n de m√©todos exhaustivos como la prueba y error.</p>
<p>A modo de ejemplo simplificado, ser√≠a encontrar el logaritmo discreto de <code>base 2</code> para el n√∫mero <code>5</code> <code>m√≥dulo 11</code>. Esto implica encontrar el valor de <code>x</code> en la ecuaci√≥n <code>2À£ ‚â° 5 (mod 11).</code></p>
<p>Realizando los c√°lculos paso a paso:</p>
<ul>
<li>2¬π ‚â° 2 (mod 11)</li>
<li>2¬≤ ‚â° 4 (mod 11)</li>
<li>2¬≥ ‚â° 8 (mod 11)</li>
<li>2‚Å¥ ‚â° 5 (mod 11)</li>
</ul>
<p>Entonces, el valor de <code>x</code> que satisface la ecuaci√≥n <code>2À£ ‚â° 5 (mod 11)</code> es <code>x = 4</code>.</p>
<h2 id="ecdlp"><a class="header" href="#ecdlp">ECDLP</a></h2>
<p>La seguridad de esquemas criptogr√°ficos basados en <strong>ECC</strong>, como <strong>ECDSA</strong>, se basa en la dificultad de resoluci√≥n del problema del logaritmo discreto de curva el√≠ptica o <strong>ECDLP</strong>. Las curvas el√≠pticas son objetos matem√°ticos utilizados en criptograf√≠a de clave p√∫blica, y el <strong>ECDLP</strong> ser√≠a el problema de hallar el valor de <code>‚ÄòK‚Äô</code> en esta ecuaci√≥n, <code>P =k‚ãÖG</code>, donde <code>P</code> es un punto en la curva, <code>k</code> es el valor que debemos hallar y <code>G</code> es un punto base conocido (el generador).</p>
<p>Al igual que en el caso del <strong>DLP</strong>, el <strong>ECDLP</strong> se vuelve m√°s dif√≠cil de resolver a medida que el tama√±o de los n√∫meros involucrados en esas expresiones matem√°ticas aumentan</p>
<h2 id="ecdsa"><a class="header" href="#ecdsa">ECDSA</a></h2>
<p>Por √∫ltimo llegamos a un algoritmo ampliamente utilizado y conocido como es el <strong>ECDSA</strong>, que se utiliza com√∫nmente en blockchain. La clave p√∫blica se obtiene multiplicando un punto base conocido (llamado generador) en la curva el√≠ptica por un entero, que representa la llave privada. El desaf√≠o radica en encontrar ese valor privado a partir del punto p√∫blico conocido en la curva.</p>
<p>La curva el√≠ptica <strong>secp256k1</strong> est√° definida por la ecuaci√≥n: <code>y¬≤ = x¬≥ + ax + b</code> sobre <code>ùîΩp</code> donde <code>p</code> es un n√∫mero primo grande.</p>
<p>El algoritmo de Shor, en su versi√≥n completa y ejecutado en un computador cu√°ntico lo suficientemente grande y estable, podr√≠a factorizar el n√∫mero primo <code>p</code> en esta ecuaci√≥n, lo que proporcionar√≠a informaci√≥n sobre el orden del subgrupo c√≠clico relacionado con la curva.</p>
<p>Si se pudiera determinar el orden del subgrupo c√≠clico relacionado con la curva <code>secp256k1</code> utilizando el algoritmo de <strong>Shor</strong>, ser√≠a posible encontrar el valor privado a partir de la clave p√∫blica. Esto comprometer√≠a la seguridad de <strong>ECDSA</strong>, ya que la clave privada es fundamental para generar firmas digitales y autenticar transacciones. Es importante destacar que el algoritmo de Shor plantea un desaf√≠o para los sistemas criptogr√°ficos actuales basados en la factorizaci√≥n de n√∫meros enteros o en el logaritmo discreto, como <strong>RSA</strong> y <strong>ECDSA</strong>.</p>
<p>No obstante, la implementaci√≥n pr√°ctica de un algoritmo cu√°ntico capaz de realizar estos c√°lculos, como los mencionados ejemplos, todav√≠a se encuentra en desarrollo y no representa una amenaza inmediata para los sistemas criptogr√°ficos utilizados en la actualidad. La investigaci√≥n y el desarrollo continuo en criptograf√≠a pos-cu√°ntica son fundamentales para garantizar la seguridad en un entorno tecnol√≥gico en constante evoluci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptograf√≠a-basada-en-lattice-previene-shor"><a class="header" href="#criptograf√≠a-basada-en-lattice-previene-shor">Criptograf√≠a basada en Lattice previene Shor</a></h2>
<p>Ahora deberemos aprender c√≥mo una verificaci√≥n de esquemas de firmas puede ser lo suficientemente fuerte para prevenirnos contra un posible ataque ejecutado con el algoritmo de Shor, la criptograf√≠a basada en ret√≠culos <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_basada_en_ret%C3%ADculos"><strong>(Lattice)</strong></a>, es una forma segura de protegerse frente a muchos algoritmos.</p>
<p>Pensemos en un <a href="https://es.wikipedia.org/wiki/Red_(grupo)">ret√≠culo</a>, como una estructura matem√°tica que se forma mediante una red de puntos en un espacio n-dimensional. Es similar a una cuadr√≠cula o una rejilla en dos dimensiones, pero se extiende a cualquier n√∫mero de dimensiones. Cada punto en el ret√≠culo est√° ubicado en una posici√≥n determinada y est√° conectado a los puntos vecinos por l√≠neas rectas de igual longitud.</p>
<p>En el contexto de la criptograf√≠a basada en ret√≠culos, se utilizan ret√≠culos en <a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_n%C3%BAmeros">teor√≠a de n√∫meros</a> para construir sistemas criptogr√°ficos. Estos ret√≠culos se definen mediante un conjunto de vectores base, que son combinaciones lineales de vectores de coordenadas con coeficientes enteros. Los ret√≠culos tienen propiedades matem√°ticas interesantes, como la propiedad de ser densos y uniformes en el espacio.</p>
<p>Los problemas computacionales basados en ret√≠culos, como el problema de la aproximaci√≥n m√°s cercana en ret√≠culos o el problema del vector corto m√°s cercano, se utilizan en criptograf√≠a para establecer la seguridad de los esquemas basados en ret√≠culos. Estos problemas son dif√≠ciles de resolver y se cree que no existen algoritmos eficientes para resolverlos en el caso general, lo que brinda seguridad a los sistemas criptogr√°ficos basados en ret√≠culos.</p>
<p>La criptograf√≠a basada en ret√≠culos es el t√©rmino gen√©rico para las construcciones de primitivas criptogr√°ficas que involucran ret√≠culos, ya sea en la construcci√≥n misma o en la prueba de seguridad.</p>
<p><strong>Las construcciones basadas en ret√≠culos son actualmente candidatas importantes para la criptograf√≠a post-cu√°ntica.</strong> A diferencia de los esquemas de clave p√∫blica m√°s ampliamente utilizados y conocidos, como RSA, Diffie-Hellman o los criptosistemas de curva el√≠ptica, que te√≥ricamente podr√≠an ser derrotados utilizando el algoritmo de Shor en un computador cu√°ntico, algunas construcciones basadas en ret√≠culos parecen ser resistentes a los ataques tanto de computadoras cl√°sicas como cu√°nticas. Adem√°s, muchas construcciones basadas en ret√≠culos se consideran seguras bajo la suposici√≥n de que ciertos problemas computacionales bien estudiados en ret√≠culos no pueden ser resueltos.</p>
<p>Aqu√≠ hay una breve explicaci√≥n de las diferencias entre los esquemas de criptograf√≠a basados en ret√≠culos en t√©rminos de encriptaci√≥n, funciones hash y intercambio de claves:</p>
<ol>
<li><strong>Encriptaci√≥n basada en ret√≠culos:</strong> los esquemas de encriptaci√≥n basados en ret√≠culos aprovechan las propiedades matem√°ticas de los ret√≠culos para proporcionar seguridad en la comunicaci√≥n.</li>
<li><strong>Funciones hash basadas en ret√≠culos:</strong> las funciones hash basadas en ret√≠culos utilizan ret√≠culos y operaciones matem√°ticas relacionadas para calcular los hashes y se utilizan en diversas aplicaciones criptogr√°ficas, como la integridad de datos y la firma digital.</li>
<li><strong>Intercambio de claves basado en ret√≠culos:</strong> el intercambio de claves basado en ret√≠culos como el <a href="https://newhopecrypto.org/">(Intercambio NewHope Protocol)</a> implica el establecimiento de una clave compartida entre dos o m√°s partes que desean comunicarse de manera segura. Los protocolos de intercambio de claves basados en ret√≠culos utilizan los ret√≠culos y los problemas computacionales relacionados con ellos para garantizar que las partes puedan acordar una clave sin que un tercero pueda determinarla. Estos esquemas se basan en la dificultad de resolver ciertos problemas matem√°ticos relacionados con los ret√≠culos para asegurar la confidencialidad de la clave compartida.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kyber-crystal"><a class="header" href="#kyber-crystal">Kyber Crystal</a></h1>
<p>En el √∫ltimo estudio post-quantum veremos <a href="https://pq-crystals.org/kyber/resources.shtml"><strong>Kyber</strong></a>, antes de entrar dentro del ecosistema de Starkware y aprender c√≥mo se generan los contratos de cuentas, as√≠ como las caracter√≠sticas criptogr√°ficas y matem√°ticas detr√°s de las STARKs.</p>
<p>Kyber es un m√©todo de encapsulaci√≥n de clave <a href="https://en.wikipedia.org/wiki/Key_encapsulation">(KEM)</a> dise√±ado para resistir ataques criptoanal√≠ticos realizados por futuras computadoras cu√°nticas poderosas. Se utiliza para establecer un secreto compartido entre dos partes que se comunican, sin que un atacante <a href="https://en.wikipedia.org/wiki/Ciphertext_indistinguishability">(IND-CCA2)</a> en el sistema de transmisi√≥n pueda descifrarlo. Este criptosistema asim√©trico utiliza una variante del problema de redes de aprendizaje con errores <a href="https://en.wikipedia.org/wiki/Learning_with_errors">(learning with errors, LWE)</a> como su <a href="https://en.wikipedia.org/wiki/Trapdoor_function">funci√≥n b√°sica con trampa</a>. Gan√≥ la competencia del NIST para el primer est√°ndar de criptograf√≠a PQ.</p>
<p>La generaci√≥n de claves en Kyber no se basa en la factorizaci√≥n de enteros o en problemas relacionados con las curvas el√≠pticas, sino que utiliza el problema de aprendizaje con errores en ret√≠culos como base para la seguridad del algoritmo.</p>
<p>El sistema se basa en el aprendizaje con errores en m√≥dulos (M-LWE) del campo del aprendizaje autom√°tico, en conjunto con anillos ciclot√≥micos. Recientemente, tambi√©n se ha logrado una reducci√≥n formal matem√°tica estrecha de la problem√°tica del anillo LWE al MLWE. <strong>En comparaci√≥n con otros m√©todos de criptograf√≠a post-cu√°ntica, tiene las ventajas t√≠picas de los m√©todos basados en ret√≠culos, como el tiempo de ejecuci√≥n, el tama√±o de los textos cifrados y el material clave.</strong></p>
<p>En cuanto a los par√°metros, Kyber proporciona diferentes conjuntos para alcanzar diferentes niveles de seguridad. Por ejemplo, <code>Kyber-512</code> tiene una seguridad aproximada equivalente a <code>AES-128</code>, <code>Kyber-768</code> tiene una seguridad aproximada equivalente a <code>AES-192</code> y <code>Kyber-1024</code> tiene una seguridad aproximada equivalente a <code>AES-256</code>.</p>
<p>En resumen, Kyber utiliza un enfoque matem√°tico diferente a ECDSA en la generaci√≥n de claves. Se basa en el problema de aprendizaje con errores en ret√≠culos y en la selecci√≥n adecuada de par√°metros de seguridad. La seguridad de Kyber radica en la dificultad de resolver problemas criptogr√°ficos espec√≠ficos asociados a ese enfoque matem√°tico.</p>
<p>Con esto hemos concluido las bases criptogr√°ficas que nos han brindado los detalles de c√≥mo se generan los distintos tipos de criptograf√≠a sim√©trica o asim√©trica, as√≠ como las funciones hash y su importancia en la seguridad. Nos adentramos en c√≥mo se integraban en los Merkle Tree o Patricia Trie, para luego explorar el √°mbito de la computaci√≥n cu√°ntica y ver c√≥mo se pod√≠an resolver algunos de los problemas planteados por ciertas criptograf√≠as. Tambi√©n destacamos la importancia de las firmas y las verificaciones de firmas en los avances de la tecnolog√≠a de la computaci√≥n cu√°ntica.</p>
<p>La computaci√≥n cu√°ntica se mostr√≥ resistente a las bases sim√©tricas de una llave maestra o a las funciones hash en s√≠. Adem√°s, presenciamos avances en la prevenci√≥n de ataques cu√°nticos y en algoritmos cu√°nticos como Lattice o encapsulamientos por Kyber. Con estos avances en mente, es hora de pasar a ver las EOA (Externally Owned Accounts) y los firmantes en Ethereum, para luego diferenciarlos de la Account Abstraction nativa en Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eoa-y-aa---firmantes"><a class="header" href="#eoa-y-aa---firmantes">EOA y AA - Firmantes</a></h1>
<p>Las cuentas de EOA <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>(Externally Owned Accounts)</strong></a> en Ethereum, al igual que muchas otras criptomonedas, utilizan el algoritmo ECDSA que aprendimos antes para generar claves y firmar transacciones digitalmente. Esto les permite participar de manera segura en la red y realizar operaciones. Las EOA son cuentas que pertenecen a usuarios externos a la cadena de bloques.</p>
<p>En Ethereum, el estado de una cuenta solo puede ser modificado a trav√©s de transacciones, las cuales deben ser iniciadas por una EOA. sin embargo, no cualquier persona puede activar una transacci√≥n desde cualquier EOA, aqu√≠ es donde entra en juego el concepto de firmante.</p>
<p>Cada cuenta en Ethereum est√° asociada con un objeto criptogr√°fico llamado firmante o keypair como aprendimos antes.</p>
<p>La clave privada, tambi√©n conocida como secreto, se utiliza para firmar mensajes digitales, mientras que la clave p√∫blica permite que cualquiera pueda verificar que una firma en particular fue generada por la clave privada correspondiente.</p>
<p>La asociaci√≥n entre una cuenta y un firmante se realiza mediante la direcci√≥n de la cuenta. La direcci√≥n de un EOA se deriva de la clave p√∫blica del firmante, espec√≠ficamente, <strong>la direcci√≥n se obtiene tomando los √∫ltimos 20 bytes del hash Keccak-256 de la clave p√∫blica.</strong></p>
<p>El propietario de una cuenta puede autorizar una transacci√≥n desde su cuenta firmando los par√°metros de la transacci√≥n con la clave privada correspondiente.</p>
<p>La <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>curva el√≠ptica secp256k1</strong></a> es una de las curvas el√≠pticas m√°s utilizadas en criptograf√≠a, especialmente en el contexto de las criptomonedas como Bitcoin o Ethereum. Se basa en las propiedades matem√°ticas de las curvas el√≠pticas para proporcionar un esquema de firma digital seguro y eficiente, el uso de la curva el√≠ptica <code>secp256k1</code> garantiza la seguridad y la integridad de las transacciones al asegurar la autenticidad de las claves y las firmas digitales asociadas a ellas.</p>
<p>La abstracci√≥n de firma y clave privada es una propiedad presente en algunos sistemas criptogr√°ficos, como ciertos esquemas de firmas digitales basados en identidad. Sin embargo, en el caso del algoritmo ECDSA utilizado en Ethereum y muchas otras blockchain, la firma est√° inherentemente vinculada a la clave privada de la cuenta y no es posible separarlas o abstraerlas, como podr√≠a ser el caso en otros esquemas dise√±ados con estos principios.</p>
<p>Ahora que ya hemos adquirido los conceptos b√°sicos y hemos prestado atenci√≥n para adquirir la formaci√≥n adecuada y avanzada, podemos sumergirnos en el apasionante ecosistema de StarkWare, Starknet, StarkEx y STARKs. Nuestra mente est√° mejor preparada para embarcarnos en el viaje que nos espera en el resto del documento y en las futuras series.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starknet-aa"><a class="header" href="#starknet-aa">Starknet AA</a></h2>
<p>Esperamos que haya disfrutado de la primera parte, donde se presentaron conceptos generales de criptograf√≠a. Ahora nos adentraremos en un tema a√∫n m√°s interesante, <a href="https://www.starknet.io/en"><strong>Starknet</strong></a> y c√≥mo mejora el ecosistema, exploraremos c√≥mo los contratos de cuentas (CA) y el esquema de firmas abstra√≠das de Starknet ofrecen beneficios significativos frente al <a href="https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a">ERC-4337</a>.</p>
<p><em>Si deseas aprender m√°s sobre el concepto y las variantes del ERC-4337, te recomendamos leer esta serie de art√≠culos en el blog de <a href="https://www.argent.xyz/argent-x/">Argent</a>. La serie est√° compuesta por la <a href="https://www.argent.xyz/blog/wtf-is-account-abstraction/">Parte 1</a>, <a href="https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/">Parte 2</a> y <a href="https://www.argent.xyz/blog/part-3-wtf-is-account-abstraction/">Parte 3</a>. Argent y <a href="https://braavos.app/">Braavos</a> son Smart wallets que aprovechan el poder del AA nativo en Starknet. Tambi√©n te recomendamos leer los art√≠culos de Braavos de <a href="https://braavos.app/account-abstraction-ethereum-comprehensive-guide/">Guide 101 AA</a> y <a href="https://braavos.app/account-abstraction-security-pyramid/">Security Pyramid AA</a>, los cuales presentan optimizaciones adicionales y capas de seguridad que exploraremos m√°s adelante. Estos recursos te proporcionar√°n una mejor comprensi√≥n del concepto de <strong>AA</strong> y del <strong>ERC-4337</strong>.</em></p>
<p><strong>¬°As√≠ que sin m√°s pre√°mbulos, bienvenidos a Starknet!</strong></p>
<p>En el ecosistema de Starknet, se encuentran diversas metodolog√≠as para generar claves y firmas. A diferencia de las cuentas EOA, en Starknet se emplea <strong>Account Abstraction</strong> <a href="https://book.starknet.io/chapter_5/index.html"><strong>(AA)</strong></a> para la implementaci√≥n de <strong>Contratct Accounts</strong> <a href="https://book.starknet.io/chapter_5/index.html#ethereums_current_account_system_a_closer_look">(CA)</a>. Estos contratos son responsables de establecer la l√≥gica en nuestras cuentas dentro de Starknet, incluyendo la validaci√≥n del esquema de firma abstra√≠do.</p>
<p>En lugar de utilizar ECDSA, Starknet utiliza una variaci√≥n llamada [<strong>STARK Curve</strong>], un tipo de curva el√≠ptica m√°s amigable y optimizada que es nativa en en el ecosistema, esta variante nos ofrece mejoras y caracter√≠sticas espec√≠ficas para las necesidades de Starknet.</p>
<p>Lo grandioso de tener esta abstracci√≥n nativa es que permite a√±adir diferentes l√≥gicas en tus esquemas o capas adicionales. Normalmente, se utiliza el sistema asim√©trico <code>secp256k1</code>, basado en la aleatoriedad y operaciones matem√°ticas, para generar claves privadas y p√∫blicas. Sin embargo, tambi√©n se pueden a√±adir curvas adicionales de forma nativa al crear un CA, como lo ha hecho Braavos con la <a href="https://github.com/myBraavos/efficient-secp256r1">secp256r1</a>. Esta curva cuenta con un sistema de firmas integrado, mejor optimizado y preparado para dispositivos modernos, donde el signer puede almacenar los datos habilitados por biometricidad en dispositivos aislados y seguros, como el m√≥dulo &quot;Enclave&quot; de Apple.</p>
<p>La AA desempe√±a un papel crucial al abstraer el esquema de firmas o verificaci√≥n de firmas de la ejecuci√≥n. Como vimos anteriormente, ECDSA genera una clave privada y una clave p√∫blica que luego se cifran y se comparten p√∫blicamente, en este caso el poseedor de esta clave privada y del esquema de firma asociado tiene el poder de realizar transacciones en Starknet, los <a href="https://book.starknet.io/chapter_8/transactions.html">dos tipos de transacciones</a> son <code>DEPLOY</code> o <code>INVOKE</code></p>
<p><img src="./assets/Invoke.png" alt="graph" /></p>
<div align="center">
<em>Contrato de Cuenta de usuario</em>
</div>
<p>Con AA podemos modificar estas firmas o curvas. Por ejemplo, la curva <code>Secp256r1</code>, vimos que ofrece una seguridad adicional en Braavos al configurar una firma biom√©trica en el m√≥dulo de seguridad del enclave. De esta manera, esta firma biom√©trica solo puede ser a√±adida gracias a AA.</p>
<p>Todo esto es posible gracias al lenguaje de programaci√≥n utilizado en la implementaci√≥n, el poderoso <a href="https://starkware.co/cairo/"><strong>Cairo</strong></a>, as√≠ que analicemos c√≥mo Cairo incorpora esta abstracci√≥n en su programaci√≥n.</p>
<p>En primer lugar, se necesita validar la firma y comprobar que coincide con la generada mediante ECDSA antes de proceder a la ejecuci√≥n. Estas dos funciones principales son <code>validate</code> y <code>execute</code>. Adem√°s, <code>execute</code> tambi√©n puede realizar m√∫ltiples llamadas utilizando <code>execute_calls</code>.</p>
<p><img src="./assets/invoke_execute.gif" alt="graph" /></p>
<div align="center">
<em>Informaci√≥n de la L√≥gica separada de las funciones validate, execute</em>
</div>
<p>Cairo, as√≠ que analicemos c√≥mo Cairo incorpora esta abstracci√≥n en su programaci√≥n.</p>
<p>Veamos c√≥mo funciona un ciclo de transacci√≥n con AA nativa y c√≥mo se representa gr√°ficamente este ciclo completo de firmas para detectar si es correcto y realizar la operaci√≥n.</p>
<p>Tambi√©n pensemos en c√≥mo se podr√≠an combinar de manera eficiente firmas como ha realizado Braavos con la EC <code>secp256r1</code> o incluso realizar la verificaci√≥n de firmas, como vimos con Lattice para prevenir ataques cu√°nticos.</p>
<p><img src="./assets/transaccion.gif" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validaci√≥n de una trnasacci√≥n</em>
</div>
<p>Los conocimientos previos adquiridos nos han ense√±ado muchas cosas, una de ellas es c√≥mo Shor puede te√≥ricamente romper ECDSA, pero no podr√° romper una prueba STARKs, como veremos en la secci√≥n de generaci√≥n de STARKs, gracias a sus bases de criptograf√≠a sim√©trica y otras variables. Sin embargo, si alguien nos roba, hackea o perdemos la cuenta, el esquema <strong>PQS</strong> para la prueba no ser√° de mucha utilidad, ya que no se ha alterado la integridad del estado de los datos. Solo se habr√° obtenido tu PK, lo que permitir√≠a mover los fondos de forma justa.</p>
<p><strong>Pero, ¬øqu√© suceder√≠a si tuvi√©ramos un esquema de verificaci√≥n de firmas seguro frente a un ataque cu√°ntico?</strong></p>
<p>Aqu√≠ es donde entran en juego peque√±os cambios, espec√≠ficamente en la parte de validaci√≥n y no de ejecuci√≥n, con las mejoras en Starknet y con la ayuda de AA nativo, est√° implementando para prepararse para el futuro. Una posibilidad ser√≠a el uso de Lattice o Kyber, aunque el futuro no est√° escrito, as√≠ que ha llegado el momento de ver c√≥mo se genera la parte de la EC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-en-cairo---stark-curve"><a class="header" href="#ec-en-cairo---stark-curve">EC en Cairo - STARK Curve</a></h1>
<p>Como hemos visto en el contexto de los sistemas criptogr√°ficos, la elecci√≥n de la curva el√≠ptica adecuada es de suma importancia. En este caso, se utiliza una variante de EC la cual ha sido especialmente dise√±ada y optimizada para su aplicaci√≥n en el entorno de Starknet.</p>
<p>La STARK Curve <a href="https://github.com/starkware-libs/cairo-lang/blob/361fe32d5930db340ea78fe05aedfe706f6c9405/src/starkware/cairo/common/ec.cairo"><strong>(EC.cairo)</strong></a> se define mediante la ecuaci√≥n:</p>
<p><img src="./assets/stark_curve.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Los valores espec√≠ficos de <code>Œ±</code>, <code>Œ≤</code> y <code>p</code> utilizados en esta curva han sido cuidadosamente seleccionados para proporcionar propiedades criptogr√°ficas s√≥lidas y un rendimiento eficiente en el contexto de los contratos de cuenta nativos en Starknet.</p>
<p>En particular, los valores de <code>Œ±</code>, <code>Œ≤</code> (notese que es <code>œÄ</code> ‚ÄúPI‚Äù sin decimales usando 67 digitos) y <code>p</code> son los siguientes:</p>
<p><img src="./assets/stark_curve1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Estos valores aseguran que la curva el√≠ptica Stark-friendly cumple con los requisitos de seguridad necesarios para su aplicaci√≥n en sistemas criptogr√°ficos.</p>
<p>Adem√°s se utiliza un punto generador <a href="https://docs.starkware.co/starkex/crypto/stark-curve.html">(G)</a> espec√≠fico asociado a esta curva. El punto generador <code>G</code> se define como:</p>
<p><img src="./assets/stark_curve_g.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Este punto generador desempe√±a un papel fundamental en el esquema de firmas digitales ECDSA, permitiendo la generaci√≥n de claves p√∫blicas y privadas como aprendimos en Generador de Claves, as√≠ como la verificaci√≥n de firmas digitales en el contexto de la curva el√≠ptica Stark-friendly.</p>
<p>La elecci√≥n de la curva el√≠ptica Stark-friendly y el punto generador <code>G</code> asociado a ella proporcionan una base s√≥lida y optimizada para la implementaci√≥n de esquemas criptogr√°ficos en el entorno de Starknet. Estos elementos garantizan la seguridad y eficiencia necesarias para la creaci√≥n de contratos de cuenta nativos y la verificaci√≥n de firmas digitales en el sistema.</p>
<p>Si desea probar y adentrarse en el despliegue de cuentas en Starknet, o si est√° interesado en aprender c√≥mo se generan y calculan off-chain, y luego financiar esas cuentas para que los contratos de cuenta se autodesplieguen, le animamos a seguir los ejercicios oficiales de <a href="https://github.com/starknet-edu/starknet-accounts/blob/answers/ES%20README.md"><strong>Starknet-Edu Account</strong></a> o las <a href="https://github.com/Nadai2010/Nadai-StarknetEs-Guia-Cairo1#configuraci%C3%B3n-de-una-cuenta"><strong>Gu√≠as Completas Cairo 1</strong></a> proporcionadas por <a href="https://twitter.com/StarkNetEs">Starknet-Es</a> para realizar pruebas reales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-braavos---secp256r1"><a class="header" href="#my-braavos---secp256r1">My Braavos - Secp256r1</a></h1>
<p>Emepecemos con un dato que no hab√≠amos comentando antes, la <code>k</code> en <code>sepc256k1</code> significa <a href="https://es.wikipedia.org/wiki/Neal_Koblitz"><strong>Koblitz</strong></a>¬†y el <code>r</code> en <code>sepc256r1</code> significa aleatorio.</p>
<p>Braavos ha incorporado la firma y validaci√≥n de transacciones utilizando <code>secp256r1</code>, lo que brinda una excelente experiencia al usuario final al permitir transacciones con firma biom√©trica en el dispositivo del usuario. Esto a√±ade un nivel adicional de seguridad. Braavos ha presentado en su blog una <a href="https://braavos.app/account-abstraction-security-pyramid/">Pir√°mide de Seguridad AA</a>.</p>
<p><img src="./assets/Mybraavos.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Podemos ver en la c√∫spide de la pir√°mide al Multi-Signer (3FA). El Multi-Signer combina la protecci√≥n de la frase de recuperaci√≥n (seed phrase) en la extensi√≥n del navegador y el Hardware Signer o Protected Signer utilizando el dispositivo m√≥vil.</p>
<p>Ahora se requieren dos firmas de dos claves diferentes para ejecutar la transacci√≥n en la cadena, obteniendo una autenticaci√≥n de 3FA:</p>
<ul>
<li><strong>Algo que sabemos:</strong> la clave derivada de tu frase de recuperaci√≥n en la extensi√≥n del navegador.</li>
<li><strong>Algo que tenemos:</strong> tu dispositivo m√≥vil.</li>
<li><strong>Algo que somos:</strong> tu huella dactilar o identificaci√≥n biom√©trica facial.</li>
</ul>
<p>Cabe destacar que aunque se ha agregado otro firmante, no se ha a√±adido otra seed phrase, esto tambi√©n tiene el beneficio adicional de alejarse de las seed phrase a una mejor seguridad en los dispositivos m√≥viles/computadoras port√°tiles modernas, y seguridad superior cuando el dispositivo del usuario admite un chip de seguridad dedicado, como el <a href="https://cloud.google.com/blog/products/identity-security/titan-in-depth-security-in-plaintext">elemento seguro Titan de Android</a> o <a href="https://support.apple.com/es-us/guide/security/sec59b0b31ff/web">Enclave Secure de Apple</a>, etc.</p>
<p>Este chip Secure Enclave/Titan es un subsistema dedicado y aislado, totalmente separado del procesador de aplicaciones que puede generar claves privadas y mensajes de signo. Genera las teclas utilizando un generador interno de n√∫meros aleatorios verdaderos <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator"><strong>(TRNG)</strong></a> y firma mensajes a trav√©s de la curva el√≠ptica <code>secp256r1</code> a trav√©s de su acelerador interno de claves p√∫blicas <a href="https://www.rambus.com/security/crypto-accelerator-cores/pka-ip-28/"><strong>(PKA)</strong></a>. Las claves privadas nunca abandonan el sistema seguro y son desconocidas / inaccesibles para cualquier persona, ni siquiera para el usuario o para la aplicaci√≥n en s√≠.</p>
<p>Esto significa que incluso si el n√∫cleo del procesador de la aplicaci√≥n del dispositivo se ve comprometido, <strong>¬°Nuestras claves se mantendr√°n seguras!</strong></p>
<p><img src="./assets/Enclave.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Vemos que esta implementaci√≥n de la firma ECDSA <code>secp256r1</code> en Cairo no es nativa, lo que significa que no tiene un Builtin dedicado nativo, esto puede llevar a un alto costo de gas al validar la firma. Sin embargo, Braavos es uno de los que han adoptado esta maravillosa novedad y est√° trabajando en mejorar la eficiencia de este proceso.</p>
<p>dem√°s, aprovechando la funcionalidad de Multi-Call incorporada, los usuarios pueden agrupar m√∫ltiples transacciones en una √∫nica transacci√≥n at√≥mica. Esto no solo acelera y reduce los costos de las transacciones, sino que tambi√©n permite a los usuarios aprobar la cantidad exacta que desean depositar, lo cual mejora la seguridad al eliminar la necesidad de <a href="https://hackernoon.com/erc20-infinite-approval-a-battle-between-convenience-and-security-lk60350r">aprobaci√≥n infinita</a></p>
<p>En cuanto a la <strong>gesti√≥n de firmantes</strong>, cuando se a√±ade un firmante adicional, como un Hardware Signer o Protected Signer, el firmante original basado en semillas ya no puede firmar transacciones, a menos que se solicite la eliminaci√≥n del firmante adicional y se regrese al firmante basado en semillas. <strong>Esta solicitud tiene un retraso de tiempo (actualmente de 4 d√≠as)</strong> para su procesamiento.</p>
<p>Por otro lado, la funci√≥n de multifirma permite configurar la cuenta en modo de multifirma (actualmente admite 2 de 2), lo que significa que ninguna transacci√≥n se ejecutar√° hasta que los 2 firmantes definidos en la cuenta firmen la transacci√≥n. La seed phrase puede solicitar la desactivaci√≥n de la multifirma, pero esto <strong>tambi√©n tiene un retraso de tiempo (actualmente 4 d√≠as)</strong> antes de que se haga efectiva.</p>
<p>Vemos la importancia de las firmas y como vimos en el contexto del PQS, entendemos la relevancia de poder modificar nuestros esquemas de verificaci√≥n de firmas, como la utilizaci√≥n de Lattice o Kyber, por ejemplo. Ahora, centr√©monos en aprender c√≥mo creamos una Stark Key para StarkEx, el motor de escalabilidad de Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creaci√≥n-de-una-stark-key-en-starkex"><a class="header" href="#creaci√≥n-de-una-stark-key-en-starkex">Creaci√≥n de una Stark Key en StarkEx</a></h1>
<p>Es importante comprender c√≥mo <a href="https://mirror.xyz/dashboard/edit/KJVQJ6X6wvbf6ps1oy96zpE3TztWyhSIDZd2IHu5NuI">StarkEx</a> se comunica con otras billeteras en t√©rminos de firmas, y c√≥mo mantiene todo el motor de transacciones y pruebas STARKs en su interior.</p>
<p>StarkEx ofrece soluciones altamente especializadas para diferentes aplicaciones que deseen construir sobre su servicio, y esto es parte de lo que StarkWare, como compa√±√≠a, proporciona a grandes empresas o cualquier otra entidad que desee aprovechar su conjunto de profesionales y servicios adaptables.</p>
<p>Aplicaciones populares como Sorare, Rhino y Apex Pro, por ejemplo, aprovechan las soluciones ofrecidas por StarkWare. Estas aplicaciones espec√≠ficas se construyen sobre el marco de Starknet. Si bien no profundizaremos en los detalles espec√≠ficos de estas aplicaciones aqu√≠, se recomienda visitar la <a href="https://layer2es.notion.site/39d63a8af9ca4524a7237b1f2456e745">Biblioteca de Layer 2 en Espa√±ol</a> para obtener informaci√≥n m√°s detallada sobre cada una de ellas y comprender mejor c√≥mo se integran en las soluciones de escalado de capa 2 de Ethereum.</p>
<p>Para utilizar StarkEx y asociar tu cuenta de MetaMask u otra billetera a Starknet, es necesario crear una Stark Key. StarkEx admite diferentes tipos de billeteras y m√©todos para crear esta clave, dependiendo de c√≥mo se utilizar√° posteriormente. A continuaci√≥n, se detallan las opciones disponibles:</p>
<h2 id="billeteras-compatibles-con-bip32"><a class="header" href="#billeteras-compatibles-con-bip32">Billeteras compatibles con BIP32</a></h2>
<p>Si est√°s utilizando una billetera compatible con <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki"><strong>BIP32</strong></a>, como Ledger, se recomienda seguir el EIP-2645. Este est√°ndar describe una ruta denominada <code>starkPath</code> y un algoritmo de derivaci√≥n de clave que utiliza esta ruta para obtener la <code>starkPrivateKey</code>.</p>
<p>La <code>starkPath</code> est√° compuesta por cuatro par√°metros pasados y dos par√°metros internos, y sigue la siguiente estructura:</p>
<p><code>m/purpose'/layer'/application'/ethAddress1'/ethAddress2'/index</code></p>
<p>Los par√°metros externos pasados son los siguientes:</p>
<ul>
<li><strong>Purpose:</strong> el n√∫mero de EIP correspondiente (en este caso, 2645).</li>
<li><strong>Layer:</strong> se utiliza para diferenciar entre tecnolog√≠as y se calcula como <code>sha256(layer) &amp; ((1 &lt;&lt; 31) - 1))</code>. En el contexto de StarkEx, el valor es <code>579218131</code> seg√∫n lo descrito en el EIP-2645.</li>
<li><strong>Application:</strong> sirve para diferenciar entre aplicaciones y se calcula como: <code>sha256(application_name) &amp; ((1 &lt;&lt; 31) - 1))</code>.</li>
<li><strong>Index:</strong> permite tener m√∫ltiples claves por direcci√≥n de Ethereum.</li>
</ul>
<p>Los par√°metros internos usados son los siguientes:</p>
<ul>
<li><strong>ethAddress1:</strong> Los 31 LSB de la direcci√≥n Ethereum del usuario, es decir, <code>(ethAddress &amp; 1 &lt;&lt; 31) - 1</code></li>
<li><strong>ethAddress2:</strong> Los 31 LSB siguientes de la direcci√≥n Ethereum del usuario, es decir, <code>(ethAddress &gt;&gt; 31) &amp; 1 &lt;&lt; 31) - </code>.</li>
</ul>
<p>Adem√°s, es importante que las billeteras compatibles con BIP32 mantengan un estado persistente en relaci√≥n con su propia direcci√≥n de Ethereum.</p>
<h2 id="billeteras-no-compatibles-con-bip32"><a class="header" href="#billeteras-no-compatibles-con-bip32">Billeteras NO compatibles con BIP32</a></h2>
<p>Si est√°s utilizando una billetera que no es compatible con BIP32, como MetaMask, se recomienda seguir el siguiente proceso:</p>
<ol>
<li>El usuario firma un mensaje utilizando su clave privada de Ethereum a trav√©s de MetaMask u otra billetera similar. Se recomienda utilizar el est√°ndar  IP-712 para brindar transparencia al usuario durante el proceso de firma. Es importante que el mensaje incluya una advertencia, indicando al usuario que so1lo debe firmarlo si proviene de un dominio espec√≠fico.</li>
<li>La firma <code>(r, s, v)</code> se utiliza como entrada para el algoritmo de derivaci√≥n de clave, que generar√° la <code>starkPrivateKey</code>. Para realizar este c√°lculo, puedes utilizar la biblioteca <a href="https://www.npmjs.com/package/@starkware-industries/starkware-crypto-utils">StarkEx Crypto SDK</a>. Primero, llama a la funci√≥n <code>getPrivateKeyFromEthSignature</code> para obtener la clave privada a partir de la firma, y luego utiliza la funci√≥n <code>privateToStarkKey</code> para calcular la <code>StarkKey</code>.</li>
</ol>
<p>Al seguir estos pasos, podr√°s crear una Stark Key asociada a tu cuenta de MetaMask u otra billetera compatible. Esta clave te permitir√° interactuar con StarkEx y otras aplicaciones dentro del ecosistema de Starknet, realizar transacciones seguras y aprovechar las funcionalidades ofrecidas por esta plataforma.</p>
<p><img src="./assets/Stark_Key.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-y-funciones-hash"><a class="header" href="#starknet-y-funciones-hash">Starknet y Funciones Hash</a></h1>
<p>Hemos visto la importancia de las firmas, el poder de AA y la asociaci√≥n de los hash dentro del ecosistema de Starknet y StarkEx. Ahora, profundicemos en c√≥mo se utilizan y los diferentes tipos de hash que podemos encontrar.</p>
<h2 id="dominio-y-rango"><a class="header" href="#dominio-y-rango">Dominio y rango</a></h2>
<p>Todas las salidas de las funciones de hash se mapean eventualmente a elementos en <code>ùîΩ‚Çö</code> con <code>p = 2¬≤‚Åµ¬π + 17 ‚ãÖ 2¬π‚Åπ¬≤ + 1</code>  como vimos en la Stark Curve.</p>
<p>Las funciones hash son componentes clave en las especificaciones de Starknet, y se utilizan para mapear las salidas de los c√°lculos a elementos en el campo finito <code>ùîΩ‚Çö</code>. A continuaci√≥n, explicaremos las tres funciones hash utilizadas en Starknet de manera m√°s clara:</p>
<p><img src="./assets/Stark_func_hash.png" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validaci√≥n de una trnasacci√≥n</em>
</div>
<ol>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#starknet_keccak"><strong>sn_keccak:</strong></a> Esta funci√≥n hash se basa en el algoritmo KECCAK, que es una familia de funciones hash criptogr√°ficas como vimos antes. Su dominio es el conjunto de cadenas de bits compuestas por ceros y unos <code>{0,1}*</code> y su rango es el campo finito <code>ùîΩ‚Çö</code> La funci√≥n toma una cadena de bits como entrada y produce una salida en el campo finito <code>ùîΩ‚Çö</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash"><strong>Pedersen:</strong></a> La funci√≥n hash Pedersen es una funci√≥n hash computacionalmente segura que se utiliza en la construcci√≥n de criptograf√≠a de compromiso cero y otras primitivas criptogr√°ficas. Su dominio es el conjunto de pares de elementos del campo finito <code>ùîΩ¬≤p</code>, donde <code>p</code> es un n√∫mero primo, y su rango es el campo finito <code>ùîΩp</code>. La funci√≥n toma un par de elementos del campo finito <code>ùîΩ¬≤p</code> como entrada y produce una salida en el campo finito <code>ùîΩp</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#poseidon_hash"><strong>Poseidon:</strong></a> La funci√≥n hash Poseidon es una funci√≥n hash criptogr√°fica dise√±ada para resistir ataques criptogr√°ficos, como los ataques de preimagen y colisi√≥n. Su dominio es un conjunto de elementos del campo finito <code>ùîΩp</code>, que incluye el cero y los elementos inversos multiplicativos, y su rango tambi√©n es el campo finito <code>ùîΩp</code>. La funci√≥n toma un conjunto de elementos del campo finito <code>ùîΩp</code> como entrada y produce una salida en el campo finito <code>ùîΩp</code>.</li>
</ol>
<p>Las funciones de hash mencionadas son a√±adidas como <a href="https://mirror.xyz/0x7D1c14939AcEE5ca141c8beDF3474AFBf3884041/RTgQnMxeVGRCczih1pGXKy2KGFcU_xmf2NMx52wDgH0"><strong>Builtin</strong></a> (AIR integradas espec√≠ficas de aplicaciones), que se utilizan como herramientas adicionales en el protocolo para garantizar la seguridad y la integridad de las transacciones y los datos.</p>
<p>Estas funciones hash desempe√±an un papel fundamental en las operaciones de Starknet al garantizar la integridad y seguridad de los c√°lculos realizados en el sistema.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak-starknet"><a class="header" href="#keccak-starknet">Keccak Starknet</a></h1>
<p>Keccak en Starknet es una implementaci√≥n espec√≠fica de la funci√≥n hash <code>Keccak256</code> adaptada para su uso en la red Starknet. Proporciona un m√©todo confiable y eficiente para calcular hashes dentro del entorno de Starknet.</p>
<p>Generalmente denotado por <code>sn_keccak</code>, se define como los primeros <strong>250 bits del hash Keccak256</strong> (esto es simplemente <code>Keccak256</code> ampliado para ajustarse a un field element ‚Äúelemento de campo‚Äù).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen-hash-starknet"><a class="header" href="#pedersen-hash-starknet">Pedersen Hash Starknet</a></h1>
<p>El <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash">Pedersen hash</a> es una funci√≥n hash criptogr√°fica utilizada en criptograf√≠a y criptograf√≠a de curvas el√≠pticas. Fue propuesto por Torben Pedersen en 1991 y se utiliza para calcular hashes de datos.</p>
<p>Uno de los aspectos interesantes del <a href="https://en.wikipedia.org/wiki/Commitment_scheme">esquema de compromiso de Pedersen</a> es su propiedad homom√≥rfica, que permite realizar la adici√≥n entre dos compromisos. En otras palabras, dados dos mensajes <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code>, y sus respectivas aleatoriedades <code>r‚ÇÅ</code> y <code>r‚ÇÇ</code>, el Pedersen hash permite combinarlos de manera segura.</p>
<p>La funci√≥n Pedersen Hash utilizada en Starknet es resistente a colisiones para entradas de longitud fija, siempre y cuando la funci√≥n de codificaci√≥n subyacente sea inyectiva. Una funci√≥n inyectiva asigna elementos distintos de su dominio a elementos distintos de su codominio, esto hace que el Pedersen hash sea resistente a ciertos tipos de ataques, como colisiones y preim√°genes.</p>
<p>Sin embargo, es importante destacar que la implementaci√≥n y el contexto en el que se utilice esta funci√≥n pueden influir en su resistencia. Para obtener m√°s informaci√≥n se recomienda realizar una lectura sobre <a href="https://research.nccgroup.com/2023/03/22/breaking-pedersen-hashes-in-practice/">Pedersen hashes in Practice</a>.</p>
<p>En Starknet, se utiliza la EC amigable STARK curve sobre el campo finito <code>ùîΩ‚Çö</code> para calcular el Pedersen hash de manera eficiente y segura.</p>
<p><img src="./assets/Pedersen_Starknet.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<ul>
<li>Œ± = 1</li>
<li>Œ≤ = 31415926535897932384626433832795028841971693993751058209749 44592307816406665</li>
</ul>
<p>Los par√°metros <code>Œ±</code> y <code>Œ≤</code> de la curva son importantes en t√©rminos de seguridad y eficiencia en los algoritmos utilizados en la construcci√≥n del Pedersen hash y los protocolos de ZKP o basados en STARK.</p>
<p>Dada una entrada <code>(a, b) ‚àà ùîΩ¬≤p</code>, se divide en <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, donde la parte <code>low</code> consiste en los <strong>248 bits menos significativos del elemento</strong> y la parte <code>high</code> consiste en los <strong>4 bits m√°s significativos del elemento.</strong> El c√°lculo del Pedersen hash se define de la siguiente manera:</p>
<p><img src="./assets/Pedersen_Starknet1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En esta f√≥rmula, <code>[P]x</code> denota la coordenada <code>x</code> del punto <code>P</code>. Para calcular el hash, se realiza una combinaci√≥n lineal de los puntos <code>P0, P1, P2 y P3</code>, ponderados por los valores <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, respectivamente. Luego, se suma el punto <code>shift_point</code> y se extrae la coordenada <code>x</code> del resultado.</p>
<p>Los valores de las constantes <code>shift_point</code>, <code>P0</code>, <code>P1</code>, <code>P2</code> y <code>P3</code> se encuentran en el archivo <a href="https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/crypto/signature/fast_pedersen_hash.py">fast_pedersen_hash.py</a>. Este archivo contiene la implementaci√≥n espec√≠fica del algoritmo necesario para calcular el Pedersen hash.</p>
<p>No se trata de puntos en la EC en s√≠ misma, sino de valores espec√≠ficos que se han elegido para el c√°lculo del hash y tampoco est√°n relacionadas con la EC ni con el punto generador <code>G</code>, revise minuciosamente la informaci√≥n oficial en caso de querer hacer pruebas sobre Stark Curve o Hash en Starknet. Estas constantes se eligen de forma independiente para el c√°lculo del hash y se utilizan en combinaci√≥n con los valores de entrada para obtener el hash resultante.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
